{"config":{"indexing":"full","lang":["en","fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"alternatives/","text":"Alternatives & Comparison In this section, we will explore what inspired Confit and how it compares to other alternative Python packages. Confection Confection (originally part of the Thinc library) is another configuration framework from which Confit takes most of its inspiration. Both Confit and Confection support loading and exporting configuration data from/to strings or config files, as well as basic interpolation and custom class instantiation from a registry. However, Confit takes it a step further by allowing arbitrary expression evaluation, post-resolution interpolation, and exporting features such as saving to strings or config files, serialization of JSON-like objects, custom classes, and reference serialization. Confit also adds support for command-line interfaces by either passing a config file as an argument or by passing arguments (or overrides) directly to the CLI, while benefiting from argument validation and type casting. Gin-config Gin Config is a flexible configuration system built for machine learning research. Like Confit and Confection, gin-config supports basic interpolation and custom class instantiation and offers CLI support. However, it does not provide exporting configuration objects functionalities like Confit does or parameter validation. Typer Typer is a CLI library that focuses on providing easy-to-use functionalities for building command-line interface. While Typer offers excellent CLI support and basic argument validation, it does not have configuration file-related features such as loading, exporting, or parameter validation like Confit does. Confit relies on Typer for its CLI support, but adds config file arguments and instantiating classes from a registry, both of which are not available in Typer. However, if your primary focus is on building a robust CLI, Typer is a strong alternative. Pydantic-CLI Pydantic-CLI is another CLI library that combines Pydantic and argparse for creating command-line interfaces. Pydantic-CLI provides CLI support and argument validation, similar to Typer. However, it does not have any configuration file-related features like Confit does, nor does it allow instantiating custom classes. Tabular comparison Loading Feature Confit Confection Gin Typer Pydantic-cli Load from str/config file Basic interpolation NA NA Arbitrary expression eval NA NA Post-resolution interpolation NA NA Custom class instantiation NA NA Exporting Feature Confit Confection Gin Typer Pydantic-cli Save to str/config file Serialization of JSON-like obj NA NA NA Serialization of custom classes NA NA NA Reference serialization NA NA NA CLI Feature Confit Confection Gin Typer Pydantic-cli CLI support CLI short-hands NA Argument validation NA Config file argument NA Parameter validation Feature Confit Confection Gin Typer Pydantic-cli Parameter validation support Auto casting NA From a Python func/class call NA","title":"Alternatives & Comparison"},{"location":"alternatives/#alternatives-comparison","text":"In this section, we will explore what inspired Confit and how it compares to other alternative Python packages.","title":"Alternatives &amp; Comparison"},{"location":"alternatives/#confection","text":"Confection (originally part of the Thinc library) is another configuration framework from which Confit takes most of its inspiration. Both Confit and Confection support loading and exporting configuration data from/to strings or config files, as well as basic interpolation and custom class instantiation from a registry. However, Confit takes it a step further by allowing arbitrary expression evaluation, post-resolution interpolation, and exporting features such as saving to strings or config files, serialization of JSON-like objects, custom classes, and reference serialization. Confit also adds support for command-line interfaces by either passing a config file as an argument or by passing arguments (or overrides) directly to the CLI, while benefiting from argument validation and type casting.","title":"Confection"},{"location":"alternatives/#gin-config","text":"Gin Config is a flexible configuration system built for machine learning research. Like Confit and Confection, gin-config supports basic interpolation and custom class instantiation and offers CLI support. However, it does not provide exporting configuration objects functionalities like Confit does or parameter validation.","title":"Gin-config"},{"location":"alternatives/#typer","text":"Typer is a CLI library that focuses on providing easy-to-use functionalities for building command-line interface. While Typer offers excellent CLI support and basic argument validation, it does not have configuration file-related features such as loading, exporting, or parameter validation like Confit does. Confit relies on Typer for its CLI support, but adds config file arguments and instantiating classes from a registry, both of which are not available in Typer. However, if your primary focus is on building a robust CLI, Typer is a strong alternative.","title":"Typer"},{"location":"alternatives/#pydantic-cli","text":"Pydantic-CLI is another CLI library that combines Pydantic and argparse for creating command-line interfaces. Pydantic-CLI provides CLI support and argument validation, similar to Typer. However, it does not have any configuration file-related features like Confit does, nor does it allow instantiating custom classes.","title":"Pydantic-CLI"},{"location":"alternatives/#tabular-comparison","text":"","title":"Tabular comparison"},{"location":"alternatives/#loading","text":"Feature Confit Confection Gin Typer Pydantic-cli Load from str/config file Basic interpolation NA NA Arbitrary expression eval NA NA Post-resolution interpolation NA NA Custom class instantiation NA NA","title":"Loading"},{"location":"alternatives/#exporting","text":"Feature Confit Confection Gin Typer Pydantic-cli Save to str/config file Serialization of JSON-like obj NA NA NA Serialization of custom classes NA NA NA Reference serialization NA NA NA","title":"Exporting"},{"location":"alternatives/#cli","text":"Feature Confit Confection Gin Typer Pydantic-cli CLI support CLI short-hands NA Argument validation NA Config file argument NA","title":"CLI"},{"location":"alternatives/#parameter-validation","text":"Feature Confit Confection Gin Typer Pydantic-cli Parameter validation support Auto casting NA From a Python func/class call NA","title":"Parameter validation"},{"location":"changelog/","text":"Changelog v0.5.3 Changed We now raise an error if a value in the config cannot be deserialized as a JSON object but contains characters that hint at a JSON object (e.g. quotes, brackets, etc.). This changes the old behavior where we would silently ignore the value and keep the string as is. Fixed Allow complex interpolations like ${[*section.\"key.with.dot\", \"baz\"]} v0.5.2 Changed Keys with dots (or path-like keys in general) will be escaped when serializing a config { \"section\" : { \"deep.key\" : \"ok\" }} will be serialized as [section] 'deep.key' = \"ok\" v0.5.1 Added Use context instead of func for set_seed to allow with set_seed ( 42 ): # do stuff num = random . randint ( 0 , 100 ) Add auto-reload plugin to work with confit wrapped functions in notebooks v0.5.0 Added deprecated parameter to register an object under multiple names with deprecation warnings Fixed Stop interpreting type errors as validation errors when executing a validated function v0.4.3 - 31-08-2023 Fixed Save var kwargs as separate fields v0.4.2 - 31-08-2023 Fixed Re-enable extra/duplicate arg errors and uniformize between pydantic v1/v2 Add pydantic-core dependency for jsonable types during dump v0.4.1 - 29-08-2023 Fixed Use pydantic v2 context error only if it is an exception v0.4.0 - 29-08-2023 Added Improve validation errors merging and display. By default, confit related frames and exception causes in the traceback are hidden. Show inner-confit traceback and exception chains if CONFIT_DEBUG env var is true Support for both Pydantic v2 and v1 Fixed If the seed is given a default value in CLI, it can now be used by confit when no seed is given v0.3.0 - 25-08-2023 Allow keyword only parameters Avoid import of all entry points by catalogue during failed registry lookup Fix bug in serialization, leading to mixed config fields v0.2.1 - 11-05-2023 Fix un-allowed kwargs: accepted signatures are fn(paramA, paramB=..., ... **kwargs) v0.2.0 - 05-04-2023 Config.merge(...) now only copies collections (not the underlying data) and doesn't split keys around dots __path__ option has been removed (having a override_structure in .to_str() would be better) Allow to skip some parameters when storing config before resolution Allow to resolve only a part of a configuration Improve serialization (can refer to dict/tuple/list objects now) and merge the instance's .cfg attribute (which can be updated by the instance) with the stored config Add the invoker option to .register(...) to modify the arguments of the call to the registered function or do something with the result User defined class registry should now inherit from RegistryCollection v0.1.5 - 02-03-2023 Verify the signature when registering rather than during a call Allow **kwargs v0.1.4 - 27-02-2023 More robust resolution algorithm Cyclic reference detection Extended JSON syntax reading & writing (tuple & nested refs) Fix lists and tuple parsing Fix multi registration Fix inheritance between registered classes Multilingual doc & improved docs style v0.1.1 - 06-01-2023 Features Enhanced references capabilities v0.1.0 - 30-12-2022 Inception ! Features Config object with pre-resolve typer CLI wrappers catalogue registries ...","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v053","text":"","title":"v0.5.3"},{"location":"changelog/#changed","text":"We now raise an error if a value in the config cannot be deserialized as a JSON object but contains characters that hint at a JSON object (e.g. quotes, brackets, etc.). This changes the old behavior where we would silently ignore the value and keep the string as is.","title":"Changed"},{"location":"changelog/#fixed","text":"Allow complex interpolations like ${[*section.\"key.with.dot\", \"baz\"]}","title":"Fixed"},{"location":"changelog/#v052","text":"","title":"v0.5.2"},{"location":"changelog/#changed_1","text":"Keys with dots (or path-like keys in general) will be escaped when serializing a config { \"section\" : { \"deep.key\" : \"ok\" }} will be serialized as [section] 'deep.key' = \"ok\"","title":"Changed"},{"location":"changelog/#v051","text":"","title":"v0.5.1"},{"location":"changelog/#added","text":"Use context instead of func for set_seed to allow with set_seed ( 42 ): # do stuff num = random . randint ( 0 , 100 ) Add auto-reload plugin to work with confit wrapped functions in notebooks","title":"Added"},{"location":"changelog/#v050","text":"","title":"v0.5.0"},{"location":"changelog/#added_1","text":"deprecated parameter to register an object under multiple names with deprecation warnings","title":"Added"},{"location":"changelog/#fixed_1","text":"Stop interpreting type errors as validation errors when executing a validated function","title":"Fixed"},{"location":"changelog/#v043-31-08-2023","text":"","title":"v0.4.3 - 31-08-2023"},{"location":"changelog/#fixed_2","text":"Save var kwargs as separate fields","title":"Fixed"},{"location":"changelog/#v042-31-08-2023","text":"","title":"v0.4.2 - 31-08-2023"},{"location":"changelog/#fixed_3","text":"Re-enable extra/duplicate arg errors and uniformize between pydantic v1/v2 Add pydantic-core dependency for jsonable types during dump","title":"Fixed"},{"location":"changelog/#v041-29-08-2023","text":"","title":"v0.4.1 - 29-08-2023"},{"location":"changelog/#fixed_4","text":"Use pydantic v2 context error only if it is an exception","title":"Fixed"},{"location":"changelog/#v040-29-08-2023","text":"","title":"v0.4.0 - 29-08-2023"},{"location":"changelog/#added_2","text":"Improve validation errors merging and display. By default, confit related frames and exception causes in the traceback are hidden. Show inner-confit traceback and exception chains if CONFIT_DEBUG env var is true Support for both Pydantic v2 and v1","title":"Added"},{"location":"changelog/#fixed_5","text":"If the seed is given a default value in CLI, it can now be used by confit when no seed is given","title":"Fixed"},{"location":"changelog/#v030-25-08-2023","text":"Allow keyword only parameters Avoid import of all entry points by catalogue during failed registry lookup Fix bug in serialization, leading to mixed config fields","title":"v0.3.0 - 25-08-2023"},{"location":"changelog/#v021-11-05-2023","text":"Fix un-allowed kwargs: accepted signatures are fn(paramA, paramB=..., ... **kwargs)","title":"v0.2.1 - 11-05-2023"},{"location":"changelog/#v020-05-04-2023","text":"Config.merge(...) now only copies collections (not the underlying data) and doesn't split keys around dots __path__ option has been removed (having a override_structure in .to_str() would be better) Allow to skip some parameters when storing config before resolution Allow to resolve only a part of a configuration Improve serialization (can refer to dict/tuple/list objects now) and merge the instance's .cfg attribute (which can be updated by the instance) with the stored config Add the invoker option to .register(...) to modify the arguments of the call to the registered function or do something with the result User defined class registry should now inherit from RegistryCollection","title":"v0.2.0 - 05-04-2023"},{"location":"changelog/#v015-02-03-2023","text":"Verify the signature when registering rather than during a call Allow **kwargs","title":"v0.1.5 - 02-03-2023"},{"location":"changelog/#v014-27-02-2023","text":"More robust resolution algorithm Cyclic reference detection Extended JSON syntax reading & writing (tuple & nested refs) Fix lists and tuple parsing Fix multi registration Fix inheritance between registered classes Multilingual doc & improved docs style","title":"v0.1.4 - 27-02-2023"},{"location":"changelog/#v011-06-01-2023","text":"","title":"v0.1.1 - 06-01-2023"},{"location":"changelog/#features","text":"Enhanced references capabilities","title":"Features"},{"location":"changelog/#v010-30-12-2022","text":"Inception !","title":"v0.1.0 - 30-12-2022"},{"location":"changelog/#features_1","text":"Config object with pre-resolve typer CLI wrappers catalogue registries ...","title":"Features"},{"location":"contributing/","text":"Contributing to Confit We welcome contributions ! There are many ways to help. For example, you can: Help us track bugs by filing issues Suggest and help prioritise new functionalities Help us make the library as straightforward as possible, by simply asking questions on whatever does not seem clear to you. Development installation To be able to run the test suite and develop your own pipeline, you should clone the repo and install it locally. color:gray # Clone the repository and change directory $ git clone ssh://git@github.com/aphp/confit.git ---> 100% $ cd confit color:gray # Install the library with its dev dependencies $ pip install -e \".[dev]\" To make sure the pipeline will not fail because of formatting errors, we added pre-commit hooks using the pre-commit Python library. To use it, simply install it: $ pre-commit install The pre-commit hooks defined in the configuration will automatically run when you commit your changes, letting you know if something went wrong. The hooks only run on staged changes. To force-run it on all files, run: $ pre-commit run --all-files ---> 100% color:green All good ! Proposing a merge request Ideally, your changes should : Be well-documented Pass every tests, and preferably implement their own Follow the style guide. Testing your code We use the Pytest test suite. The following command will run the test suite. Writing your own tests is encouraged ! python -m pytest Should your contribution propose a bug fix, we require the bug be thoroughly tested. Style Guide We use Black and Ruff to reformat the code. While other formatter only enforce PEP8 compliance, Black also makes the code uniform. In short : Black reformats entire files in place. It is not configurable. Moreover, the CI/CD pipeline enforces a number of checks on the \"quality\" of the code. To wit, non black-formatted code will make the test pipeline fail. We use pre-commit to keep our codebase clean. Refer to the development install tutorial for tips on how to format your files automatically. Most modern editors propose extensions that will format files on save. Documentation Make sure to document your improvements, both within the code with comprehensive docstrings, as well as in the documentation itself if need be. We use MkDocs for Confit's documentation. You can checkout the changes you make with: color:gray # Run the documentation $ mkdocs serve Go to localhost:8000 to see your changes. MkDocs watches for changes in the documentation folder and automatically reloads the page.","title":"Contributing to Confit"},{"location":"contributing/#contributing-to-confit","text":"We welcome contributions ! There are many ways to help. For example, you can: Help us track bugs by filing issues Suggest and help prioritise new functionalities Help us make the library as straightforward as possible, by simply asking questions on whatever does not seem clear to you.","title":"Contributing to Confit"},{"location":"contributing/#development-installation","text":"To be able to run the test suite and develop your own pipeline, you should clone the repo and install it locally. color:gray # Clone the repository and change directory $ git clone ssh://git@github.com/aphp/confit.git ---> 100% $ cd confit color:gray # Install the library with its dev dependencies $ pip install -e \".[dev]\" To make sure the pipeline will not fail because of formatting errors, we added pre-commit hooks using the pre-commit Python library. To use it, simply install it: $ pre-commit install The pre-commit hooks defined in the configuration will automatically run when you commit your changes, letting you know if something went wrong. The hooks only run on staged changes. To force-run it on all files, run: $ pre-commit run --all-files ---> 100% color:green All good !","title":"Development installation"},{"location":"contributing/#proposing-a-merge-request","text":"Ideally, your changes should : Be well-documented Pass every tests, and preferably implement their own Follow the style guide.","title":"Proposing a merge request"},{"location":"contributing/#testing-your-code","text":"We use the Pytest test suite. The following command will run the test suite. Writing your own tests is encouraged ! python -m pytest Should your contribution propose a bug fix, we require the bug be thoroughly tested.","title":"Testing your code"},{"location":"contributing/#style-guide","text":"We use Black and Ruff to reformat the code. While other formatter only enforce PEP8 compliance, Black also makes the code uniform. In short : Black reformats entire files in place. It is not configurable. Moreover, the CI/CD pipeline enforces a number of checks on the \"quality\" of the code. To wit, non black-formatted code will make the test pipeline fail. We use pre-commit to keep our codebase clean. Refer to the development install tutorial for tips on how to format your files automatically. Most modern editors propose extensions that will format files on save.","title":"Style Guide"},{"location":"contributing/#documentation","text":"Make sure to document your improvements, both within the code with comprehensive docstrings, as well as in the documentation itself if need be. We use MkDocs for Confit's documentation. You can checkout the changes you make with: color:gray # Run the documentation $ mkdocs serve Go to localhost:8000 to see your changes. MkDocs watches for changes in the documentation folder and automatically reloads the page.","title":"Documentation"},{"location":"getting-started/","text":"Getting started Installation Install the library with pip: $ pip install confit A simple example Confit only abstracts the boilerplate code related to configuration and leaves the rest of your code unchanged. Here is an example: script.py import datetime + from confit import Cli, Registry, RegistryCollection + app = Cli(pretty_exceptions_show_locals=False) + class RegistryCollection(: + factory = Registry((\"test_cli\", \"factory\"), entry_points=True) + @registry.factory.register(\"submodel\") class SubModel: # Type hinting is optional but recommended to benefit for argument casting ! def __init__(self, value: float, desc: str = \"\"): self.value = value self.desc = desc + @registry.factory.register(\"bigmodel\") class BigModel: def __init__(self, date: datetime.date, submodel: SubModel): self.date = date self.submodel = submodel + @app.command(name=\"script\", registry=registry) def func(modelA: BigModel, modelB: BigModel, other: int, seed: int): assert modelA.submodel is modelB.submodel assert modelA.date == datetime.date(2010, 10, 10) print(\"Other:\", other) + if __name__ == \"__main__\": + app() Create a new config file config.cfg # CLI sections [script] modelA = ${modelA} modelB = ${modelB} # CLI common parameters [modelA] @factory = \"bigmodel\" date = \"2010-10-10\" [modelA.submodel] @factory = \"submodel\" value = 12 [modelB] date = \"2003-04-05\" submodel = ${modelA.submodel} and run the following command from the terminal $ python script.py --config config.cfg --seed 42 Naming To use the name of your config path (e.g. config-expe-2 if the configuration file is named config-expe-2.cfg in the configuration (after resolution), simply mention name = None under the section which title was provided at @app.command(name=<section-title>) Multiple configurations You can pass multiple configuration files by repeating the --config option. Configuration will be merged in order. You can still call the function method from your code, but now also benefit from argument validation ! from script import func , BigModel , SubModel # To seed before creating the models from confit.utils.random import set_seed seed = 42 set_seed ( seed ) submodel = SubModel ( value = 12 ) # BigModel will cast date strings as datetime.date objects modelA = BigModel ( date = \"2003-02-01\" , submodel = submodel ) modelB = BigModel ( date = \"2003-04-05\" , submodel = submodel ) func ( modelA = modelA , modelB = modelA , seed = seed , )","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#installation","text":"Install the library with pip: $ pip install confit","title":"Installation"},{"location":"getting-started/#a-simple-example","text":"Confit only abstracts the boilerplate code related to configuration and leaves the rest of your code unchanged. Here is an example: script.py import datetime + from confit import Cli, Registry, RegistryCollection + app = Cli(pretty_exceptions_show_locals=False) + class RegistryCollection(: + factory = Registry((\"test_cli\", \"factory\"), entry_points=True) + @registry.factory.register(\"submodel\") class SubModel: # Type hinting is optional but recommended to benefit for argument casting ! def __init__(self, value: float, desc: str = \"\"): self.value = value self.desc = desc + @registry.factory.register(\"bigmodel\") class BigModel: def __init__(self, date: datetime.date, submodel: SubModel): self.date = date self.submodel = submodel + @app.command(name=\"script\", registry=registry) def func(modelA: BigModel, modelB: BigModel, other: int, seed: int): assert modelA.submodel is modelB.submodel assert modelA.date == datetime.date(2010, 10, 10) print(\"Other:\", other) + if __name__ == \"__main__\": + app() Create a new config file config.cfg # CLI sections [script] modelA = ${modelA} modelB = ${modelB} # CLI common parameters [modelA] @factory = \"bigmodel\" date = \"2010-10-10\" [modelA.submodel] @factory = \"submodel\" value = 12 [modelB] date = \"2003-04-05\" submodel = ${modelA.submodel} and run the following command from the terminal $ python script.py --config config.cfg --seed 42 Naming To use the name of your config path (e.g. config-expe-2 if the configuration file is named config-expe-2.cfg in the configuration (after resolution), simply mention name = None under the section which title was provided at @app.command(name=<section-title>) Multiple configurations You can pass multiple configuration files by repeating the --config option. Configuration will be merged in order. You can still call the function method from your code, but now also benefit from argument validation ! from script import func , BigModel , SubModel # To seed before creating the models from confit.utils.random import set_seed seed = 42 set_seed ( seed ) submodel = SubModel ( value = 12 ) # BigModel will cast date strings as datetime.date objects modelA = BigModel ( date = \"2003-02-01\" , submodel = submodel ) modelB = BigModel ( date = \"2003-04-05\" , submodel = submodel ) func ( modelA = modelA , modelB = modelA , seed = seed , )","title":"A simple example"},{"location":"","text":"Confit Confit is a complete and easy-to-use configuration framework aimed at improving the reproducibility of experiments by relying on the Python typing system, minimal configuration files and command line interfaces. Architecture The three pillars of this configuration system are the catalogue registry, the Pydantic validation system and the typer CLI library. Registry The catalogue registry records the various objects (classes or functions) that can be composed together to run your program. Once registered, with the registry.factory.register decorator, these objects are accessible as [entry points] and can be used in the configuration system. To start, you can create a simple registry \"factory\" as follows: from confit import Registry , RegistryCollection class registry ( RegistryCollection ): factory = Registry (( \"my_library\" , \"factory\" ), entry_points = True ) What is this useful for? With this registry, you can register a function or a class: @registry . factory . register ( \"my-function\" ) def my_function ( value = 10 ): print ( f \"The value is { value } !\" ) Now you can dynamically retrieve the function from anywhere: func = registry . factory . get ( \"my-function\" ) func () # Out: \"The value is 10!\" func ( value = 42 ) # Out: \"The value is 42!\" Typing system The Pydantic validate_arguments decorator enhances a function to automatically parse and validate its arguments every time it is called, using the Pydantic typing-based validation system. For instance, strings can be automatically cast as Path objects, or datetime or numbers depending on the type annotation of the argument. Combined with our configuration system, dictionaries passed as arguments to a decorated function can be \"cast\" as instantiated classes if these classes were them-selves decorated. CLI TBD The Config object The configuration object consists of a supercharged dict, the Config class, that can be used to read and write to cfg files, interpolate variables and instantiate components through the registry with some special @factory keys. A cfg file can be used directly as an input to a CLI-decorated function. We will show partial examples with increasing complexity below. See here for an end-to-end example. Instantiating an object script.py @registry . factory . register ( \"my-class\" ) class MyClass : def __init__ ( self , value1 : int , value2 : float ): self . value1 = value1 self . value2 = value2 config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = 2.5 Here, Confit will: Parse the configuration Get the target class from the registry Validate parameters if needed (in this case, value1 is typed as an int, thus it will be casted as an int by setting value1=1 ) Instantiate the class using the validated parameters Interpolating values When multiple sections of the configuration need to access the same value, you can provide it using the ${<section.value>} syntax: config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Here, value2 will be set to 10. Advanced interpolation You can even pass instantiated objects! Suppose we have a registered myOtherClass class expecting an instance of MyClass as input. You could use the following configuration: config.cfg [func] @factory = \"my-other-class\" obj = ${myclass} [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Finally, you may want to access some attributes of Python classes that are available after instantiation, but not present in the configuration file. For instance, let's modify our MyClass class: script.py @registry.factory.register(\"my-class\") class MyClass: def __init__(self, value1: int, value2: float): self.value1 = value1 self.value2 = value2 + self.hidden_value = 99 To access those values directly in the configuration file, use the ${<obj:attribute>} syntax (notice the colon instead of the point ) config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = 2.5 [other_values] value3 = ${myclass:hidden_value}","title":"Confit"},{"location":"#confit","text":"Confit is a complete and easy-to-use configuration framework aimed at improving the reproducibility of experiments by relying on the Python typing system, minimal configuration files and command line interfaces.","title":"Confit"},{"location":"#architecture","text":"The three pillars of this configuration system are the catalogue registry, the Pydantic validation system and the typer CLI library.","title":"Architecture"},{"location":"#registry","text":"The catalogue registry records the various objects (classes or functions) that can be composed together to run your program. Once registered, with the registry.factory.register decorator, these objects are accessible as [entry points] and can be used in the configuration system. To start, you can create a simple registry \"factory\" as follows: from confit import Registry , RegistryCollection class registry ( RegistryCollection ): factory = Registry (( \"my_library\" , \"factory\" ), entry_points = True ) What is this useful for? With this registry, you can register a function or a class: @registry . factory . register ( \"my-function\" ) def my_function ( value = 10 ): print ( f \"The value is { value } !\" ) Now you can dynamically retrieve the function from anywhere: func = registry . factory . get ( \"my-function\" ) func () # Out: \"The value is 10!\" func ( value = 42 ) # Out: \"The value is 42!\"","title":"Registry"},{"location":"#typing-system","text":"The Pydantic validate_arguments decorator enhances a function to automatically parse and validate its arguments every time it is called, using the Pydantic typing-based validation system. For instance, strings can be automatically cast as Path objects, or datetime or numbers depending on the type annotation of the argument. Combined with our configuration system, dictionaries passed as arguments to a decorated function can be \"cast\" as instantiated classes if these classes were them-selves decorated.","title":"Typing system"},{"location":"#cli","text":"TBD","title":"CLI"},{"location":"#the-config-object","text":"The configuration object consists of a supercharged dict, the Config class, that can be used to read and write to cfg files, interpolate variables and instantiate components through the registry with some special @factory keys. A cfg file can be used directly as an input to a CLI-decorated function. We will show partial examples with increasing complexity below. See here for an end-to-end example.","title":"The Config object"},{"location":"#instantiating-an-object","text":"script.py @registry . factory . register ( \"my-class\" ) class MyClass : def __init__ ( self , value1 : int , value2 : float ): self . value1 = value1 self . value2 = value2 config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = 2.5 Here, Confit will: Parse the configuration Get the target class from the registry Validate parameters if needed (in this case, value1 is typed as an int, thus it will be casted as an int by setting value1=1 ) Instantiate the class using the validated parameters","title":"Instantiating an object"},{"location":"#interpolating-values","text":"When multiple sections of the configuration need to access the same value, you can provide it using the ${<section.value>} syntax: config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Here, value2 will be set to 10.","title":"Interpolating values"},{"location":"#advanced-interpolation","text":"You can even pass instantiated objects! Suppose we have a registered myOtherClass class expecting an instance of MyClass as input. You could use the following configuration: config.cfg [func] @factory = \"my-other-class\" obj = ${myclass} [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Finally, you may want to access some attributes of Python classes that are available after instantiation, but not present in the configuration file. For instance, let's modify our MyClass class: script.py @registry.factory.register(\"my-class\") class MyClass: def __init__(self, value1: int, value2: float): self.value1 = value1 self.value2 = value2 + self.hidden_value = 99 To access those values directly in the configuration file, use the ${<obj:attribute>} syntax (notice the colon instead of the point ) config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = 2.5 [other_values] value3 = ${myclass:hidden_value}","title":"Advanced interpolation"},{"location":"roadmap/","text":"Roadmap better pydantic <-> typer errors tutorials find edge cases ...","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"better pydantic <-> typer errors tutorials find edge cases ...","title":"Roadmap"},{"location":"reference/","text":"confit","title":"index"},{"location":"reference/#confit","text":"","title":"confit"},{"location":"reference/autoreload/","text":"confit.autoreload Plugin to help IPython's autoreload magic reload functions wrapped with confit.","title":"autoreload"},{"location":"reference/autoreload/#confitautoreload","text":"Plugin to help IPython's autoreload magic reload functions wrapped with confit.","title":"confit.autoreload"},{"location":"reference/cli/","text":"confit.cli Cli Bases: Typer Custom Typer object that: validates a command parameters before executing it accepts a configuration file describing the parameters automatically instantiates parameters given a dictionary when type hinted Source code in confit/cli.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class Cli ( Typer ): \"\"\" Custom Typer object that: - validates a command parameters before executing it - accepts a configuration file describing the parameters - automatically instantiates parameters given a dictionary when type hinted \"\"\" def command ( # noqa self , name , * , cls : Optional [ Type [ TyperCommand ]] = None , context_settings : Optional [ Dict [ Any , Any ]] = None , help : Optional [ str ] = None , epilog : Optional [ str ] = None , short_help : Optional [ str ] = None , options_metavar : str = \"[OPTIONS]\" , add_help_option : bool = True , no_args_is_help : bool = False , hidden : bool = False , deprecated : bool = False , # Rich settings rich_help_panel : Union [ str , None ] = Default ( None ), registry : Any = None , ) -> Callable [[ CommandFunctionType ], CommandFunctionType ]: typer_command = super () . command ( name = name , cls = cls , help = help , epilog = epilog , short_help = short_help , options_metavar = options_metavar , add_help_option = add_help_option , no_args_is_help = no_args_is_help , hidden = hidden , deprecated = deprecated , rich_help_panel = rich_help_panel , context_settings = { ** ( context_settings or {}), \"ignore_unknown_options\" : True , \"allow_extra_args\" : True , }, ) def wrapper ( fn ): validated = validate_arguments ( fn ) @typer_command def command ( ctx : Context , config : Optional [ List [ Path ]] = None ): config_path = config has_meta = _fn_has_meta ( fn ) if config_path : config , name_from_file = merge_from_disk ( config_path ) else : config = Config ({ name : {}}) model_fields = ( validated . model . model_fields if hasattr ( validated . model , \"model_fields\" ) else validated . model . __fields__ ) for k , v in parse_overrides ( ctx . args ) . items (): if \".\" not in k : parts = ( name , k ) else : parts = k . split ( \".\" ) if parts [ 0 ] in model_fields and parts [ 0 ] not in config : parts = ( name , * parts ) current = config if parts [ 0 ] not in current : raise Exception ( f \" { k } does not match any existing section in config\" ) for part in parts [: - 1 ]: current = current . setdefault ( part , Config ()) current [ parts [ - 1 ]] = v try : resolved_config = config . resolve ( registry = registry ) default_seed = model_fields . get ( \"seed\" ) if default_seed is not None : default_seed = default_seed . get_default () seed = config . get ( name , {}) . get ( \"seed\" , default_seed ) if seed is not None : set_seed ( seed ) if has_meta : config_meta = dict ( config_path = config_path , resolved_config = resolved_config , unresolved_config = config , ) return validated ( ** resolved_config . get ( name , {}), config_meta = config_meta , ) else : return validated ( ** resolved_config . get ( name , {})) except ( LegacyValidationError , ConfitValidationError ) as e : e . raw_errors = patch_errors ( e . raw_errors , ( name ,), ) if is_debug () or e . __cause__ is not None : raise e try : import rich console = rich . console . Console ( stderr = True ) console . print ( \"Validation error:\" , style = \"red\" , end = \" \" ) console . print ( str ( e )) except ImportError : # pragma: no cover print ( \"Validation error:\" , file = sys . stderr , end = \" \" ) print ( str ( e ), file = sys . stderr ) sys . exit ( 1 ) return validated return wrapper parse_overrides ( args ) Parse the overrides from the command line into a dictionary of key-value pairs. PARAMETER DESCRIPTION args The arguments to parse TYPE: List [ str ] RETURNS DESCRIPTION Dict [ str , Any ] The parsed overrides as a dictionary Source code in confit/cli.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def parse_overrides ( args : List [ str ]) -> Dict [ str , Any ]: \"\"\" Parse the overrides from the command line into a dictionary of key-value pairs. Parameters ---------- args: List[str] The arguments to parse Returns ------- Dict[str, Any] The parsed overrides as a dictionary \"\"\" result = {} while args : opt = args . pop ( 0 ) err = f \"Invalid config override ' { opt } '\" if opt . startswith ( \"--\" ): # new argument opt = opt . replace ( \"--\" , \"\" ) if \"=\" in opt : # we have --opt=value opt , value = opt . split ( \"=\" , 1 ) else : if not args or args [ 0 ] . startswith ( \"--\" ): # flag with no value value = \"true\" else : value = args . pop ( 0 ) opt = opt . replace ( \"-\" , \"_\" ) result [ opt ] = loads ( value ) else : secho ( f \" { err } : doesn't support shorthands\" , fg = colors . RED ) exit ( 1 ) return result","title":"cli"},{"location":"reference/cli/#confitcli","text":"","title":"confit.cli"},{"location":"reference/cli/#confit.cli.Cli","text":"Bases: Typer Custom Typer object that: validates a command parameters before executing it accepts a configuration file describing the parameters automatically instantiates parameters given a dictionary when type hinted Source code in confit/cli.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class Cli ( Typer ): \"\"\" Custom Typer object that: - validates a command parameters before executing it - accepts a configuration file describing the parameters - automatically instantiates parameters given a dictionary when type hinted \"\"\" def command ( # noqa self , name , * , cls : Optional [ Type [ TyperCommand ]] = None , context_settings : Optional [ Dict [ Any , Any ]] = None , help : Optional [ str ] = None , epilog : Optional [ str ] = None , short_help : Optional [ str ] = None , options_metavar : str = \"[OPTIONS]\" , add_help_option : bool = True , no_args_is_help : bool = False , hidden : bool = False , deprecated : bool = False , # Rich settings rich_help_panel : Union [ str , None ] = Default ( None ), registry : Any = None , ) -> Callable [[ CommandFunctionType ], CommandFunctionType ]: typer_command = super () . command ( name = name , cls = cls , help = help , epilog = epilog , short_help = short_help , options_metavar = options_metavar , add_help_option = add_help_option , no_args_is_help = no_args_is_help , hidden = hidden , deprecated = deprecated , rich_help_panel = rich_help_panel , context_settings = { ** ( context_settings or {}), \"ignore_unknown_options\" : True , \"allow_extra_args\" : True , }, ) def wrapper ( fn ): validated = validate_arguments ( fn ) @typer_command def command ( ctx : Context , config : Optional [ List [ Path ]] = None ): config_path = config has_meta = _fn_has_meta ( fn ) if config_path : config , name_from_file = merge_from_disk ( config_path ) else : config = Config ({ name : {}}) model_fields = ( validated . model . model_fields if hasattr ( validated . model , \"model_fields\" ) else validated . model . __fields__ ) for k , v in parse_overrides ( ctx . args ) . items (): if \".\" not in k : parts = ( name , k ) else : parts = k . split ( \".\" ) if parts [ 0 ] in model_fields and parts [ 0 ] not in config : parts = ( name , * parts ) current = config if parts [ 0 ] not in current : raise Exception ( f \" { k } does not match any existing section in config\" ) for part in parts [: - 1 ]: current = current . setdefault ( part , Config ()) current [ parts [ - 1 ]] = v try : resolved_config = config . resolve ( registry = registry ) default_seed = model_fields . get ( \"seed\" ) if default_seed is not None : default_seed = default_seed . get_default () seed = config . get ( name , {}) . get ( \"seed\" , default_seed ) if seed is not None : set_seed ( seed ) if has_meta : config_meta = dict ( config_path = config_path , resolved_config = resolved_config , unresolved_config = config , ) return validated ( ** resolved_config . get ( name , {}), config_meta = config_meta , ) else : return validated ( ** resolved_config . get ( name , {})) except ( LegacyValidationError , ConfitValidationError ) as e : e . raw_errors = patch_errors ( e . raw_errors , ( name ,), ) if is_debug () or e . __cause__ is not None : raise e try : import rich console = rich . console . Console ( stderr = True ) console . print ( \"Validation error:\" , style = \"red\" , end = \" \" ) console . print ( str ( e )) except ImportError : # pragma: no cover print ( \"Validation error:\" , file = sys . stderr , end = \" \" ) print ( str ( e ), file = sys . stderr ) sys . exit ( 1 ) return validated return wrapper","title":"Cli"},{"location":"reference/cli/#confit.cli.parse_overrides","text":"Parse the overrides from the command line into a dictionary of key-value pairs. PARAMETER DESCRIPTION args The arguments to parse TYPE: List [ str ] RETURNS DESCRIPTION Dict [ str , Any ] The parsed overrides as a dictionary Source code in confit/cli.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def parse_overrides ( args : List [ str ]) -> Dict [ str , Any ]: \"\"\" Parse the overrides from the command line into a dictionary of key-value pairs. Parameters ---------- args: List[str] The arguments to parse Returns ------- Dict[str, Any] The parsed overrides as a dictionary \"\"\" result = {} while args : opt = args . pop ( 0 ) err = f \"Invalid config override ' { opt } '\" if opt . startswith ( \"--\" ): # new argument opt = opt . replace ( \"--\" , \"\" ) if \"=\" in opt : # we have --opt=value opt , value = opt . split ( \"=\" , 1 ) else : if not args or args [ 0 ] . startswith ( \"--\" ): # flag with no value value = \"true\" else : value = args . pop ( 0 ) opt = opt . replace ( \"-\" , \"_\" ) result [ opt ] = loads ( value ) else : secho ( f \" { err } : doesn't support shorthands\" , fg = colors . RED ) exit ( 1 ) return result","title":"parse_overrides()"},{"location":"reference/config/","text":"confit.config Config Bases: dict The configuration system consists of a supercharged dict, the Config class, that can be used to read and write to cfg files, interpolate variables and instantiate components through the registry with some special @factory keys. A cfg file can be used directly as an input to a CLI-decorated function. Source code in confit/config.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Config ( dict ): \"\"\" The configuration system consists of a supercharged dict, the `Config` class, that can be used to read and write to `cfg` files, interpolate variables and instantiate components through the registry with some special `@factory` keys. A cfg file can be used directly as an input to a CLI-decorated function. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs ) @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry ) def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s ) def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self ) def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue () def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ()) def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy @classmethod def _store_resolved ( cls , resolved : Any , config : Dict [ str , Any ]): \"\"\" Adds a resolved object to the RESOLVED_TO_CONFIG dict for later retrieval during serialization ([`.serialize`][confit.config.Config.serialize]) Parameters ---------- resolved: Any config: Config \"\"\" try : RESOLVED_TO_CONFIG [ resolved ] = config except TypeError : pass __init__ ( * args , ** kwargs ) A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. PARAMETER DESCRIPTION args TYPE: Any DEFAULT: () kwargs TYPE: Any DEFAULT: {} Source code in confit/config.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs ) from_str ( s , resolve = False , registry = None ) classmethod Load a config object from a config string PARAMETER DESCRIPTION s The cfg config string TYPE: str resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config from_disk ( path , resolve = False , registry = None ) classmethod Load a config object from a '.cfg' file PARAMETER DESCRIPTION path The path to the config object TYPE: Union [ str , Path ] resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry ) to_disk ( path ) Export a config to the disk (usually to a .cfg file) PARAMETER DESCRIPTION path TYPE: Union [ str , Path ] Source code in confit/config.py 139 140 141 142 143 144 145 146 147 148 def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s ) serialize () Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. a = A () # serializable object cfg = { \"a\" : a , \"b\" : a } print ( Config . serialize ( cfg )) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} RETURNS DESCRIPTION Config Source code in confit/config.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self ) to_str () Export a config to a string in the cfg format by serializing it first RETURNS DESCRIPTION str Source code in confit/config.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue () resolve ( deep = True , registry = None , root = None ) Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. PARAMETER DESCRIPTION deep Should we resolve deeply DEFAULT: True registry Registry to use when resolving TYPE: Any DEFAULT: None root The root of the config tree. Used for resolving references. TYPE: Mapping DEFAULT: None RETURNS DESCRIPTION Union [ Config , Any ] Source code in confit/config.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ()) merge ( * updates , remove_extra = False ) Deep merge two configs. Heavily inspired from thinc 's config merge function. PARAMETER DESCRIPTION updates Configs to update the original config TYPE: Union [ Dict [ str , Any ], Config ] DEFAULT: () remove_extra If true, restricts update to keys that existed in the original config TYPE: bool DEFAULT: False RETURNS DESCRIPTION The new config Source code in confit/config.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config copy () Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] RETURNS DESCRIPTION Any Source code in confit/config.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy merge_from_disk ( config_paths , returned_name = 'first' ) Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config PARAMETER DESCRIPTION config_paths Paths to the config files TYPE: Union [ Path , List [ Path ]] returned_name If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign TYPE: str DEFAULT: 'first' Source code in confit/config.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 def merge_from_disk ( config_paths : Union [ Path , List [ Path ]], returned_name : str = \"first\" , ): \"\"\" Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config Parameters ---------- config_paths: Union[Path, List[Path]] Paths to the config files returned_name: str If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign Returns ------- \"\"\" assert returned_name in { \"first\" , \"concat\" } if isinstance ( config_paths , Path ): config_paths = [ config_paths ] configs = [ Config . from_disk ( p , resolve = False ) for p in config_paths ] config_names = [ p . stem for p in config_paths ] name = config_names [ 0 ] if returned_name == \"first\" else \"+\" . join ( config_names ) config = configs . pop ( 0 ) return config . merge ( * configs ), name","title":"config"},{"location":"reference/config/#confitconfig","text":"","title":"confit.config"},{"location":"reference/config/#confit.config.Config","text":"Bases: dict The configuration system consists of a supercharged dict, the Config class, that can be used to read and write to cfg files, interpolate variables and instantiate components through the registry with some special @factory keys. A cfg file can be used directly as an input to a CLI-decorated function. Source code in confit/config.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Config ( dict ): \"\"\" The configuration system consists of a supercharged dict, the `Config` class, that can be used to read and write to `cfg` files, interpolate variables and instantiate components through the registry with some special `@factory` keys. A cfg file can be used directly as an input to a CLI-decorated function. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs ) @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry ) def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s ) def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self ) def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue () def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ()) def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy @classmethod def _store_resolved ( cls , resolved : Any , config : Dict [ str , Any ]): \"\"\" Adds a resolved object to the RESOLVED_TO_CONFIG dict for later retrieval during serialization ([`.serialize`][confit.config.Config.serialize]) Parameters ---------- resolved: Any config: Config \"\"\" try : RESOLVED_TO_CONFIG [ resolved ] = config except TypeError : pass","title":"Config"},{"location":"reference/config/#confit.config.Config.__init__","text":"A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. PARAMETER DESCRIPTION args TYPE: Any DEFAULT: () kwargs TYPE: Any DEFAULT: {} Source code in confit/config.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs )","title":"__init__()"},{"location":"reference/config/#confit.config.Config.from_str","text":"Load a config object from a config string PARAMETER DESCRIPTION s The cfg config string TYPE: str resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config","title":"from_str()"},{"location":"reference/config/#confit.config.Config.from_disk","text":"Load a config object from a '.cfg' file PARAMETER DESCRIPTION path The path to the config object TYPE: Union [ str , Path ] resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry )","title":"from_disk()"},{"location":"reference/config/#confit.config.Config.to_disk","text":"Export a config to the disk (usually to a .cfg file) PARAMETER DESCRIPTION path TYPE: Union [ str , Path ] Source code in confit/config.py 139 140 141 142 143 144 145 146 147 148 def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s )","title":"to_disk()"},{"location":"reference/config/#confit.config.Config.serialize","text":"Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. a = A () # serializable object cfg = { \"a\" : a , \"b\" : a } print ( Config . serialize ( cfg )) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} RETURNS DESCRIPTION Config Source code in confit/config.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self )","title":"serialize()"},{"location":"reference/config/#confit.config.Config.to_str","text":"Export a config to a string in the cfg format by serializing it first RETURNS DESCRIPTION str Source code in confit/config.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue ()","title":"to_str()"},{"location":"reference/config/#confit.config.Config.resolve","text":"Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. PARAMETER DESCRIPTION deep Should we resolve deeply DEFAULT: True registry Registry to use when resolving TYPE: Any DEFAULT: None root The root of the config tree. Used for resolving references. TYPE: Mapping DEFAULT: None RETURNS DESCRIPTION Union [ Config , Any ] Source code in confit/config.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ())","title":"resolve()"},{"location":"reference/config/#confit.config.Config.merge","text":"Deep merge two configs. Heavily inspired from thinc 's config merge function. PARAMETER DESCRIPTION updates Configs to update the original config TYPE: Union [ Dict [ str , Any ], Config ] DEFAULT: () remove_extra If true, restricts update to keys that existed in the original config TYPE: bool DEFAULT: False RETURNS DESCRIPTION The new config Source code in confit/config.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config","title":"merge()"},{"location":"reference/config/#confit.config.Config.copy","text":"Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] RETURNS DESCRIPTION Any Source code in confit/config.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy","title":"copy()"},{"location":"reference/config/#confit.config.merge_from_disk","text":"Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config PARAMETER DESCRIPTION config_paths Paths to the config files TYPE: Union [ Path , List [ Path ]] returned_name If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign TYPE: str DEFAULT: 'first' Source code in confit/config.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 def merge_from_disk ( config_paths : Union [ Path , List [ Path ]], returned_name : str = \"first\" , ): \"\"\" Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config Parameters ---------- config_paths: Union[Path, List[Path]] Paths to the config files returned_name: str If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign Returns ------- \"\"\" assert returned_name in { \"first\" , \"concat\" } if isinstance ( config_paths , Path ): config_paths = [ config_paths ] configs = [ Config . from_disk ( p , resolve = False ) for p in config_paths ] config_names = [ p . stem for p in config_paths ] name = config_names [ 0 ] if returned_name == \"first\" else \"+\" . join ( config_names ) config = configs . pop ( 0 ) return config . merge ( * configs ), name","title":"merge_from_disk()"},{"location":"reference/errors/","text":"confit.errors MissingReference Bases: Exception Raised when one or multiple references cannot be resolved. Source code in confit/errors.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class MissingReference ( Exception ): \"\"\" Raised when one or multiple references cannot be resolved. \"\"\" def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref ) __init__ ( ref ) PARAMETER DESCRIPTION ref The reference that could not be resolved. TYPE: Reference Source code in confit/errors.py 38 39 40 41 42 43 44 45 46 def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ () __str__ () String representation of the exception Source code in confit/errors.py 48 49 50 51 52 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref ) CyclicReferenceError Bases: Exception Raised when a cyclic reference is detected. Source code in confit/errors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class CyclicReferenceError ( Exception ): \"\"\" Raised when a cyclic reference is detected. \"\"\" def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path )) __init__ ( path ) PARAMETER DESCRIPTION path The path of the cyclic reference TYPE: Loc Source code in confit/errors.py 60 61 62 63 64 65 66 67 68 def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ () __str__ () String representation of the exception Source code in confit/errors.py 70 71 72 73 74 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path )) remove_lib_from_traceback ( tb ) Remove the lib folder from the traceback Source code in confit/errors.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def remove_lib_from_traceback ( tb ): \"\"\" Remove the lib folder from the traceback \"\"\" # compare package to module in f_globals if is_debug (): return tb if tb is not None and tb . tb_frame . f_globals . get ( \"__package__\" ) == __package__ : return remove_lib_from_traceback ( tb . tb_next ) if tb is None or tb . tb_next is None : return tb tb . tb_next = remove_lib_from_traceback ( tb . tb_next ) return tb to_legacy_error ( err , model ) Decorator to convert a Pydantic ValidationError into a ConfitValidationError Source code in confit/errors.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def to_legacy_error ( err : pydantic . ValidationError , model : Any ) -> LegacyValidationError : \"\"\" Decorator to convert a Pydantic ValidationError into a ConfitValidationError \"\"\" if isinstance ( err , LegacyValidationError ): return err errors = err . errors ( include_url = False ) raw_errors = [] for err in errors : vrepr = repr ( err [ \"input\" ]) vrepr = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr err = dict ( err ) msg = err . pop ( \"msg\" , \"\" ) msg = ( msg [ 0 ] . lower () + msg [ 1 :]) if msg else msg raw_errors . append ( ErrorWrapper ( exc = err [ \"ctx\" ][ \"error\" ] if \"ctx\" in err and \"error\" in err [ \"ctx\" ] and isinstance ( err [ \"ctx\" ][ \"error\" ], BaseException ) else PydanticNewStyleError ( ** err , msg = msg , actual_value = vrepr , actual_type = type ( err [ \"input\" ]) . __name__ , ), loc = err [ \"loc\" ], ) ) return ConfitValidationError ( raw_errors , model = model ) patch_errors ( errors , path , values = None , model = None , special_names = ()) Patch the location of the errors to add the path prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. PARAMETER DESCRIPTION errors The pydantic errors to patch TYPE: Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] path The path to add to the errors TYPE: Loc values The values of the config TYPE: Dict DEFAULT: None special_names The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] The patched errors Source code in confit/errors.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def patch_errors ( errors : Union [ Sequence [ ErrorWrapper ], ErrorWrapper ], path : Loc , values : Dict = None , model : Optional [ pydantic . BaseModel ] = None , special_names : Sequence [ str ] = (), ): \"\"\" Patch the location of the errors to add the `path` prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. Parameters ---------- errors: Union[Sequence[ErrorWrapper], ErrorWrapper] The pydantic errors to patch path: Loc The path to add to the errors values: Dict The values of the config special_names: Sequence[str] The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path Returns ------- Union[Sequence[ErrorWrapper], ErrorWrapper] The patched errors \"\"\" if isinstance ( errors , list ): res = [] for error in errors : res . extend ( patch_errors ( error , path , values , model , special_names )) return res if isinstance ( errors , ErrorWrapper ) and isinstance ( errors . exc , LegacyValidationError ): try : field_model = model for part in errors . loc_tuple (): # if not issubclass(field_model, pydantic.BaseModel) and issubclass( # field_model.vd.model, pydantic.BaseModel # ): # field_model = field_model.vd.model if hasattr ( field_model , \"model_fields\" ): field_model = field_model . model_fields [ part ] else : field_model = field_model . __fields__ [ part ] if hasattr ( field_model , \"type_\" ): field_model = field_model . type_ else : field_model = field_model . annotation if ( field_model is errors . exc . model or field_model . vd . model is errors . exc . model ): return patch_errors ( errors . exc . raw_errors , ( * path , * errors . loc_tuple ()), values , model , special_names , ) except ( KeyError , AttributeError ): # pragma: no cover print ( \"Could not find model for\" , errors . loc_tuple ()) if ( isinstance ( errors . exc , PydanticErrorMixin ) and values is not None and errors . loc_tuple () and errors . loc_tuple ()[ 0 ] in values ): if \"actual_value\" not in errors . exc . __dict__ : actual_value = values for key in errors . loc_tuple (): actual_value = actual_value [ key ] vrepr = repr ( actual_value ) errors . exc . actual_value = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr errors . exc . actual_type = type ( actual_value ) . __name__ cls = errors . exc . __class__ if cls not in PATCHED_ERRORS_CLS : def error_str ( self ): s = cls . __str__ ( self ) s = ( s + f \", got { self . actual_value } ( { self . actual_type } )\" if hasattr ( self , \"actual_value\" ) else s ) return s new_cls = type ( cls . __name__ , ( cls ,), { \"msg_template\" : cls . msg_template + \", got {actual_value} ( {actual_type} )\" } if hasattr ( cls , \"msg_template\" ) else { \"__str__\" : error_str , }, ) PATCHED_ERRORS_CLS [ cls ] = new_cls PATCHED_ERRORS_CLS [ new_cls ] = new_cls errors . exc . __class__ = PATCHED_ERRORS_CLS [ cls ] if ( isinstance ( errors . exc , TypeError ) and str ( errors . exc ) . startswith ( \"unexpected keyword argument\" ) and \":\" in errors . exc . args [ 0 ] ): extra_keys = errors . exc . args [ 0 ] . split ( \": \" )[ 1 ] . split ( \", \" ) return [ ErrorWrapper ( TypeError ( \"unexpected keyword argument\" ), ( * path , * errors . loc_tuple ()[: - 1 ], key . strip ( \"'\" )), ) for key in extra_keys ] loc_tuple = errors . loc_tuple () if loc_tuple and loc_tuple [ - 1 ] in special_names : loc_tuple = ( * loc_tuple [: - 1 ], \"[signature]\" ) return [ ErrorWrapper ( errors . exc , ( * path , * loc_tuple ), ) ]","title":"errors"},{"location":"reference/errors/#confiterrors","text":"","title":"confit.errors"},{"location":"reference/errors/#confit.errors.MissingReference","text":"Bases: Exception Raised when one or multiple references cannot be resolved. Source code in confit/errors.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class MissingReference ( Exception ): \"\"\" Raised when one or multiple references cannot be resolved. \"\"\" def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref )","title":"MissingReference"},{"location":"reference/errors/#confit.errors.MissingReference.__init__","text":"PARAMETER DESCRIPTION ref The reference that could not be resolved. TYPE: Reference Source code in confit/errors.py 38 39 40 41 42 43 44 45 46 def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ ()","title":"__init__()"},{"location":"reference/errors/#confit.errors.MissingReference.__str__","text":"String representation of the exception Source code in confit/errors.py 48 49 50 51 52 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref )","title":"__str__()"},{"location":"reference/errors/#confit.errors.CyclicReferenceError","text":"Bases: Exception Raised when a cyclic reference is detected. Source code in confit/errors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class CyclicReferenceError ( Exception ): \"\"\" Raised when a cyclic reference is detected. \"\"\" def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path ))","title":"CyclicReferenceError"},{"location":"reference/errors/#confit.errors.CyclicReferenceError.__init__","text":"PARAMETER DESCRIPTION path The path of the cyclic reference TYPE: Loc Source code in confit/errors.py 60 61 62 63 64 65 66 67 68 def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ ()","title":"__init__()"},{"location":"reference/errors/#confit.errors.CyclicReferenceError.__str__","text":"String representation of the exception Source code in confit/errors.py 70 71 72 73 74 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path ))","title":"__str__()"},{"location":"reference/errors/#confit.errors.remove_lib_from_traceback","text":"Remove the lib folder from the traceback Source code in confit/errors.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def remove_lib_from_traceback ( tb ): \"\"\" Remove the lib folder from the traceback \"\"\" # compare package to module in f_globals if is_debug (): return tb if tb is not None and tb . tb_frame . f_globals . get ( \"__package__\" ) == __package__ : return remove_lib_from_traceback ( tb . tb_next ) if tb is None or tb . tb_next is None : return tb tb . tb_next = remove_lib_from_traceback ( tb . tb_next ) return tb","title":"remove_lib_from_traceback()"},{"location":"reference/errors/#confit.errors.to_legacy_error","text":"Decorator to convert a Pydantic ValidationError into a ConfitValidationError Source code in confit/errors.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def to_legacy_error ( err : pydantic . ValidationError , model : Any ) -> LegacyValidationError : \"\"\" Decorator to convert a Pydantic ValidationError into a ConfitValidationError \"\"\" if isinstance ( err , LegacyValidationError ): return err errors = err . errors ( include_url = False ) raw_errors = [] for err in errors : vrepr = repr ( err [ \"input\" ]) vrepr = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr err = dict ( err ) msg = err . pop ( \"msg\" , \"\" ) msg = ( msg [ 0 ] . lower () + msg [ 1 :]) if msg else msg raw_errors . append ( ErrorWrapper ( exc = err [ \"ctx\" ][ \"error\" ] if \"ctx\" in err and \"error\" in err [ \"ctx\" ] and isinstance ( err [ \"ctx\" ][ \"error\" ], BaseException ) else PydanticNewStyleError ( ** err , msg = msg , actual_value = vrepr , actual_type = type ( err [ \"input\" ]) . __name__ , ), loc = err [ \"loc\" ], ) ) return ConfitValidationError ( raw_errors , model = model )","title":"to_legacy_error()"},{"location":"reference/errors/#confit.errors.patch_errors","text":"Patch the location of the errors to add the path prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. PARAMETER DESCRIPTION errors The pydantic errors to patch TYPE: Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] path The path to add to the errors TYPE: Loc values The values of the config TYPE: Dict DEFAULT: None special_names The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] The patched errors Source code in confit/errors.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def patch_errors ( errors : Union [ Sequence [ ErrorWrapper ], ErrorWrapper ], path : Loc , values : Dict = None , model : Optional [ pydantic . BaseModel ] = None , special_names : Sequence [ str ] = (), ): \"\"\" Patch the location of the errors to add the `path` prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. Parameters ---------- errors: Union[Sequence[ErrorWrapper], ErrorWrapper] The pydantic errors to patch path: Loc The path to add to the errors values: Dict The values of the config special_names: Sequence[str] The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path Returns ------- Union[Sequence[ErrorWrapper], ErrorWrapper] The patched errors \"\"\" if isinstance ( errors , list ): res = [] for error in errors : res . extend ( patch_errors ( error , path , values , model , special_names )) return res if isinstance ( errors , ErrorWrapper ) and isinstance ( errors . exc , LegacyValidationError ): try : field_model = model for part in errors . loc_tuple (): # if not issubclass(field_model, pydantic.BaseModel) and issubclass( # field_model.vd.model, pydantic.BaseModel # ): # field_model = field_model.vd.model if hasattr ( field_model , \"model_fields\" ): field_model = field_model . model_fields [ part ] else : field_model = field_model . __fields__ [ part ] if hasattr ( field_model , \"type_\" ): field_model = field_model . type_ else : field_model = field_model . annotation if ( field_model is errors . exc . model or field_model . vd . model is errors . exc . model ): return patch_errors ( errors . exc . raw_errors , ( * path , * errors . loc_tuple ()), values , model , special_names , ) except ( KeyError , AttributeError ): # pragma: no cover print ( \"Could not find model for\" , errors . loc_tuple ()) if ( isinstance ( errors . exc , PydanticErrorMixin ) and values is not None and errors . loc_tuple () and errors . loc_tuple ()[ 0 ] in values ): if \"actual_value\" not in errors . exc . __dict__ : actual_value = values for key in errors . loc_tuple (): actual_value = actual_value [ key ] vrepr = repr ( actual_value ) errors . exc . actual_value = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr errors . exc . actual_type = type ( actual_value ) . __name__ cls = errors . exc . __class__ if cls not in PATCHED_ERRORS_CLS : def error_str ( self ): s = cls . __str__ ( self ) s = ( s + f \", got { self . actual_value } ( { self . actual_type } )\" if hasattr ( self , \"actual_value\" ) else s ) return s new_cls = type ( cls . __name__ , ( cls ,), { \"msg_template\" : cls . msg_template + \", got {actual_value} ( {actual_type} )\" } if hasattr ( cls , \"msg_template\" ) else { \"__str__\" : error_str , }, ) PATCHED_ERRORS_CLS [ cls ] = new_cls PATCHED_ERRORS_CLS [ new_cls ] = new_cls errors . exc . __class__ = PATCHED_ERRORS_CLS [ cls ] if ( isinstance ( errors . exc , TypeError ) and str ( errors . exc ) . startswith ( \"unexpected keyword argument\" ) and \":\" in errors . exc . args [ 0 ] ): extra_keys = errors . exc . args [ 0 ] . split ( \": \" )[ 1 ] . split ( \", \" ) return [ ErrorWrapper ( TypeError ( \"unexpected keyword argument\" ), ( * path , * errors . loc_tuple ()[: - 1 ], key . strip ( \"'\" )), ) for key in extra_keys ] loc_tuple = errors . loc_tuple () if loc_tuple and loc_tuple [ - 1 ] in special_names : loc_tuple = ( * loc_tuple [: - 1 ], \"[signature]\" ) return [ ErrorWrapper ( errors . exc , ( * path , * loc_tuple ), ) ]","title":"patch_errors()"},{"location":"reference/registry/","text":"confit.registry VisibleDeprecationWarning Bases: UserWarning Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 Source code in confit/registry.py 346 347 348 349 350 351 352 353 354 355 class VisibleDeprecationWarning ( UserWarning ): \"\"\" Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 \"\"\" # noqa: E501 Registry Bases: Registry A registry that validates the input arguments of the registered functions. Source code in confit/registry.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 class Registry ( catalogue . Registry ): \"\"\" A registry that validates the input arguments of the registered functions. \"\"\" def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace ) def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result ) __init__ ( namespace , entry_points = False ) Initialize the registry. PARAMETER DESCRIPTION namespace The namespace of the registry TYPE: Sequence [ str ] entry_points Should we use entry points to load the registered functions TYPE: bool DEFAULT: False Source code in confit/registry.py 366 367 368 369 370 371 372 373 374 375 376 377 378 def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None register ( name , * , func = None , save_params = None , skip_save_params = (), invoker = None , deprecated = ()) This is a convenience wrapper around catalogue.Registry.register , that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. PARAMETER DESCRIPTION name The name of the function TYPE: str func The function to register TYPE: Optional [ InFunc ] DEFAULT: None save_params Additional parameters to save when the function is called. If falsy, the function parameters are not saved TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None skip_save_params List of parameters to skip when saving the function parameters TYPE: Sequence [ str ] DEFAULT: () invoker An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. TYPE: Optional [ Callable ] DEFAULT: None deprecated The deprecated registry names for the function TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Callable [[ InFunc ], InFunc ] Source code in confit/registry.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register get ( name ) Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. PARAMETER DESCRIPTION name The name of the function TYPE: str RETURNS DESCRIPTION InFunc Source code in confit/registry.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace ) get_available () Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. Source code in confit/registry.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result ) MetaRegistryCollection Bases: type A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. Source code in confit/registry.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 class MetaRegistryCollection ( type ): \"\"\" A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. \"\"\" def __setattr__ ( self , key , value ): assert isinstance ( value , Registry ) value . registry = self super () . __setattr__ ( key , value ) def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls __init__ ( name , bases , dct ) Initialize the registry collection by adding it-self as the registry collection of all registries. PARAMETER DESCRIPTION name bases dct Source code in confit/registry.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls RegistryCollection A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) Source code in confit/registry.py 545 546 547 548 549 550 551 552 553 class RegistryCollection ( metaclass = MetaRegistryCollection ): \"\"\" A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) \"\"\" validate_arguments ( func = None , * , config = None , invoker = None , registry = None ) Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing PARAMETER DESCRIPTION func The function or class to call TYPE: Optional [ Callable ] DEFAULT: None config The validation configuration object TYPE: Dict DEFAULT: None invoker An optional invoker to apply on the validated function TYPE: Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] DEFAULT: None registry The registry to use to resolve the default parameters TYPE: Any DEFAULT: None RETURNS DESCRIPTION Any Source code in confit/registry.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def validate_arguments ( func : Optional [ Callable ] = None , * , config : Dict = None , invoker : Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] = None , registry : Any = None , ) -> Any : \"\"\" Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing Parameters ---------- func: Callable The function or class to call config: Dict The validation configuration object invoker: Optional[Callable] An optional invoker to apply on the validated function registry: Any The registry to use to resolve the default parameters Returns ------- Any \"\"\" if config is None : config = {} config = { ** config , \"arbitrary_types_allowed\" : True } def validate ( _func : Callable ) -> Callable : if isinstance ( _func , type ): _func : type if hasattr ( _func . __init__ , \"__wrapped__\" ): vd = ValidatedFunction ( _func . __init__ . __wrapped__ , config ) else : vd = ValidatedFunction ( _func . __init__ , config ) vd . model . __name__ = _func . __name__ if hasattr ( vd . model , \"model_fields\" ): vd . model . model_fields [ \"self\" ] . default = None else : vd . model . __fields__ [ \"self\" ] . default = None # This function is called by Pydantic when asked to cast # a value (most likely a dict) as a Model (most often during # a function call) old_get_validators = ( _func . __get_validators__ if hasattr ( _func , \"__get_validators__\" ) else None ) old_get_pydantic_core_schema = ( _func . __get_pydantic_core_schema__ if hasattr ( _func , \"__get_pydantic_core_schema__\" ) else None ) def __get_validators__ (): \"\"\" This function is called by Pydantic when asked to cast a value (most likely a dict) as a Model (most often during a function call) Yields ------- Callable The validator function \"\"\" def _validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) if old_get_validators is not None : for validator in old_get_validators (): value = validator ( value ) if isinstance ( value , _func ): return value return _func ( ** value ) yield _validate def __get_pydantic_core_schema__ ( * args , ** kwargs ): from pydantic_core import core_schema def pre_validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) return value def post_validate ( value ): if isinstance ( value , _func ): return value return _func ( ** value ) return core_schema . chain_schema ( [ core_schema . no_info_plain_validator_function ( pre_validate ), * ( ( old_get_pydantic_core_schema ( * args , ** kwargs ),) if old_get_pydantic_core_schema else ( core_schema . no_info_plain_validator_function ( fn ) for fn in old_get_validators () ) if old_get_validators is not None else () ), core_schema . no_info_plain_validator_function ( post_validate ), ] ) # This function is called when we do Model(variable=..., other=...) @wraps ( vd . raw_function , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = True , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __context__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) _func . vd = vd # type: ignore _func . __get_validators__ = __get_validators__ # type: ignore _func . __get_pydantic_core_schema__ = ( __get_pydantic_core_schema__ # type: ignore ) _func . model = vd . model # type: ignore _func . model . type_ = _func # type: ignore _func . __init__ = wrapper_function _func . __init__ . __wrapped__ = vd . raw_function # type: ignore return _func else : vd = ValidatedFunction ( _func , config ) @wraps ( _func , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = False , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __cause__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) wrapper_function . vd = vd # type: ignore wrapper_function . validate = vd . init_model_instance # type: ignore wrapper_function . __wrapped__ = vd . raw_function # type: ignore wrapper_function . model = vd . model # type: ignore return wrapper_function if func : return validate ( func ) else : return validate get_default_registry () Get the default registered registry. RETURNS DESCRIPTION Registry Source code in confit/registry.py 556 557 558 559 560 561 562 563 564 def get_default_registry () -> Any : \"\"\" Get the default registered registry. Returns ------- Registry \"\"\" return _default_registry set_default_registry ( registry ) Set the default registered registry. This is used in Config.resolve() when no registry is provided. PARAMETER DESCRIPTION registry TYPE: CustomRegistry RETURNS DESCRIPTION Registry Source code in confit/registry.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 def set_default_registry ( registry : CustomRegistry ) -> CustomRegistry : \"\"\" Set the default registered registry. This is used in [`Config.resolve()`][confit.config.Config.resolve] when no registry is provided. Parameters ---------- registry: Registry Returns ------- Registry \"\"\" global _default_registry _default_registry = registry return registry","title":"registry"},{"location":"reference/registry/#confitregistry","text":"","title":"confit.registry"},{"location":"reference/registry/#confit.registry.VisibleDeprecationWarning","text":"Bases: UserWarning Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 Source code in confit/registry.py 346 347 348 349 350 351 352 353 354 355 class VisibleDeprecationWarning ( UserWarning ): \"\"\" Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 \"\"\" # noqa: E501","title":"VisibleDeprecationWarning"},{"location":"reference/registry/#confit.registry.Registry","text":"Bases: Registry A registry that validates the input arguments of the registered functions. Source code in confit/registry.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 class Registry ( catalogue . Registry ): \"\"\" A registry that validates the input arguments of the registered functions. \"\"\" def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace ) def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result )","title":"Registry"},{"location":"reference/registry/#confit.registry.Registry.__init__","text":"Initialize the registry. PARAMETER DESCRIPTION namespace The namespace of the registry TYPE: Sequence [ str ] entry_points Should we use entry points to load the registered functions TYPE: bool DEFAULT: False Source code in confit/registry.py 366 367 368 369 370 371 372 373 374 375 376 377 378 def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None","title":"__init__()"},{"location":"reference/registry/#confit.registry.Registry.register","text":"This is a convenience wrapper around catalogue.Registry.register , that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. PARAMETER DESCRIPTION name The name of the function TYPE: str func The function to register TYPE: Optional [ InFunc ] DEFAULT: None save_params Additional parameters to save when the function is called. If falsy, the function parameters are not saved TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None skip_save_params List of parameters to skip when saving the function parameters TYPE: Sequence [ str ] DEFAULT: () invoker An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. TYPE: Optional [ Callable ] DEFAULT: None deprecated The deprecated registry names for the function TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Callable [[ InFunc ], InFunc ] Source code in confit/registry.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register","title":"register()"},{"location":"reference/registry/#confit.registry.Registry.get","text":"Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. PARAMETER DESCRIPTION name The name of the function TYPE: str RETURNS DESCRIPTION InFunc Source code in confit/registry.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace )","title":"get()"},{"location":"reference/registry/#confit.registry.Registry.get_available","text":"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. Source code in confit/registry.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result )","title":"get_available()"},{"location":"reference/registry/#confit.registry.MetaRegistryCollection","text":"Bases: type A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. Source code in confit/registry.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 class MetaRegistryCollection ( type ): \"\"\" A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. \"\"\" def __setattr__ ( self , key , value ): assert isinstance ( value , Registry ) value . registry = self super () . __setattr__ ( key , value ) def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls","title":"MetaRegistryCollection"},{"location":"reference/registry/#confit.registry.MetaRegistryCollection.__init__","text":"Initialize the registry collection by adding it-self as the registry collection of all registries. PARAMETER DESCRIPTION name bases dct Source code in confit/registry.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls","title":"__init__()"},{"location":"reference/registry/#confit.registry.RegistryCollection","text":"A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) Source code in confit/registry.py 545 546 547 548 549 550 551 552 553 class RegistryCollection ( metaclass = MetaRegistryCollection ): \"\"\" A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) \"\"\"","title":"RegistryCollection"},{"location":"reference/registry/#confit.registry.validate_arguments","text":"Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing PARAMETER DESCRIPTION func The function or class to call TYPE: Optional [ Callable ] DEFAULT: None config The validation configuration object TYPE: Dict DEFAULT: None invoker An optional invoker to apply on the validated function TYPE: Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] DEFAULT: None registry The registry to use to resolve the default parameters TYPE: Any DEFAULT: None RETURNS DESCRIPTION Any Source code in confit/registry.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def validate_arguments ( func : Optional [ Callable ] = None , * , config : Dict = None , invoker : Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] = None , registry : Any = None , ) -> Any : \"\"\" Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing Parameters ---------- func: Callable The function or class to call config: Dict The validation configuration object invoker: Optional[Callable] An optional invoker to apply on the validated function registry: Any The registry to use to resolve the default parameters Returns ------- Any \"\"\" if config is None : config = {} config = { ** config , \"arbitrary_types_allowed\" : True } def validate ( _func : Callable ) -> Callable : if isinstance ( _func , type ): _func : type if hasattr ( _func . __init__ , \"__wrapped__\" ): vd = ValidatedFunction ( _func . __init__ . __wrapped__ , config ) else : vd = ValidatedFunction ( _func . __init__ , config ) vd . model . __name__ = _func . __name__ if hasattr ( vd . model , \"model_fields\" ): vd . model . model_fields [ \"self\" ] . default = None else : vd . model . __fields__ [ \"self\" ] . default = None # This function is called by Pydantic when asked to cast # a value (most likely a dict) as a Model (most often during # a function call) old_get_validators = ( _func . __get_validators__ if hasattr ( _func , \"__get_validators__\" ) else None ) old_get_pydantic_core_schema = ( _func . __get_pydantic_core_schema__ if hasattr ( _func , \"__get_pydantic_core_schema__\" ) else None ) def __get_validators__ (): \"\"\" This function is called by Pydantic when asked to cast a value (most likely a dict) as a Model (most often during a function call) Yields ------- Callable The validator function \"\"\" def _validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) if old_get_validators is not None : for validator in old_get_validators (): value = validator ( value ) if isinstance ( value , _func ): return value return _func ( ** value ) yield _validate def __get_pydantic_core_schema__ ( * args , ** kwargs ): from pydantic_core import core_schema def pre_validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) return value def post_validate ( value ): if isinstance ( value , _func ): return value return _func ( ** value ) return core_schema . chain_schema ( [ core_schema . no_info_plain_validator_function ( pre_validate ), * ( ( old_get_pydantic_core_schema ( * args , ** kwargs ),) if old_get_pydantic_core_schema else ( core_schema . no_info_plain_validator_function ( fn ) for fn in old_get_validators () ) if old_get_validators is not None else () ), core_schema . no_info_plain_validator_function ( post_validate ), ] ) # This function is called when we do Model(variable=..., other=...) @wraps ( vd . raw_function , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = True , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __context__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) _func . vd = vd # type: ignore _func . __get_validators__ = __get_validators__ # type: ignore _func . __get_pydantic_core_schema__ = ( __get_pydantic_core_schema__ # type: ignore ) _func . model = vd . model # type: ignore _func . model . type_ = _func # type: ignore _func . __init__ = wrapper_function _func . __init__ . __wrapped__ = vd . raw_function # type: ignore return _func else : vd = ValidatedFunction ( _func , config ) @wraps ( _func , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = False , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __cause__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) wrapper_function . vd = vd # type: ignore wrapper_function . validate = vd . init_model_instance # type: ignore wrapper_function . __wrapped__ = vd . raw_function # type: ignore wrapper_function . model = vd . model # type: ignore return wrapper_function if func : return validate ( func ) else : return validate","title":"validate_arguments()"},{"location":"reference/registry/#confit.registry.get_default_registry","text":"Get the default registered registry. RETURNS DESCRIPTION Registry Source code in confit/registry.py 556 557 558 559 560 561 562 563 564 def get_default_registry () -> Any : \"\"\" Get the default registered registry. Returns ------- Registry \"\"\" return _default_registry","title":"get_default_registry()"},{"location":"reference/registry/#confit.registry.set_default_registry","text":"Set the default registered registry. This is used in Config.resolve() when no registry is provided. PARAMETER DESCRIPTION registry TYPE: CustomRegistry RETURNS DESCRIPTION Registry Source code in confit/registry.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 def set_default_registry ( registry : CustomRegistry ) -> CustomRegistry : \"\"\" Set the default registered registry. This is used in [`Config.resolve()`][confit.config.Config.resolve] when no registry is provided. Parameters ---------- registry: Registry Returns ------- Registry \"\"\" global _default_registry _default_registry = registry return registry","title":"set_default_registry()"},{"location":"reference/utils/","text":"confit.utils","title":"index"},{"location":"reference/utils/#confitutils","text":"","title":"confit.utils"},{"location":"reference/utils/collections/","text":"confit.utils.collections join_path ( path ) Join a path into a string and quotes subpaths that contain dots. PARAMETER DESCRIPTION path RETURNS DESCRIPTION str Source code in confit/utils/collections.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def join_path ( path ): \"\"\" Join a path into a string and quotes subpaths that contain dots. Parameters ---------- path: Tuple[Union[int, str]] Returns ------- str \"\"\" return \".\" . join ( repr ( x ) if not isinstance ( x , str ) or split_path ( x . strip ()) != ( x ,) else x for x in path ) split_path ( path ) Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. PARAMETER DESCRIPTION path TYPE: str Source code in confit/utils/collections.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def split_path ( path : str ) -> Tuple [ Union [ int , str ]]: \"\"\" Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. Parameters ---------- path: str Returns ------- \"\"\" offset = 0 result = [] for match in re . finditer ( KEY_PART , str ( path )): assert match . start () == offset , f \"Malformed path: { path !r} in config\" offset = match . end () part = next (( g for g in match . groups () if g is not None )) result . append ( int ( part ) if part . isdigit () else part ) if offset == len ( path ): break return tuple ( result ) flatten_sections ( root ) Flatten a nested dict of dicts into a \"flat\" dict of dict. PARAMETER DESCRIPTION root The root dict to flatten TYPE: Dict [ str , Any ] RETURNS DESCRIPTION Dict [ str , Dict [ str , Any ]] Source code in confit/utils/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def flatten_sections ( root : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Flatten a nested dict of dicts into a \"flat\" dict of dict. Parameters ---------- root: Dict[str, Any] The root dict to flatten Returns ------- Dict[str, Dict[str, Any]] \"\"\" res = collections . defaultdict ( lambda : {}) def rec ( d , path ): res . setdefault ( join_path ( path ), {}) section = {} for k , v in d . items (): if isinstance ( v , dict ): rec ( v , ( * path , k )) else : section [ k ] = v res [ join_path ( path )] . update ( section ) rec ( root , ()) root_level = res . pop ( \"\" , None ) if root_level is not None and len ( root_level ) > 0 : raise Exception ( \"Cannot dump root level config\" , root_level ) return dict ( res )","title":"collections"},{"location":"reference/utils/collections/#confitutilscollections","text":"","title":"confit.utils.collections"},{"location":"reference/utils/collections/#confit.utils.collections.join_path","text":"Join a path into a string and quotes subpaths that contain dots. PARAMETER DESCRIPTION path RETURNS DESCRIPTION str Source code in confit/utils/collections.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def join_path ( path ): \"\"\" Join a path into a string and quotes subpaths that contain dots. Parameters ---------- path: Tuple[Union[int, str]] Returns ------- str \"\"\" return \".\" . join ( repr ( x ) if not isinstance ( x , str ) or split_path ( x . strip ()) != ( x ,) else x for x in path )","title":"join_path()"},{"location":"reference/utils/collections/#confit.utils.collections.split_path","text":"Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. PARAMETER DESCRIPTION path TYPE: str Source code in confit/utils/collections.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def split_path ( path : str ) -> Tuple [ Union [ int , str ]]: \"\"\" Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. Parameters ---------- path: str Returns ------- \"\"\" offset = 0 result = [] for match in re . finditer ( KEY_PART , str ( path )): assert match . start () == offset , f \"Malformed path: { path !r} in config\" offset = match . end () part = next (( g for g in match . groups () if g is not None )) result . append ( int ( part ) if part . isdigit () else part ) if offset == len ( path ): break return tuple ( result )","title":"split_path()"},{"location":"reference/utils/collections/#confit.utils.collections.flatten_sections","text":"Flatten a nested dict of dicts into a \"flat\" dict of dict. PARAMETER DESCRIPTION root The root dict to flatten TYPE: Dict [ str , Any ] RETURNS DESCRIPTION Dict [ str , Dict [ str , Any ]] Source code in confit/utils/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def flatten_sections ( root : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Flatten a nested dict of dicts into a \"flat\" dict of dict. Parameters ---------- root: Dict[str, Any] The root dict to flatten Returns ------- Dict[str, Dict[str, Any]] \"\"\" res = collections . defaultdict ( lambda : {}) def rec ( d , path ): res . setdefault ( join_path ( path ), {}) section = {} for k , v in d . items (): if isinstance ( v , dict ): rec ( v , ( * path , k )) else : section [ k ] = v res [ join_path ( path )] . update ( section ) rec ( root , ()) root_level = res . pop ( \"\" , None ) if root_level is not None and len ( root_level ) > 0 : raise Exception ( \"Cannot dump root level config\" , root_level ) return dict ( res )","title":"flatten_sections()"},{"location":"reference/utils/eval/","text":"confit.utils.eval Transformer Bases: NodeTransformer An ast NodeTransformer that only allows a subset of the Python AST. Source code in confit/utils/eval.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Transformer ( ast . NodeTransformer ): \"\"\" An ast NodeTransformer that only allows a subset of the Python AST. \"\"\" ALLOWED_NODE_TYPES = { \"Expression\" , \"Attribute\" , \"Slice\" , \"Subscript\" , \"Index\" , \"Constant\" , \"Tuple\" , \"Name\" , \"Load\" , \"Str\" , \"BinOp\" , \"Num\" , \"List\" , \"Dict\" , \"Set\" , \"Add\" , \"Sub\" , \"Mult\" , \"Div\" , \"FloorDiv\" , \"Mod\" , \"Pow\" , \"LShift\" , \"RShift\" , \"BitOr\" , \"BitXor\" , \"BitAnd\" , \"MatMult\" , \"And\" , \"Or\" , \"Compare\" , \"Eq\" , \"NotEq\" , \"Lt\" , \"LtE\" , \"Gt\" , \"GtE\" , \"Is\" , \"IsNot\" , \"In\" , \"NotIn\" , \"Starred\" , } def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node ) generic_visit ( node ) Checks that the node type is allowed. Source code in confit/utils/eval.py 55 56 57 58 59 60 61 62 63 def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node ) safe_eval ( source , locals_dict = None ) Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. PARAMETER DESCRIPTION source The expression to evaluate TYPE: str locals_dict The local variables to use in the evaluation TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None RETURNS DESCRIPTION Any The result of the evaluation Source code in confit/utils/eval.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def safe_eval ( source : str , locals_dict : Optional [ Dict [ str , Any ]] = None ): \"\"\" Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. Parameters ---------- source: str The expression to evaluate locals_dict: Optional[Dict[str, Any]] The local variables to use in the evaluation Returns ------- Any The result of the evaluation \"\"\" tree = ast . parse ( source , mode = \"eval\" ) transformer . visit ( tree ) clause = compile ( tree , \"<AST>\" , \"eval\" ) result = eval ( clause , { \"__builtins__\" : {}}, locals_dict ) return result","title":"eval"},{"location":"reference/utils/eval/#confitutilseval","text":"","title":"confit.utils.eval"},{"location":"reference/utils/eval/#confit.utils.eval.Transformer","text":"Bases: NodeTransformer An ast NodeTransformer that only allows a subset of the Python AST. Source code in confit/utils/eval.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Transformer ( ast . NodeTransformer ): \"\"\" An ast NodeTransformer that only allows a subset of the Python AST. \"\"\" ALLOWED_NODE_TYPES = { \"Expression\" , \"Attribute\" , \"Slice\" , \"Subscript\" , \"Index\" , \"Constant\" , \"Tuple\" , \"Name\" , \"Load\" , \"Str\" , \"BinOp\" , \"Num\" , \"List\" , \"Dict\" , \"Set\" , \"Add\" , \"Sub\" , \"Mult\" , \"Div\" , \"FloorDiv\" , \"Mod\" , \"Pow\" , \"LShift\" , \"RShift\" , \"BitOr\" , \"BitXor\" , \"BitAnd\" , \"MatMult\" , \"And\" , \"Or\" , \"Compare\" , \"Eq\" , \"NotEq\" , \"Lt\" , \"LtE\" , \"Gt\" , \"GtE\" , \"Is\" , \"IsNot\" , \"In\" , \"NotIn\" , \"Starred\" , } def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node )","title":"Transformer"},{"location":"reference/utils/eval/#confit.utils.eval.Transformer.generic_visit","text":"Checks that the node type is allowed. Source code in confit/utils/eval.py 55 56 57 58 59 60 61 62 63 def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node )","title":"generic_visit()"},{"location":"reference/utils/eval/#confit.utils.eval.safe_eval","text":"Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. PARAMETER DESCRIPTION source The expression to evaluate TYPE: str locals_dict The local variables to use in the evaluation TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None RETURNS DESCRIPTION Any The result of the evaluation Source code in confit/utils/eval.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def safe_eval ( source : str , locals_dict : Optional [ Dict [ str , Any ]] = None ): \"\"\" Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. Parameters ---------- source: str The expression to evaluate locals_dict: Optional[Dict[str, Any]] The local variables to use in the evaluation Returns ------- Any The result of the evaluation \"\"\" tree = ast . parse ( source , mode = \"eval\" ) transformer . visit ( tree ) clause = compile ( tree , \"<AST>\" , \"eval\" ) result = eval ( clause , { \"__builtins__\" : {}}, locals_dict ) return result","title":"safe_eval()"},{"location":"reference/utils/random/","text":"confit.utils.random set_seed Source code in confit/utils/random.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class set_seed : def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_val , exc_tb ): set_random_generator_state ( self . state ) __init__ ( seed , cuda = None ) Set seed values for random generators. If used as a context, restore the random state used before entering the context. PARAMETER DESCRIPTION seed Value used as a seed. cuda Saves the cuda random states too TYPE: Optional [ bool ] DEFAULT: None Source code in confit/utils/random.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass get_random_generator_state ( cuda = None ) Get the torch , numpy and random random generator state. PARAMETER DESCRIPTION cuda Saves the cuda random states too DEFAULT: None RETURNS DESCRIPTION RandomGeneratorState Source code in confit/utils/random.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def get_random_generator_state ( cuda = None ): \"\"\" Get the `torch`, `numpy` and `random` random generator state. Parameters ---------- cuda: bool Saves the cuda random states too Returns ------- RandomGeneratorState \"\"\" torch_state = torch_cuda_state = numpy_state = None random_state = random . getstate () try : import torch torch_state = torch . random . get_rng_state () if cuda or ( cuda is None and torch . cuda . is_available ()): # pragma: no cover torch_cuda_state = torch . cuda . get_rng_state_all () except ImportError : # pragma: no cover pass try : import numpy numpy_state = numpy . random . get_state () except ImportError : # pragma: no cover pass return RandomGeneratorState ( random_state , torch_state , numpy_state , torch_cuda_state , ) set_random_generator_state ( state ) Set the torch , numpy and random random generator state. PARAMETER DESCRIPTION state Source code in confit/utils/random.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_random_generator_state ( state ): \"\"\" Set the `torch`, `numpy` and `random` random generator state. Parameters ---------- state: RandomGeneratorState \"\"\" random . setstate ( state . random ) if state . torch is not None : import torch torch . random . set_rng_state ( state . torch ) if ( state . torch_cuda is not None and torch . cuda . is_available () and len ( state . torch_cuda ) == torch . cuda . device_count () ): # pragma: no cover torch . cuda . set_rng_state_all ( state . torch_cuda ) if state . numpy is not None : import numpy numpy . random . set_state ( state . numpy )","title":"random"},{"location":"reference/utils/random/#confitutilsrandom","text":"","title":"confit.utils.random"},{"location":"reference/utils/random/#confit.utils.random.set_seed","text":"Source code in confit/utils/random.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class set_seed : def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_val , exc_tb ): set_random_generator_state ( self . state )","title":"set_seed"},{"location":"reference/utils/random/#confit.utils.random.set_seed.__init__","text":"Set seed values for random generators. If used as a context, restore the random state used before entering the context. PARAMETER DESCRIPTION seed Value used as a seed. cuda Saves the cuda random states too TYPE: Optional [ bool ] DEFAULT: None Source code in confit/utils/random.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass","title":"__init__()"},{"location":"reference/utils/random/#confit.utils.random.get_random_generator_state","text":"Get the torch , numpy and random random generator state. PARAMETER DESCRIPTION cuda Saves the cuda random states too DEFAULT: None RETURNS DESCRIPTION RandomGeneratorState Source code in confit/utils/random.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def get_random_generator_state ( cuda = None ): \"\"\" Get the `torch`, `numpy` and `random` random generator state. Parameters ---------- cuda: bool Saves the cuda random states too Returns ------- RandomGeneratorState \"\"\" torch_state = torch_cuda_state = numpy_state = None random_state = random . getstate () try : import torch torch_state = torch . random . get_rng_state () if cuda or ( cuda is None and torch . cuda . is_available ()): # pragma: no cover torch_cuda_state = torch . cuda . get_rng_state_all () except ImportError : # pragma: no cover pass try : import numpy numpy_state = numpy . random . get_state () except ImportError : # pragma: no cover pass return RandomGeneratorState ( random_state , torch_state , numpy_state , torch_cuda_state , )","title":"get_random_generator_state()"},{"location":"reference/utils/random/#confit.utils.random.set_random_generator_state","text":"Set the torch , numpy and random random generator state. PARAMETER DESCRIPTION state Source code in confit/utils/random.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_random_generator_state ( state ): \"\"\" Set the `torch`, `numpy` and `random` random generator state. Parameters ---------- state: RandomGeneratorState \"\"\" random . setstate ( state . random ) if state . torch is not None : import torch torch . random . set_rng_state ( state . torch ) if ( state . torch_cuda is not None and torch . cuda . is_available () and len ( state . torch_cuda ) == torch . cuda . device_count () ): # pragma: no cover torch . cuda . set_rng_state_all ( state . torch_cuda ) if state . numpy is not None : import numpy numpy . random . set_state ( state . numpy )","title":"set_random_generator_state()"},{"location":"reference/utils/settings/","text":"confit.utils.settings","title":"settings"},{"location":"reference/utils/settings/#confitutilssettings","text":"","title":"confit.utils.settings"},{"location":"reference/utils/xjson/","text":"confit.utils.xjson Reference A path reference to a value in the configuration. Source code in confit/utils/xjson.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Reference : \"\"\" A path reference to a value in the configuration. \"\"\" def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value def __repr__ ( self ): return f \"$ {{ { self . value } }} \" def __str__ ( self ): return self . __repr__ () def __eq__ ( self , other ): return self . value == other . value __init__ ( value ) PARAMETER DESCRIPTION value The path to the value in the configuration. TYPE: str Source code in confit/utils/xjson.py 13 14 15 16 17 18 19 20 def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value XJsonTransformer Bases: Transformer A Lark transformer to parse extended JSON. Source code in confit/utils/xjson.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class XJsonTransformer ( Transformer ): \"\"\" A Lark transformer to parse extended JSON. \"\"\" def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n ) def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n ) def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ]) list = list tuple = tuple pair = tuple dict = dict def null ( self , _ ): \"\"\"Parse null\"\"\" return None def true ( self , _ ): \"\"\"Parse true\"\"\" return True def false ( self , _ ): \"\"\"Parse false\"\"\" return False def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" ) def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" ) def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" ) __init__ ( input_string ) PARAMETER DESCRIPTION input_string The input string to parse. TYPE: str Source code in confit/utils/xjson.py 88 89 90 91 92 93 94 95 96 def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string string ( s ) Parse string Source code in confit/utils/xjson.py 98 99 100 101 102 def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s float ( n ) Parse number Source code in confit/utils/xjson.py 104 105 106 107 def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n ) int ( n ) Parse number Source code in confit/utils/xjson.py 109 110 111 112 def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n ) reference ( tree ) Parse reference Source code in confit/utils/xjson.py 114 115 116 117 def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ]) null ( _ ) Parse null Source code in confit/utils/xjson.py 124 125 126 def null ( self , _ ): \"\"\"Parse null\"\"\" return None true ( _ ) Parse true Source code in confit/utils/xjson.py 128 129 130 def true ( self , _ ): \"\"\"Parse true\"\"\" return True false ( _ ) Parse false Source code in confit/utils/xjson.py 132 133 134 def false ( self , _ ): \"\"\"Parse false\"\"\" return False plus_inf ( _ ) Parse infinity Source code in confit/utils/xjson.py 136 137 138 def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" ) minus_inf ( _ ) Parse -infinity Source code in confit/utils/xjson.py 140 141 142 def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" ) nan ( _ ) Parse nan Source code in confit/utils/xjson.py 144 145 146 def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" ) loads ( s ) Load an extended JSON string into a python object. Takes care of detecting references and tuples PARAMETER DESCRIPTION s TYPE: str RETURNS DESCRIPTION Any Source code in confit/utils/xjson.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def loads ( s : str ): \"\"\" Load an extended JSON string into a python object. Takes care of detecting references and tuples Parameters ---------- s: str Returns ------- Any \"\"\" try : return XJsonTransformer ( s ) . transform ( _json_parser . parse ( s )) except Exception : # Fail if we suspect that it is a malformed object # (e.g. has ', \", {, }, [, ] in it) if set ( s ) & set ( \",' \\\" {} []$\" ): raise MalformedValueError ( s ) return s dumps ( o ) Dump a python object into an extended JSON string. Takes care of serializing references and tuples PARAMETER DESCRIPTION o TYPE: Any RETURNS DESCRIPTION str Source code in confit/utils/xjson.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def dumps ( o : Any ): \"\"\" Dump a python object into an extended JSON string. Takes care of serializing references and tuples Parameters ---------- o: Any Returns ------- str \"\"\" return \"\" . join ( _make_iterencode ()( o ))","title":"xjson"},{"location":"reference/utils/xjson/#confitutilsxjson","text":"","title":"confit.utils.xjson"},{"location":"reference/utils/xjson/#confit.utils.xjson.Reference","text":"A path reference to a value in the configuration. Source code in confit/utils/xjson.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Reference : \"\"\" A path reference to a value in the configuration. \"\"\" def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value def __repr__ ( self ): return f \"$ {{ { self . value } }} \" def __str__ ( self ): return self . __repr__ () def __eq__ ( self , other ): return self . value == other . value","title":"Reference"},{"location":"reference/utils/xjson/#confit.utils.xjson.Reference.__init__","text":"PARAMETER DESCRIPTION value The path to the value in the configuration. TYPE: str Source code in confit/utils/xjson.py 13 14 15 16 17 18 19 20 def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value","title":"__init__()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer","text":"Bases: Transformer A Lark transformer to parse extended JSON. Source code in confit/utils/xjson.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class XJsonTransformer ( Transformer ): \"\"\" A Lark transformer to parse extended JSON. \"\"\" def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n ) def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n ) def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ]) list = list tuple = tuple pair = tuple dict = dict def null ( self , _ ): \"\"\"Parse null\"\"\" return None def true ( self , _ ): \"\"\"Parse true\"\"\" return True def false ( self , _ ): \"\"\"Parse false\"\"\" return False def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" ) def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" ) def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" )","title":"XJsonTransformer"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.__init__","text":"PARAMETER DESCRIPTION input_string The input string to parse. TYPE: str Source code in confit/utils/xjson.py 88 89 90 91 92 93 94 95 96 def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string","title":"__init__()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.string","text":"Parse string Source code in confit/utils/xjson.py 98 99 100 101 102 def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s","title":"string()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.float","text":"Parse number Source code in confit/utils/xjson.py 104 105 106 107 def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n )","title":"float()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.int","text":"Parse number Source code in confit/utils/xjson.py 109 110 111 112 def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n )","title":"int()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.reference","text":"Parse reference Source code in confit/utils/xjson.py 114 115 116 117 def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ])","title":"reference()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.null","text":"Parse null Source code in confit/utils/xjson.py 124 125 126 def null ( self , _ ): \"\"\"Parse null\"\"\" return None","title":"null()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.true","text":"Parse true Source code in confit/utils/xjson.py 128 129 130 def true ( self , _ ): \"\"\"Parse true\"\"\" return True","title":"true()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.false","text":"Parse false Source code in confit/utils/xjson.py 132 133 134 def false ( self , _ ): \"\"\"Parse false\"\"\" return False","title":"false()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.plus_inf","text":"Parse infinity Source code in confit/utils/xjson.py 136 137 138 def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" )","title":"plus_inf()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.minus_inf","text":"Parse -infinity Source code in confit/utils/xjson.py 140 141 142 def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" )","title":"minus_inf()"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.nan","text":"Parse nan Source code in confit/utils/xjson.py 144 145 146 def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" )","title":"nan()"},{"location":"reference/utils/xjson/#confit.utils.xjson.loads","text":"Load an extended JSON string into a python object. Takes care of detecting references and tuples PARAMETER DESCRIPTION s TYPE: str RETURNS DESCRIPTION Any Source code in confit/utils/xjson.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def loads ( s : str ): \"\"\" Load an extended JSON string into a python object. Takes care of detecting references and tuples Parameters ---------- s: str Returns ------- Any \"\"\" try : return XJsonTransformer ( s ) . transform ( _json_parser . parse ( s )) except Exception : # Fail if we suspect that it is a malformed object # (e.g. has ', \", {, }, [, ] in it) if set ( s ) & set ( \",' \\\" {} []$\" ): raise MalformedValueError ( s ) return s","title":"loads()"},{"location":"reference/utils/xjson/#confit.utils.xjson.dumps","text":"Dump a python object into an extended JSON string. Takes care of serializing references and tuples PARAMETER DESCRIPTION o TYPE: Any RETURNS DESCRIPTION str Source code in confit/utils/xjson.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def dumps ( o : Any ): \"\"\" Dump a python object into an extended JSON string. Takes care of serializing references and tuples Parameters ---------- o: Any Returns ------- str \"\"\" return \"\" . join ( _make_iterencode ()( o ))","title":"dumps()"},{"location":"en/reference/","text":"confit","title":"confit"},{"location":"en/reference/autoreload/","text":"confit.autoreload Plugin to help IPython's autoreload magic reload functions wrapped with confit.","title":"confit.autoreload"},{"location":"en/reference/cli/","text":"confit.cli Cli Bases: Typer Custom Typer object that: validates a command parameters before executing it accepts a configuration file describing the parameters automatically instantiates parameters given a dictionary when type hinted Source code in confit/cli.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class Cli ( Typer ): \"\"\" Custom Typer object that: - validates a command parameters before executing it - accepts a configuration file describing the parameters - automatically instantiates parameters given a dictionary when type hinted \"\"\" def command ( # noqa self , name , * , cls : Optional [ Type [ TyperCommand ]] = None , context_settings : Optional [ Dict [ Any , Any ]] = None , help : Optional [ str ] = None , epilog : Optional [ str ] = None , short_help : Optional [ str ] = None , options_metavar : str = \"[OPTIONS]\" , add_help_option : bool = True , no_args_is_help : bool = False , hidden : bool = False , deprecated : bool = False , # Rich settings rich_help_panel : Union [ str , None ] = Default ( None ), registry : Any = None , ) -> Callable [[ CommandFunctionType ], CommandFunctionType ]: typer_command = super () . command ( name = name , cls = cls , help = help , epilog = epilog , short_help = short_help , options_metavar = options_metavar , add_help_option = add_help_option , no_args_is_help = no_args_is_help , hidden = hidden , deprecated = deprecated , rich_help_panel = rich_help_panel , context_settings = { ** ( context_settings or {}), \"ignore_unknown_options\" : True , \"allow_extra_args\" : True , }, ) def wrapper ( fn ): validated = validate_arguments ( fn ) @typer_command def command ( ctx : Context , config : Optional [ List [ Path ]] = None ): config_path = config has_meta = _fn_has_meta ( fn ) if config_path : config , name_from_file = merge_from_disk ( config_path ) else : config = Config ({ name : {}}) model_fields = ( validated . model . model_fields if hasattr ( validated . model , \"model_fields\" ) else validated . model . __fields__ ) for k , v in parse_overrides ( ctx . args ) . items (): if \".\" not in k : parts = ( name , k ) else : parts = k . split ( \".\" ) if parts [ 0 ] in model_fields and parts [ 0 ] not in config : parts = ( name , * parts ) current = config if parts [ 0 ] not in current : raise Exception ( f \" { k } does not match any existing section in config\" ) for part in parts [: - 1 ]: current = current . setdefault ( part , Config ()) current [ parts [ - 1 ]] = v try : resolved_config = config . resolve ( registry = registry ) default_seed = model_fields . get ( \"seed\" ) if default_seed is not None : default_seed = default_seed . get_default () seed = config . get ( name , {}) . get ( \"seed\" , default_seed ) if seed is not None : set_seed ( seed ) if has_meta : config_meta = dict ( config_path = config_path , resolved_config = resolved_config , unresolved_config = config , ) return validated ( ** resolved_config . get ( name , {}), config_meta = config_meta , ) else : return validated ( ** resolved_config . get ( name , {})) except ( LegacyValidationError , ConfitValidationError ) as e : e . raw_errors = patch_errors ( e . raw_errors , ( name ,), ) if is_debug () or e . __cause__ is not None : raise e try : import rich console = rich . console . Console ( stderr = True ) console . print ( \"Validation error:\" , style = \"red\" , end = \" \" ) console . print ( str ( e )) except ImportError : # pragma: no cover print ( \"Validation error:\" , file = sys . stderr , end = \" \" ) print ( str ( e ), file = sys . stderr ) sys . exit ( 1 ) return validated return wrapper parse_overrides ( args ) Parse the overrides from the command line into a dictionary of key-value pairs. PARAMETER DESCRIPTION args The arguments to parse TYPE: List [ str ] RETURNS DESCRIPTION Dict [ str , Any ] The parsed overrides as a dictionary Source code in confit/cli.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def parse_overrides ( args : List [ str ]) -> Dict [ str , Any ]: \"\"\" Parse the overrides from the command line into a dictionary of key-value pairs. Parameters ---------- args: List[str] The arguments to parse Returns ------- Dict[str, Any] The parsed overrides as a dictionary \"\"\" result = {} while args : opt = args . pop ( 0 ) err = f \"Invalid config override ' { opt } '\" if opt . startswith ( \"--\" ): # new argument opt = opt . replace ( \"--\" , \"\" ) if \"=\" in opt : # we have --opt=value opt , value = opt . split ( \"=\" , 1 ) else : if not args or args [ 0 ] . startswith ( \"--\" ): # flag with no value value = \"true\" else : value = args . pop ( 0 ) opt = opt . replace ( \"-\" , \"_\" ) result [ opt ] = loads ( value ) else : secho ( f \" { err } : doesn't support shorthands\" , fg = colors . RED ) exit ( 1 ) return result","title":"confit.cli"},{"location":"en/reference/config/","text":"confit.config Config Bases: dict The configuration system consists of a supercharged dict, the Config class, that can be used to read and write to cfg files, interpolate variables and instantiate components through the registry with some special @factory keys. A cfg file can be used directly as an input to a CLI-decorated function. Source code in confit/config.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Config ( dict ): \"\"\" The configuration system consists of a supercharged dict, the `Config` class, that can be used to read and write to `cfg` files, interpolate variables and instantiate components through the registry with some special `@factory` keys. A cfg file can be used directly as an input to a CLI-decorated function. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs ) @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry ) def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s ) def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self ) def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue () def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ()) def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy @classmethod def _store_resolved ( cls , resolved : Any , config : Dict [ str , Any ]): \"\"\" Adds a resolved object to the RESOLVED_TO_CONFIG dict for later retrieval during serialization ([`.serialize`][confit.config.Config.serialize]) Parameters ---------- resolved: Any config: Config \"\"\" try : RESOLVED_TO_CONFIG [ resolved ] = config except TypeError : pass __init__ ( * args , ** kwargs ) A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. PARAMETER DESCRIPTION args TYPE: Any DEFAULT: () kwargs TYPE: Any DEFAULT: {} Source code in confit/config.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs ) from_str ( s , resolve = False , registry = None ) classmethod Load a config object from a config string PARAMETER DESCRIPTION s The cfg config string TYPE: str resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config from_disk ( path , resolve = False , registry = None ) classmethod Load a config object from a '.cfg' file PARAMETER DESCRIPTION path The path to the config object TYPE: Union [ str , Path ] resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry ) to_disk ( path ) Export a config to the disk (usually to a .cfg file) PARAMETER DESCRIPTION path TYPE: Union [ str , Path ] Source code in confit/config.py 139 140 141 142 143 144 145 146 147 148 def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s ) serialize () Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. a = A () # serializable object cfg = { \"a\" : a , \"b\" : a } print ( Config . serialize ( cfg )) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} RETURNS DESCRIPTION Config Source code in confit/config.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self ) to_str () Export a config to a string in the cfg format by serializing it first RETURNS DESCRIPTION str Source code in confit/config.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue () resolve ( deep = True , registry = None , root = None ) Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. PARAMETER DESCRIPTION deep Should we resolve deeply DEFAULT: True registry Registry to use when resolving TYPE: Any DEFAULT: None root The root of the config tree. Used for resolving references. TYPE: Mapping DEFAULT: None RETURNS DESCRIPTION Union [ Config , Any ] Source code in confit/config.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ()) merge ( * updates , remove_extra = False ) Deep merge two configs. Heavily inspired from thinc 's config merge function. PARAMETER DESCRIPTION updates Configs to update the original config TYPE: Union [ Dict [ str , Any ], Config ] DEFAULT: () remove_extra If true, restricts update to keys that existed in the original config TYPE: bool DEFAULT: False RETURNS DESCRIPTION The new config Source code in confit/config.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config copy () Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] RETURNS DESCRIPTION Any Source code in confit/config.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy merge_from_disk ( config_paths , returned_name = 'first' ) Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config PARAMETER DESCRIPTION config_paths Paths to the config files TYPE: Union [ Path , List [ Path ]] returned_name If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign TYPE: str DEFAULT: 'first' Source code in confit/config.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 def merge_from_disk ( config_paths : Union [ Path , List [ Path ]], returned_name : str = \"first\" , ): \"\"\" Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config Parameters ---------- config_paths: Union[Path, List[Path]] Paths to the config files returned_name: str If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign Returns ------- \"\"\" assert returned_name in { \"first\" , \"concat\" } if isinstance ( config_paths , Path ): config_paths = [ config_paths ] configs = [ Config . from_disk ( p , resolve = False ) for p in config_paths ] config_names = [ p . stem for p in config_paths ] name = config_names [ 0 ] if returned_name == \"first\" else \"+\" . join ( config_names ) config = configs . pop ( 0 ) return config . merge ( * configs ), name","title":"confit.config"},{"location":"en/reference/errors/","text":"confit.errors MissingReference Bases: Exception Raised when one or multiple references cannot be resolved. Source code in confit/errors.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class MissingReference ( Exception ): \"\"\" Raised when one or multiple references cannot be resolved. \"\"\" def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref ) __init__ ( ref ) PARAMETER DESCRIPTION ref The reference that could not be resolved. TYPE: Reference Source code in confit/errors.py 38 39 40 41 42 43 44 45 46 def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ () __str__ () String representation of the exception Source code in confit/errors.py 48 49 50 51 52 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref ) CyclicReferenceError Bases: Exception Raised when a cyclic reference is detected. Source code in confit/errors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class CyclicReferenceError ( Exception ): \"\"\" Raised when a cyclic reference is detected. \"\"\" def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path )) __init__ ( path ) PARAMETER DESCRIPTION path The path of the cyclic reference TYPE: Loc Source code in confit/errors.py 60 61 62 63 64 65 66 67 68 def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ () __str__ () String representation of the exception Source code in confit/errors.py 70 71 72 73 74 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path )) remove_lib_from_traceback ( tb ) Remove the lib folder from the traceback Source code in confit/errors.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def remove_lib_from_traceback ( tb ): \"\"\" Remove the lib folder from the traceback \"\"\" # compare package to module in f_globals if is_debug (): return tb if tb is not None and tb . tb_frame . f_globals . get ( \"__package__\" ) == __package__ : return remove_lib_from_traceback ( tb . tb_next ) if tb is None or tb . tb_next is None : return tb tb . tb_next = remove_lib_from_traceback ( tb . tb_next ) return tb to_legacy_error ( err , model ) Decorator to convert a Pydantic ValidationError into a ConfitValidationError Source code in confit/errors.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def to_legacy_error ( err : pydantic . ValidationError , model : Any ) -> LegacyValidationError : \"\"\" Decorator to convert a Pydantic ValidationError into a ConfitValidationError \"\"\" if isinstance ( err , LegacyValidationError ): return err errors = err . errors ( include_url = False ) raw_errors = [] for err in errors : vrepr = repr ( err [ \"input\" ]) vrepr = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr err = dict ( err ) msg = err . pop ( \"msg\" , \"\" ) msg = ( msg [ 0 ] . lower () + msg [ 1 :]) if msg else msg raw_errors . append ( ErrorWrapper ( exc = err [ \"ctx\" ][ \"error\" ] if \"ctx\" in err and \"error\" in err [ \"ctx\" ] and isinstance ( err [ \"ctx\" ][ \"error\" ], BaseException ) else PydanticNewStyleError ( ** err , msg = msg , actual_value = vrepr , actual_type = type ( err [ \"input\" ]) . __name__ , ), loc = err [ \"loc\" ], ) ) return ConfitValidationError ( raw_errors , model = model ) patch_errors ( errors , path , values = None , model = None , special_names = ()) Patch the location of the errors to add the path prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. PARAMETER DESCRIPTION errors The pydantic errors to patch TYPE: Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] path The path to add to the errors TYPE: Loc values The values of the config TYPE: Dict DEFAULT: None special_names The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] The patched errors Source code in confit/errors.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def patch_errors ( errors : Union [ Sequence [ ErrorWrapper ], ErrorWrapper ], path : Loc , values : Dict = None , model : Optional [ pydantic . BaseModel ] = None , special_names : Sequence [ str ] = (), ): \"\"\" Patch the location of the errors to add the `path` prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. Parameters ---------- errors: Union[Sequence[ErrorWrapper], ErrorWrapper] The pydantic errors to patch path: Loc The path to add to the errors values: Dict The values of the config special_names: Sequence[str] The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path Returns ------- Union[Sequence[ErrorWrapper], ErrorWrapper] The patched errors \"\"\" if isinstance ( errors , list ): res = [] for error in errors : res . extend ( patch_errors ( error , path , values , model , special_names )) return res if isinstance ( errors , ErrorWrapper ) and isinstance ( errors . exc , LegacyValidationError ): try : field_model = model for part in errors . loc_tuple (): # if not issubclass(field_model, pydantic.BaseModel) and issubclass( # field_model.vd.model, pydantic.BaseModel # ): # field_model = field_model.vd.model if hasattr ( field_model , \"model_fields\" ): field_model = field_model . model_fields [ part ] else : field_model = field_model . __fields__ [ part ] if hasattr ( field_model , \"type_\" ): field_model = field_model . type_ else : field_model = field_model . annotation if ( field_model is errors . exc . model or field_model . vd . model is errors . exc . model ): return patch_errors ( errors . exc . raw_errors , ( * path , * errors . loc_tuple ()), values , model , special_names , ) except ( KeyError , AttributeError ): # pragma: no cover print ( \"Could not find model for\" , errors . loc_tuple ()) if ( isinstance ( errors . exc , PydanticErrorMixin ) and values is not None and errors . loc_tuple () and errors . loc_tuple ()[ 0 ] in values ): if \"actual_value\" not in errors . exc . __dict__ : actual_value = values for key in errors . loc_tuple (): actual_value = actual_value [ key ] vrepr = repr ( actual_value ) errors . exc . actual_value = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr errors . exc . actual_type = type ( actual_value ) . __name__ cls = errors . exc . __class__ if cls not in PATCHED_ERRORS_CLS : def error_str ( self ): s = cls . __str__ ( self ) s = ( s + f \", got { self . actual_value } ( { self . actual_type } )\" if hasattr ( self , \"actual_value\" ) else s ) return s new_cls = type ( cls . __name__ , ( cls ,), { \"msg_template\" : cls . msg_template + \", got {actual_value} ( {actual_type} )\" } if hasattr ( cls , \"msg_template\" ) else { \"__str__\" : error_str , }, ) PATCHED_ERRORS_CLS [ cls ] = new_cls PATCHED_ERRORS_CLS [ new_cls ] = new_cls errors . exc . __class__ = PATCHED_ERRORS_CLS [ cls ] if ( isinstance ( errors . exc , TypeError ) and str ( errors . exc ) . startswith ( \"unexpected keyword argument\" ) and \":\" in errors . exc . args [ 0 ] ): extra_keys = errors . exc . args [ 0 ] . split ( \": \" )[ 1 ] . split ( \", \" ) return [ ErrorWrapper ( TypeError ( \"unexpected keyword argument\" ), ( * path , * errors . loc_tuple ()[: - 1 ], key . strip ( \"'\" )), ) for key in extra_keys ] loc_tuple = errors . loc_tuple () if loc_tuple and loc_tuple [ - 1 ] in special_names : loc_tuple = ( * loc_tuple [: - 1 ], \"[signature]\" ) return [ ErrorWrapper ( errors . exc , ( * path , * loc_tuple ), ) ]","title":"confit.errors"},{"location":"en/reference/registry/","text":"confit.registry VisibleDeprecationWarning Bases: UserWarning Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 Source code in confit/registry.py 346 347 348 349 350 351 352 353 354 355 class VisibleDeprecationWarning ( UserWarning ): \"\"\" Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 \"\"\" # noqa: E501 Registry Bases: Registry A registry that validates the input arguments of the registered functions. Source code in confit/registry.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 class Registry ( catalogue . Registry ): \"\"\" A registry that validates the input arguments of the registered functions. \"\"\" def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace ) def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result ) __init__ ( namespace , entry_points = False ) Initialize the registry. PARAMETER DESCRIPTION namespace The namespace of the registry TYPE: Sequence [ str ] entry_points Should we use entry points to load the registered functions TYPE: bool DEFAULT: False Source code in confit/registry.py 366 367 368 369 370 371 372 373 374 375 376 377 378 def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None register ( name , * , func = None , save_params = None , skip_save_params = (), invoker = None , deprecated = ()) This is a convenience wrapper around catalogue.Registry.register , that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. PARAMETER DESCRIPTION name The name of the function TYPE: str func The function to register TYPE: Optional [ InFunc ] DEFAULT: None save_params Additional parameters to save when the function is called. If falsy, the function parameters are not saved TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None skip_save_params List of parameters to skip when saving the function parameters TYPE: Sequence [ str ] DEFAULT: () invoker An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. TYPE: Optional [ Callable ] DEFAULT: None deprecated The deprecated registry names for the function TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Callable [[ InFunc ], InFunc ] Source code in confit/registry.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register get ( name ) Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. PARAMETER DESCRIPTION name The name of the function TYPE: str RETURNS DESCRIPTION InFunc Source code in confit/registry.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace ) get_available () Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. Source code in confit/registry.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result ) MetaRegistryCollection Bases: type A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. Source code in confit/registry.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 class MetaRegistryCollection ( type ): \"\"\" A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. \"\"\" def __setattr__ ( self , key , value ): assert isinstance ( value , Registry ) value . registry = self super () . __setattr__ ( key , value ) def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls __init__ ( name , bases , dct ) Initialize the registry collection by adding it-self as the registry collection of all registries. PARAMETER DESCRIPTION name bases dct Source code in confit/registry.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls RegistryCollection A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) Source code in confit/registry.py 545 546 547 548 549 550 551 552 553 class RegistryCollection ( metaclass = MetaRegistryCollection ): \"\"\" A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) \"\"\" validate_arguments ( func = None , * , config = None , invoker = None , registry = None ) Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing PARAMETER DESCRIPTION func The function or class to call TYPE: Optional [ Callable ] DEFAULT: None config The validation configuration object TYPE: Dict DEFAULT: None invoker An optional invoker to apply on the validated function TYPE: Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] DEFAULT: None registry The registry to use to resolve the default parameters TYPE: Any DEFAULT: None RETURNS DESCRIPTION Any Source code in confit/registry.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def validate_arguments ( func : Optional [ Callable ] = None , * , config : Dict = None , invoker : Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] = None , registry : Any = None , ) -> Any : \"\"\" Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing Parameters ---------- func: Callable The function or class to call config: Dict The validation configuration object invoker: Optional[Callable] An optional invoker to apply on the validated function registry: Any The registry to use to resolve the default parameters Returns ------- Any \"\"\" if config is None : config = {} config = { ** config , \"arbitrary_types_allowed\" : True } def validate ( _func : Callable ) -> Callable : if isinstance ( _func , type ): _func : type if hasattr ( _func . __init__ , \"__wrapped__\" ): vd = ValidatedFunction ( _func . __init__ . __wrapped__ , config ) else : vd = ValidatedFunction ( _func . __init__ , config ) vd . model . __name__ = _func . __name__ if hasattr ( vd . model , \"model_fields\" ): vd . model . model_fields [ \"self\" ] . default = None else : vd . model . __fields__ [ \"self\" ] . default = None # This function is called by Pydantic when asked to cast # a value (most likely a dict) as a Model (most often during # a function call) old_get_validators = ( _func . __get_validators__ if hasattr ( _func , \"__get_validators__\" ) else None ) old_get_pydantic_core_schema = ( _func . __get_pydantic_core_schema__ if hasattr ( _func , \"__get_pydantic_core_schema__\" ) else None ) def __get_validators__ (): \"\"\" This function is called by Pydantic when asked to cast a value (most likely a dict) as a Model (most often during a function call) Yields ------- Callable The validator function \"\"\" def _validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) if old_get_validators is not None : for validator in old_get_validators (): value = validator ( value ) if isinstance ( value , _func ): return value return _func ( ** value ) yield _validate def __get_pydantic_core_schema__ ( * args , ** kwargs ): from pydantic_core import core_schema def pre_validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) return value def post_validate ( value ): if isinstance ( value , _func ): return value return _func ( ** value ) return core_schema . chain_schema ( [ core_schema . no_info_plain_validator_function ( pre_validate ), * ( ( old_get_pydantic_core_schema ( * args , ** kwargs ),) if old_get_pydantic_core_schema else ( core_schema . no_info_plain_validator_function ( fn ) for fn in old_get_validators () ) if old_get_validators is not None else () ), core_schema . no_info_plain_validator_function ( post_validate ), ] ) # This function is called when we do Model(variable=..., other=...) @wraps ( vd . raw_function , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = True , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __context__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) _func . vd = vd # type: ignore _func . __get_validators__ = __get_validators__ # type: ignore _func . __get_pydantic_core_schema__ = ( __get_pydantic_core_schema__ # type: ignore ) _func . model = vd . model # type: ignore _func . model . type_ = _func # type: ignore _func . __init__ = wrapper_function _func . __init__ . __wrapped__ = vd . raw_function # type: ignore return _func else : vd = ValidatedFunction ( _func , config ) @wraps ( _func , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = False , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __cause__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) wrapper_function . vd = vd # type: ignore wrapper_function . validate = vd . init_model_instance # type: ignore wrapper_function . __wrapped__ = vd . raw_function # type: ignore wrapper_function . model = vd . model # type: ignore return wrapper_function if func : return validate ( func ) else : return validate get_default_registry () Get the default registered registry. RETURNS DESCRIPTION Registry Source code in confit/registry.py 556 557 558 559 560 561 562 563 564 def get_default_registry () -> Any : \"\"\" Get the default registered registry. Returns ------- Registry \"\"\" return _default_registry set_default_registry ( registry ) Set the default registered registry. This is used in Config.resolve() when no registry is provided. PARAMETER DESCRIPTION registry TYPE: CustomRegistry RETURNS DESCRIPTION Registry Source code in confit/registry.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 def set_default_registry ( registry : CustomRegistry ) -> CustomRegistry : \"\"\" Set the default registered registry. This is used in [`Config.resolve()`][confit.config.Config.resolve] when no registry is provided. Parameters ---------- registry: Registry Returns ------- Registry \"\"\" global _default_registry _default_registry = registry return registry","title":"confit.registry"},{"location":"en/reference/utils/","text":"confit.utils","title":"confit.utils"},{"location":"en/reference/utils/collections/","text":"confit.utils.collections join_path ( path ) Join a path into a string and quotes subpaths that contain dots. PARAMETER DESCRIPTION path RETURNS DESCRIPTION str Source code in confit/utils/collections.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def join_path ( path ): \"\"\" Join a path into a string and quotes subpaths that contain dots. Parameters ---------- path: Tuple[Union[int, str]] Returns ------- str \"\"\" return \".\" . join ( repr ( x ) if not isinstance ( x , str ) or split_path ( x . strip ()) != ( x ,) else x for x in path ) split_path ( path ) Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. PARAMETER DESCRIPTION path TYPE: str Source code in confit/utils/collections.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def split_path ( path : str ) -> Tuple [ Union [ int , str ]]: \"\"\" Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. Parameters ---------- path: str Returns ------- \"\"\" offset = 0 result = [] for match in re . finditer ( KEY_PART , str ( path )): assert match . start () == offset , f \"Malformed path: { path !r} in config\" offset = match . end () part = next (( g for g in match . groups () if g is not None )) result . append ( int ( part ) if part . isdigit () else part ) if offset == len ( path ): break return tuple ( result ) flatten_sections ( root ) Flatten a nested dict of dicts into a \"flat\" dict of dict. PARAMETER DESCRIPTION root The root dict to flatten TYPE: Dict [ str , Any ] RETURNS DESCRIPTION Dict [ str , Dict [ str , Any ]] Source code in confit/utils/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def flatten_sections ( root : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Flatten a nested dict of dicts into a \"flat\" dict of dict. Parameters ---------- root: Dict[str, Any] The root dict to flatten Returns ------- Dict[str, Dict[str, Any]] \"\"\" res = collections . defaultdict ( lambda : {}) def rec ( d , path ): res . setdefault ( join_path ( path ), {}) section = {} for k , v in d . items (): if isinstance ( v , dict ): rec ( v , ( * path , k )) else : section [ k ] = v res [ join_path ( path )] . update ( section ) rec ( root , ()) root_level = res . pop ( \"\" , None ) if root_level is not None and len ( root_level ) > 0 : raise Exception ( \"Cannot dump root level config\" , root_level ) return dict ( res )","title":"confit.utils.collections"},{"location":"en/reference/utils/eval/","text":"confit.utils.eval Transformer Bases: NodeTransformer An ast NodeTransformer that only allows a subset of the Python AST. Source code in confit/utils/eval.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Transformer ( ast . NodeTransformer ): \"\"\" An ast NodeTransformer that only allows a subset of the Python AST. \"\"\" ALLOWED_NODE_TYPES = { \"Expression\" , \"Attribute\" , \"Slice\" , \"Subscript\" , \"Index\" , \"Constant\" , \"Tuple\" , \"Name\" , \"Load\" , \"Str\" , \"BinOp\" , \"Num\" , \"List\" , \"Dict\" , \"Set\" , \"Add\" , \"Sub\" , \"Mult\" , \"Div\" , \"FloorDiv\" , \"Mod\" , \"Pow\" , \"LShift\" , \"RShift\" , \"BitOr\" , \"BitXor\" , \"BitAnd\" , \"MatMult\" , \"And\" , \"Or\" , \"Compare\" , \"Eq\" , \"NotEq\" , \"Lt\" , \"LtE\" , \"Gt\" , \"GtE\" , \"Is\" , \"IsNot\" , \"In\" , \"NotIn\" , \"Starred\" , } def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node ) generic_visit ( node ) Checks that the node type is allowed. Source code in confit/utils/eval.py 55 56 57 58 59 60 61 62 63 def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node ) safe_eval ( source , locals_dict = None ) Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. PARAMETER DESCRIPTION source The expression to evaluate TYPE: str locals_dict The local variables to use in the evaluation TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None RETURNS DESCRIPTION Any The result of the evaluation Source code in confit/utils/eval.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def safe_eval ( source : str , locals_dict : Optional [ Dict [ str , Any ]] = None ): \"\"\" Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. Parameters ---------- source: str The expression to evaluate locals_dict: Optional[Dict[str, Any]] The local variables to use in the evaluation Returns ------- Any The result of the evaluation \"\"\" tree = ast . parse ( source , mode = \"eval\" ) transformer . visit ( tree ) clause = compile ( tree , \"<AST>\" , \"eval\" ) result = eval ( clause , { \"__builtins__\" : {}}, locals_dict ) return result","title":"confit.utils.eval"},{"location":"en/reference/utils/random/","text":"confit.utils.random set_seed Source code in confit/utils/random.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class set_seed : def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_val , exc_tb ): set_random_generator_state ( self . state ) __init__ ( seed , cuda = None ) Set seed values for random generators. If used as a context, restore the random state used before entering the context. PARAMETER DESCRIPTION seed Value used as a seed. cuda Saves the cuda random states too TYPE: Optional [ bool ] DEFAULT: None Source code in confit/utils/random.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass get_random_generator_state ( cuda = None ) Get the torch , numpy and random random generator state. PARAMETER DESCRIPTION cuda Saves the cuda random states too DEFAULT: None RETURNS DESCRIPTION RandomGeneratorState Source code in confit/utils/random.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def get_random_generator_state ( cuda = None ): \"\"\" Get the `torch`, `numpy` and `random` random generator state. Parameters ---------- cuda: bool Saves the cuda random states too Returns ------- RandomGeneratorState \"\"\" torch_state = torch_cuda_state = numpy_state = None random_state = random . getstate () try : import torch torch_state = torch . random . get_rng_state () if cuda or ( cuda is None and torch . cuda . is_available ()): # pragma: no cover torch_cuda_state = torch . cuda . get_rng_state_all () except ImportError : # pragma: no cover pass try : import numpy numpy_state = numpy . random . get_state () except ImportError : # pragma: no cover pass return RandomGeneratorState ( random_state , torch_state , numpy_state , torch_cuda_state , ) set_random_generator_state ( state ) Set the torch , numpy and random random generator state. PARAMETER DESCRIPTION state Source code in confit/utils/random.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_random_generator_state ( state ): \"\"\" Set the `torch`, `numpy` and `random` random generator state. Parameters ---------- state: RandomGeneratorState \"\"\" random . setstate ( state . random ) if state . torch is not None : import torch torch . random . set_rng_state ( state . torch ) if ( state . torch_cuda is not None and torch . cuda . is_available () and len ( state . torch_cuda ) == torch . cuda . device_count () ): # pragma: no cover torch . cuda . set_rng_state_all ( state . torch_cuda ) if state . numpy is not None : import numpy numpy . random . set_state ( state . numpy )","title":"confit.utils.random"},{"location":"en/reference/utils/settings/","text":"confit.utils.settings","title":"confit.utils.settings"},{"location":"en/reference/utils/xjson/","text":"confit.utils.xjson Reference A path reference to a value in the configuration. Source code in confit/utils/xjson.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Reference : \"\"\" A path reference to a value in the configuration. \"\"\" def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value def __repr__ ( self ): return f \"$ {{ { self . value } }} \" def __str__ ( self ): return self . __repr__ () def __eq__ ( self , other ): return self . value == other . value __init__ ( value ) PARAMETER DESCRIPTION value The path to the value in the configuration. TYPE: str Source code in confit/utils/xjson.py 13 14 15 16 17 18 19 20 def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value XJsonTransformer Bases: Transformer A Lark transformer to parse extended JSON. Source code in confit/utils/xjson.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class XJsonTransformer ( Transformer ): \"\"\" A Lark transformer to parse extended JSON. \"\"\" def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n ) def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n ) def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ]) list = list tuple = tuple pair = tuple dict = dict def null ( self , _ ): \"\"\"Parse null\"\"\" return None def true ( self , _ ): \"\"\"Parse true\"\"\" return True def false ( self , _ ): \"\"\"Parse false\"\"\" return False def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" ) def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" ) def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" ) __init__ ( input_string ) PARAMETER DESCRIPTION input_string The input string to parse. TYPE: str Source code in confit/utils/xjson.py 88 89 90 91 92 93 94 95 96 def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string string ( s ) Parse string Source code in confit/utils/xjson.py 98 99 100 101 102 def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s float ( n ) Parse number Source code in confit/utils/xjson.py 104 105 106 107 def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n ) int ( n ) Parse number Source code in confit/utils/xjson.py 109 110 111 112 def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n ) reference ( tree ) Parse reference Source code in confit/utils/xjson.py 114 115 116 117 def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ]) null ( _ ) Parse null Source code in confit/utils/xjson.py 124 125 126 def null ( self , _ ): \"\"\"Parse null\"\"\" return None true ( _ ) Parse true Source code in confit/utils/xjson.py 128 129 130 def true ( self , _ ): \"\"\"Parse true\"\"\" return True false ( _ ) Parse false Source code in confit/utils/xjson.py 132 133 134 def false ( self , _ ): \"\"\"Parse false\"\"\" return False plus_inf ( _ ) Parse infinity Source code in confit/utils/xjson.py 136 137 138 def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" ) minus_inf ( _ ) Parse -infinity Source code in confit/utils/xjson.py 140 141 142 def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" ) nan ( _ ) Parse nan Source code in confit/utils/xjson.py 144 145 146 def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" ) loads ( s ) Load an extended JSON string into a python object. Takes care of detecting references and tuples PARAMETER DESCRIPTION s TYPE: str RETURNS DESCRIPTION Any Source code in confit/utils/xjson.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def loads ( s : str ): \"\"\" Load an extended JSON string into a python object. Takes care of detecting references and tuples Parameters ---------- s: str Returns ------- Any \"\"\" try : return XJsonTransformer ( s ) . transform ( _json_parser . parse ( s )) except Exception : # Fail if we suspect that it is a malformed object # (e.g. has ', \", {, }, [, ] in it) if set ( s ) & set ( \",' \\\" {} []$\" ): raise MalformedValueError ( s ) return s dumps ( o ) Dump a python object into an extended JSON string. Takes care of serializing references and tuples PARAMETER DESCRIPTION o TYPE: Any RETURNS DESCRIPTION str Source code in confit/utils/xjson.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def dumps ( o : Any ): \"\"\" Dump a python object into an extended JSON string. Takes care of serializing references and tuples Parameters ---------- o: Any Returns ------- str \"\"\" return \"\" . join ( _make_iterencode ()( o ))","title":"confit.utils.xjson"},{"location":"fr/alternatives/","text":"Alternatives & Comparaison Dans cette section, nous explorons ce qui a inspir\u00e9 Confit et les diff\u00e9rences notables avec d'autres packages Python. Confection Confection (issu de la librairie Thinc ) est un autre framework de configuration dont Confit s'inspire largement. Confit et Confection permettent tous deux le chargement et l'exportation des donn\u00e9es de configuration \u00e0 partir de/vers des cha\u00eenes de caract\u00e8res ou des fichiers de configuration, ainsi que interpolation sur des types basiques et l'instanciation de classes personnalis\u00e9es \u00e0 partir d'un registre. Cependant, Confit va plus loin en permettant l'\u00e9valuation d'expressions arbitraires, l'interpolation post-r\u00e9solution et des fonctionnalit\u00e9s d'exportation telles que la sauvegarde dans des cha\u00eenes de caract\u00e8res ou des fichiers de configuration, la s\u00e9rialisation d'objets de type JSON, les classes personnalis\u00e9es et la s\u00e9rialisation de r\u00e9f\u00e9rences. Confit offre \u00e9galement une API pour d\u00e9finir des interfaces en ligne de commande en passant soit un fichier de configuration en argument, soit en passant des arguments (ou des substitutions), tout en b\u00e9n\u00e9ficiant de la validation des arguments et du transtypage. Gin-config Gin Config est un syst\u00e8me de configuration flexible con\u00e7u pour la recherche en apprentissage automatique. Comme Confit et Confection, gin-config permet l'interpolation sur des types basiques et l'instanciation de classes personnalis\u00e9es et offre un support pour les interfaces en ligne de commande. Cependant, il ne fournit pas de fonctionnalit\u00e9s d'exportation d'objets de configuration comme le fait Confit ou de validation des param\u00e8tres. Typer Typer est une biblioth\u00e8que pour d\u00e9finir facilement interfaces en ligne de commande (CLI). Bien que Typer offre une excellent prise en charge pour les CLI et une validation basique des arguments, il ne dispose pas de fonctionnalit\u00e9s li\u00e9es aux fichiers de configuration telles que le chargement, l'exportation ou la validation des param\u00e8tres comme le fait Confit. Confit s'appuie sur Typer pour ses fonctionnalit\u00e9s CLI mais prend \u00e9galement en charge les arguments de fichiers de configuration et l'instanciation de classes \u00e0 partir d'un registre, qui ne sont pas disponibles dans Typer. Cependant, si votre objectif principal est de construire une interface en ligne de commande robuste, Typer est une solide alternative. Pydantic-CLI Pydantic-CLI est une autre biblioth\u00e8que CLI qui combine Pydantic et argparse pour cr\u00e9er des interfaces de ligne de commande. Pydantic-CLI fournit un support CLI et une validation des arguments, similaire \u00e0 Typer. Cependant, elle n'a pas de fonctionnalit\u00e9s li\u00e9es aux fichiers de configuration comme Confit, et ne permet pas non plus d'instancier des classes personnalis\u00e9es. Tableau de comparaison Chargement Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Chargement \u00e0 partir du fichier str/config Interpolation basique NA NA \u00c9valuation d'expressions arbitraires NA NA Interpolation post-r\u00e9solution NA NA Instanciation de classe personnalis\u00e9e NA NA Export Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Export vers string / fichier cfg S\u00e9rialisation d'objets de type JSON NA NA NA S\u00e9rialisation des classes personnalis\u00e9es NA NA NA S\u00e9rialisation des r\u00e9f\u00e9rences NA NA NA Interface en ligne de commande (CLI) Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Utilisation en CLI Options courtes en CLI NA Validation des arguments NA Option de fichier de configuration NA Validation des param\u00e8tres Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Support de la validation des param\u00e8tres Casting automatique NA Depuis un appel fonction/classe Python NA","title":"Alternatives & Comparaison"},{"location":"fr/alternatives/#alternatives-comparaison","text":"Dans cette section, nous explorons ce qui a inspir\u00e9 Confit et les diff\u00e9rences notables avec d'autres packages Python.","title":"Alternatives &amp; Comparaison"},{"location":"fr/alternatives/#confection","text":"Confection (issu de la librairie Thinc ) est un autre framework de configuration dont Confit s'inspire largement. Confit et Confection permettent tous deux le chargement et l'exportation des donn\u00e9es de configuration \u00e0 partir de/vers des cha\u00eenes de caract\u00e8res ou des fichiers de configuration, ainsi que interpolation sur des types basiques et l'instanciation de classes personnalis\u00e9es \u00e0 partir d'un registre. Cependant, Confit va plus loin en permettant l'\u00e9valuation d'expressions arbitraires, l'interpolation post-r\u00e9solution et des fonctionnalit\u00e9s d'exportation telles que la sauvegarde dans des cha\u00eenes de caract\u00e8res ou des fichiers de configuration, la s\u00e9rialisation d'objets de type JSON, les classes personnalis\u00e9es et la s\u00e9rialisation de r\u00e9f\u00e9rences. Confit offre \u00e9galement une API pour d\u00e9finir des interfaces en ligne de commande en passant soit un fichier de configuration en argument, soit en passant des arguments (ou des substitutions), tout en b\u00e9n\u00e9ficiant de la validation des arguments et du transtypage.","title":"Confection"},{"location":"fr/alternatives/#gin-config","text":"Gin Config est un syst\u00e8me de configuration flexible con\u00e7u pour la recherche en apprentissage automatique. Comme Confit et Confection, gin-config permet l'interpolation sur des types basiques et l'instanciation de classes personnalis\u00e9es et offre un support pour les interfaces en ligne de commande. Cependant, il ne fournit pas de fonctionnalit\u00e9s d'exportation d'objets de configuration comme le fait Confit ou de validation des param\u00e8tres.","title":"Gin-config"},{"location":"fr/alternatives/#typer","text":"Typer est une biblioth\u00e8que pour d\u00e9finir facilement interfaces en ligne de commande (CLI). Bien que Typer offre une excellent prise en charge pour les CLI et une validation basique des arguments, il ne dispose pas de fonctionnalit\u00e9s li\u00e9es aux fichiers de configuration telles que le chargement, l'exportation ou la validation des param\u00e8tres comme le fait Confit. Confit s'appuie sur Typer pour ses fonctionnalit\u00e9s CLI mais prend \u00e9galement en charge les arguments de fichiers de configuration et l'instanciation de classes \u00e0 partir d'un registre, qui ne sont pas disponibles dans Typer. Cependant, si votre objectif principal est de construire une interface en ligne de commande robuste, Typer est une solide alternative.","title":"Typer"},{"location":"fr/alternatives/#pydantic-cli","text":"Pydantic-CLI est une autre biblioth\u00e8que CLI qui combine Pydantic et argparse pour cr\u00e9er des interfaces de ligne de commande. Pydantic-CLI fournit un support CLI et une validation des arguments, similaire \u00e0 Typer. Cependant, elle n'a pas de fonctionnalit\u00e9s li\u00e9es aux fichiers de configuration comme Confit, et ne permet pas non plus d'instancier des classes personnalis\u00e9es.","title":"Pydantic-CLI"},{"location":"fr/alternatives/#tableau-de-comparaison","text":"","title":"Tableau de comparaison"},{"location":"fr/alternatives/#chargement","text":"Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Chargement \u00e0 partir du fichier str/config Interpolation basique NA NA \u00c9valuation d'expressions arbitraires NA NA Interpolation post-r\u00e9solution NA NA Instanciation de classe personnalis\u00e9e NA NA","title":"Chargement"},{"location":"fr/alternatives/#export","text":"Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Export vers string / fichier cfg S\u00e9rialisation d'objets de type JSON NA NA NA S\u00e9rialisation des classes personnalis\u00e9es NA NA NA S\u00e9rialisation des r\u00e9f\u00e9rences NA NA NA","title":"Export"},{"location":"fr/alternatives/#interface-en-ligne-de-commande-cli","text":"Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Utilisation en CLI Options courtes en CLI NA Validation des arguments NA Option de fichier de configuration NA","title":"Interface en ligne de commande (CLI)"},{"location":"fr/alternatives/#validation-des-parametres","text":"Fonctionnalit\u00e9 Confit Confection Gin Typer Pydantic-cli Support de la validation des param\u00e8tres Casting automatique NA Depuis un appel fonction/classe Python NA","title":"Validation des param\u00e8tres"},{"location":"fr/getting-started/","text":"Mise en route Installation Installez la biblioth\u00e8que avec pip : $ pip install confit Un exemple simple Confit n'abstrait que le code standard li\u00e9 \u00e0 la configuration et laisse le reste de votre code inchang\u00e9. Voici un exemple : script.py import datetime + from confit import Cli, Registry, RegistryCollection + app = Cli(pretty_exceptions_show_locals=False) + class RegistryCollection(: + factory = Registry((\"test_cli\", \"factory\"), entry_points=True) + @registry.factory.register(\"submodel\") class SubModel: # Le typage est facultatif mais recommand\u00e9 pour b\u00e9n\u00e9ficier du transtypage des arguments def __init__(self, value: float, desc: str = \"\"): self.value = value self.desc = desc + @registry.factory.register(\"bigmodel\") class BigModel: def __init__(self, date: datetime.date, submodel: SubModel): self.date = date self.submodel = submodel + @app.command(name=\"script\", registry=registry) def func(modelA: BigModel, modelB: BigModel, other: int, seed: int): assert modelA.submodel is modelB.submodel assert modelA.date == datetime.date(2010, 10, 10) print(\"Autre :\", other) + if __name__ == \"__main__\": + app() Cr\u00e9ez un nouveau fichier de configuration config.cfg # Sections CLI [script] modelA = ${modelA} modelB = ${modelB} # Param\u00e8tres communs CLI [modelA] @factory = \"bigmodel\" date = \"2010-10-10\" [modelA.submodel] @factory = \"submodel\" value = 12 [modelB] date = \"2003-04-05\" submodel = ${modelA.submodel} et ex\u00e9cutez la commande suivante depuis le terminal $ python script.py --config config.cfg --seed 42 Nom Pour utiliser le nom de votre chemin de configuration (par exemple config-expe-2 si le fichier de configuration est nomm\u00e9 config-expe-2.cfg dans * la configuration (apr\u00e8s r\u00e9solution), mentionnez simplement name = None sous la section dont le titre a \u00e9t\u00e9 fourni \u00e0 @app.command(name=<section-title>) Configurations multiples Vous pouvez passer plusieurs fichiers de configuration en r\u00e9p\u00e9tant l'option --config . La configuration sera fusionn\u00e9e dans l'ordre. Vous pouvez toujours appeler la m\u00e9thode function depuis votre code, mais vous b\u00e9n\u00e9ficiez maintenant \u00e9galement de la validation des arguments ! from script import func , BigModel , SubModel # Pour initialiser la graine avant de cr\u00e9er les mod\u00e8les from confit.utils.random import set_seed seed = 42 set_seed ( seed ) submodel = SubModel ( value = 12 ) # BigModel convertira les cha\u00eenes de caract\u00e8res de date en objets datetime.date modelA = BigModel ( date = \"2003-02-01\" , submodel = submodel ) modelB = BigModel ( date = \"2003-04-05\" , submodel = submodel ) func ( modelA = modelA , modelB = modelA , seed = seed , )","title":"Mise en route"},{"location":"fr/getting-started/#mise-en-route","text":"","title":"Mise en route"},{"location":"fr/getting-started/#installation","text":"Installez la biblioth\u00e8que avec pip : $ pip install confit","title":"Installation"},{"location":"fr/getting-started/#un-exemple-simple","text":"Confit n'abstrait que le code standard li\u00e9 \u00e0 la configuration et laisse le reste de votre code inchang\u00e9. Voici un exemple : script.py import datetime + from confit import Cli, Registry, RegistryCollection + app = Cli(pretty_exceptions_show_locals=False) + class RegistryCollection(: + factory = Registry((\"test_cli\", \"factory\"), entry_points=True) + @registry.factory.register(\"submodel\") class SubModel: # Le typage est facultatif mais recommand\u00e9 pour b\u00e9n\u00e9ficier du transtypage des arguments def __init__(self, value: float, desc: str = \"\"): self.value = value self.desc = desc + @registry.factory.register(\"bigmodel\") class BigModel: def __init__(self, date: datetime.date, submodel: SubModel): self.date = date self.submodel = submodel + @app.command(name=\"script\", registry=registry) def func(modelA: BigModel, modelB: BigModel, other: int, seed: int): assert modelA.submodel is modelB.submodel assert modelA.date == datetime.date(2010, 10, 10) print(\"Autre :\", other) + if __name__ == \"__main__\": + app() Cr\u00e9ez un nouveau fichier de configuration config.cfg # Sections CLI [script] modelA = ${modelA} modelB = ${modelB} # Param\u00e8tres communs CLI [modelA] @factory = \"bigmodel\" date = \"2010-10-10\" [modelA.submodel] @factory = \"submodel\" value = 12 [modelB] date = \"2003-04-05\" submodel = ${modelA.submodel} et ex\u00e9cutez la commande suivante depuis le terminal $ python script.py --config config.cfg --seed 42 Nom Pour utiliser le nom de votre chemin de configuration (par exemple config-expe-2 si le fichier de configuration est nomm\u00e9 config-expe-2.cfg dans * la configuration (apr\u00e8s r\u00e9solution), mentionnez simplement name = None sous la section dont le titre a \u00e9t\u00e9 fourni \u00e0 @app.command(name=<section-title>) Configurations multiples Vous pouvez passer plusieurs fichiers de configuration en r\u00e9p\u00e9tant l'option --config . La configuration sera fusionn\u00e9e dans l'ordre. Vous pouvez toujours appeler la m\u00e9thode function depuis votre code, mais vous b\u00e9n\u00e9ficiez maintenant \u00e9galement de la validation des arguments ! from script import func , BigModel , SubModel # Pour initialiser la graine avant de cr\u00e9er les mod\u00e8les from confit.utils.random import set_seed seed = 42 set_seed ( seed ) submodel = SubModel ( value = 12 ) # BigModel convertira les cha\u00eenes de caract\u00e8res de date en objets datetime.date modelA = BigModel ( date = \"2003-02-01\" , submodel = submodel ) modelB = BigModel ( date = \"2003-04-05\" , submodel = submodel ) func ( modelA = modelA , modelB = modelA , seed = seed , )","title":"Un exemple simple"},{"location":"fr/","text":"Confit Confit est un syst\u00e8me de configuration complet et facile d'utilisation qui vise \u00e0 am\u00e9liorer la reproductibilit\u00e9 des exp\u00e9riences en s'appuyant sur le syst\u00e8me de typage Python, sur des fichiers de configuration minimaux et avec une interface en ligne de commande. Architecture Les trois piliers de ce syst\u00e8me de configuration sont le registre catalogue , le syst\u00e8me de validation Pydantic et la biblioth\u00e8que de CLI typer . Registre Le registre catalogue stocke les diff\u00e9rents objects (classes ou fonctions) qui peuvent \u00eatre compos\u00e9s ensemble pour executer votre programme. Une fois enregistr\u00e9s, avec le d\u00e9corateur registry.factory.register ces objets sont accessibles via les entry-points et peuvent \u00eatre utilis\u00e9s dans le syst\u00e8me de configuration. Pour commencer, vous pouvez cr\u00e9er un registre \"factory\" comme suit: from confit import Registry , RegistryCollection class registry ( RegistryCollection ): factory = Registry (( \"my_library\" , \"factory\" ), entry_points = True ) \u00c0 quoi cela sert-il ? Avec ce registre, vous pouvez enregistrer une fonction ou une classe : @registry . factory . register ( \"my-function\" ) def my_function ( value = 10 ): print ( f \"The value is { value } !\" ) Maintenant, vous pouvez r\u00e9cup\u00e9rer dynamiquement la fonction depuis n'importe o\u00f9 : func = registry . factory . get ( \"my-function\" ) func () # Out: \"The value is 10!\" func ( value = 42 ) # Out: \"The value is 42!\" Syst\u00e8me de typage Le d\u00e9corateur Pydantic validate_arguments am\u00e9liore une fonction pour analyser et valider automatiquement ses arguments \u00e0 chaque appel, en utilisant le syst\u00e8me de validation bas\u00e9 sur le typage Pydantic. Par exemple, les cha\u00eenes de caract\u00e8res peuvent \u00eatre automatiquement converties en objets Path, ou en objets datetime ou en nombres, en fonction de l'annotation de type de l'argument. Combin\u00e9 avec notre syst\u00e8me de configuration, les dictionnaires pass\u00e9s en arguments \u00e0 une fonction d\u00e9cor\u00e9e peuvent \u00eatre \"cast\u00e9s\" en classes instanci\u00e9es si ces classes \u00e9taient elles-m\u00eames d\u00e9cor\u00e9es. CLI Documentation en cours L'objet Config L'objet de configuration, la classe Config , est un dictionnaire augment\u00e9 qui peut \u00eatre utilis\u00e9 pour lire et \u00e9crire des fichiers cfg , interpoler des variables et instancier des composants via le registre avec des cl\u00e9s sp\u00e9ciales @factory . Un fichier cfg peut \u00eatre utilis\u00e9 directement comme entr\u00e9e pour une fonction d\u00e9cor\u00e9e en CLI. Nous montrerons ci-dessous des exemples partiels de complexit\u00e9 croissante. Voir ici pour un exemple complet. Instanciation d'un objet script.py @registry . factory . register ( \"my-class\" ) class MyClass : def __init__ ( self , value1 : int , value2 : float ): self . value1 = value1 self . value2 = value2 config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = 2.5 Ici, Confit va : Analyser la configuration R\u00e9cup\u00e9rer la classe cible \u00e0 partir du registre Valider les param\u00e8tres si n\u00e9cessaire (dans ce cas, value1 est typ\u00e9 en tant qu'entier, il sera donc converti en entier en d\u00e9finissant value1=1 ) Instancier la classe en utilisant les param\u00e8tres valid\u00e9s Interpolation des valeurs Lorsque plusieurs sections de la configuration doivent acc\u00e9der \u00e0 la m\u00eame valeur, vous pouvez utiliser une r\u00e9f\u00e9rence avec la syntaxe ${<section.value>} : config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Ici, value2 sera d\u00e9fini \u00e0 10, comme value3 . Interpolation avanc\u00e9e Vous pouvez m\u00eame passer des objets instanci\u00e9s ! Supposons que nous ayons une classe enregistr\u00e9e myOtherClass attendant une instance de MyClass en entr\u00e9e. Vous pourriez utiliser la configuration suivante : config.cfg [func] @factory = \"my-other-class\" obj = ${myclass} [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Enfin, vous pouvez vouloir acc\u00e9der \u00e0 certains attributs des classes Python qui sont disponibles apr\u00e8s l'instanciation, mais pas pr\u00e9sents dans le fichier de configuration. Par exemple, modifions notre classe MyClass : script.py @registry.factory.register(\"my-class\") class MyClass: def __init__(self, value1: int, value2: float): self.value1 = value1 self.value2 = value2 + self.hidden_value = 99 Pour acc\u00e9der \u00e0 ces valeurs directement dans le fichier de configuration, utilisez la syntaxe ${<obj:attribut>} (remarquez les deux points au lieu du point ) config.cfg [objet] @factory = \"ma-classe valeur1 = 1.1 valeur2 = 2.5 [autres_valeurs] valeur3 = ${objet:valeur_cach\u00e9e}","title":"Confit"},{"location":"fr/#confit","text":"Confit est un syst\u00e8me de configuration complet et facile d'utilisation qui vise \u00e0 am\u00e9liorer la reproductibilit\u00e9 des exp\u00e9riences en s'appuyant sur le syst\u00e8me de typage Python, sur des fichiers de configuration minimaux et avec une interface en ligne de commande.","title":"Confit"},{"location":"fr/#architecture","text":"Les trois piliers de ce syst\u00e8me de configuration sont le registre catalogue , le syst\u00e8me de validation Pydantic et la biblioth\u00e8que de CLI typer .","title":"Architecture"},{"location":"fr/#registre","text":"Le registre catalogue stocke les diff\u00e9rents objects (classes ou fonctions) qui peuvent \u00eatre compos\u00e9s ensemble pour executer votre programme. Une fois enregistr\u00e9s, avec le d\u00e9corateur registry.factory.register ces objets sont accessibles via les entry-points et peuvent \u00eatre utilis\u00e9s dans le syst\u00e8me de configuration. Pour commencer, vous pouvez cr\u00e9er un registre \"factory\" comme suit: from confit import Registry , RegistryCollection class registry ( RegistryCollection ): factory = Registry (( \"my_library\" , \"factory\" ), entry_points = True ) \u00c0 quoi cela sert-il ? Avec ce registre, vous pouvez enregistrer une fonction ou une classe : @registry . factory . register ( \"my-function\" ) def my_function ( value = 10 ): print ( f \"The value is { value } !\" ) Maintenant, vous pouvez r\u00e9cup\u00e9rer dynamiquement la fonction depuis n'importe o\u00f9 : func = registry . factory . get ( \"my-function\" ) func () # Out: \"The value is 10!\" func ( value = 42 ) # Out: \"The value is 42!\"","title":"Registre"},{"location":"fr/#systeme-de-typage","text":"Le d\u00e9corateur Pydantic validate_arguments am\u00e9liore une fonction pour analyser et valider automatiquement ses arguments \u00e0 chaque appel, en utilisant le syst\u00e8me de validation bas\u00e9 sur le typage Pydantic. Par exemple, les cha\u00eenes de caract\u00e8res peuvent \u00eatre automatiquement converties en objets Path, ou en objets datetime ou en nombres, en fonction de l'annotation de type de l'argument. Combin\u00e9 avec notre syst\u00e8me de configuration, les dictionnaires pass\u00e9s en arguments \u00e0 une fonction d\u00e9cor\u00e9e peuvent \u00eatre \"cast\u00e9s\" en classes instanci\u00e9es si ces classes \u00e9taient elles-m\u00eames d\u00e9cor\u00e9es.","title":"Syst\u00e8me de typage"},{"location":"fr/#cli","text":"Documentation en cours","title":"CLI"},{"location":"fr/#lobjet-config","text":"L'objet de configuration, la classe Config , est un dictionnaire augment\u00e9 qui peut \u00eatre utilis\u00e9 pour lire et \u00e9crire des fichiers cfg , interpoler des variables et instancier des composants via le registre avec des cl\u00e9s sp\u00e9ciales @factory . Un fichier cfg peut \u00eatre utilis\u00e9 directement comme entr\u00e9e pour une fonction d\u00e9cor\u00e9e en CLI. Nous montrerons ci-dessous des exemples partiels de complexit\u00e9 croissante. Voir ici pour un exemple complet.","title":"L'objet Config"},{"location":"fr/#instanciation-dun-objet","text":"script.py @registry . factory . register ( \"my-class\" ) class MyClass : def __init__ ( self , value1 : int , value2 : float ): self . value1 = value1 self . value2 = value2 config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = 2.5 Ici, Confit va : Analyser la configuration R\u00e9cup\u00e9rer la classe cible \u00e0 partir du registre Valider les param\u00e8tres si n\u00e9cessaire (dans ce cas, value1 est typ\u00e9 en tant qu'entier, il sera donc converti en entier en d\u00e9finissant value1=1 ) Instancier la classe en utilisant les param\u00e8tres valid\u00e9s","title":"Instanciation d'un objet"},{"location":"fr/#interpolation-des-valeurs","text":"Lorsque plusieurs sections de la configuration doivent acc\u00e9der \u00e0 la m\u00eame valeur, vous pouvez utiliser une r\u00e9f\u00e9rence avec la syntaxe ${<section.value>} : config.cfg [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Ici, value2 sera d\u00e9fini \u00e0 10, comme value3 .","title":"Interpolation des valeurs"},{"location":"fr/#interpolation-avancee","text":"Vous pouvez m\u00eame passer des objets instanci\u00e9s ! Supposons que nous ayons une classe enregistr\u00e9e myOtherClass attendant une instance de MyClass en entr\u00e9e. Vous pourriez utiliser la configuration suivante : config.cfg [func] @factory = \"my-other-class\" obj = ${myclass} [myclass] @factory = \"my-class\" value1 = 1.1 value2 = ${other_values.value3} [other_values] value3 = 10 Enfin, vous pouvez vouloir acc\u00e9der \u00e0 certains attributs des classes Python qui sont disponibles apr\u00e8s l'instanciation, mais pas pr\u00e9sents dans le fichier de configuration. Par exemple, modifions notre classe MyClass : script.py @registry.factory.register(\"my-class\") class MyClass: def __init__(self, value1: int, value2: float): self.value1 = value1 self.value2 = value2 + self.hidden_value = 99 Pour acc\u00e9der \u00e0 ces valeurs directement dans le fichier de configuration, utilisez la syntaxe ${<obj:attribut>} (remarquez les deux points au lieu du point ) config.cfg [objet] @factory = \"ma-classe valeur1 = 1.1 valeur2 = 2.5 [autres_valeurs] valeur3 = ${objet:valeur_cach\u00e9e}","title":"Interpolation avanc\u00e9e"},{"location":"fr/reference/","text":"confit","title":"confit"},{"location":"fr/reference/autoreload/","text":"confit.autoreload Plugin to help IPython's autoreload magic reload functions wrapped with confit.","title":"confit.autoreload"},{"location":"fr/reference/cli/","text":"confit.cli Cli Bases: Typer Custom Typer object that: validates a command parameters before executing it accepts a configuration file describing the parameters automatically instantiates parameters given a dictionary when type hinted Source code in confit/cli.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class Cli ( Typer ): \"\"\" Custom Typer object that: - validates a command parameters before executing it - accepts a configuration file describing the parameters - automatically instantiates parameters given a dictionary when type hinted \"\"\" def command ( # noqa self , name , * , cls : Optional [ Type [ TyperCommand ]] = None , context_settings : Optional [ Dict [ Any , Any ]] = None , help : Optional [ str ] = None , epilog : Optional [ str ] = None , short_help : Optional [ str ] = None , options_metavar : str = \"[OPTIONS]\" , add_help_option : bool = True , no_args_is_help : bool = False , hidden : bool = False , deprecated : bool = False , # Rich settings rich_help_panel : Union [ str , None ] = Default ( None ), registry : Any = None , ) -> Callable [[ CommandFunctionType ], CommandFunctionType ]: typer_command = super () . command ( name = name , cls = cls , help = help , epilog = epilog , short_help = short_help , options_metavar = options_metavar , add_help_option = add_help_option , no_args_is_help = no_args_is_help , hidden = hidden , deprecated = deprecated , rich_help_panel = rich_help_panel , context_settings = { ** ( context_settings or {}), \"ignore_unknown_options\" : True , \"allow_extra_args\" : True , }, ) def wrapper ( fn ): validated = validate_arguments ( fn ) @typer_command def command ( ctx : Context , config : Optional [ List [ Path ]] = None ): config_path = config has_meta = _fn_has_meta ( fn ) if config_path : config , name_from_file = merge_from_disk ( config_path ) else : config = Config ({ name : {}}) model_fields = ( validated . model . model_fields if hasattr ( validated . model , \"model_fields\" ) else validated . model . __fields__ ) for k , v in parse_overrides ( ctx . args ) . items (): if \".\" not in k : parts = ( name , k ) else : parts = k . split ( \".\" ) if parts [ 0 ] in model_fields and parts [ 0 ] not in config : parts = ( name , * parts ) current = config if parts [ 0 ] not in current : raise Exception ( f \" { k } does not match any existing section in config\" ) for part in parts [: - 1 ]: current = current . setdefault ( part , Config ()) current [ parts [ - 1 ]] = v try : resolved_config = config . resolve ( registry = registry ) default_seed = model_fields . get ( \"seed\" ) if default_seed is not None : default_seed = default_seed . get_default () seed = config . get ( name , {}) . get ( \"seed\" , default_seed ) if seed is not None : set_seed ( seed ) if has_meta : config_meta = dict ( config_path = config_path , resolved_config = resolved_config , unresolved_config = config , ) return validated ( ** resolved_config . get ( name , {}), config_meta = config_meta , ) else : return validated ( ** resolved_config . get ( name , {})) except ( LegacyValidationError , ConfitValidationError ) as e : e . raw_errors = patch_errors ( e . raw_errors , ( name ,), ) if is_debug () or e . __cause__ is not None : raise e try : import rich console = rich . console . Console ( stderr = True ) console . print ( \"Validation error:\" , style = \"red\" , end = \" \" ) console . print ( str ( e )) except ImportError : # pragma: no cover print ( \"Validation error:\" , file = sys . stderr , end = \" \" ) print ( str ( e ), file = sys . stderr ) sys . exit ( 1 ) return validated return wrapper parse_overrides ( args ) Parse the overrides from the command line into a dictionary of key-value pairs. PARAMETER DESCRIPTION args The arguments to parse TYPE: List [ str ] RETURNS DESCRIPTION Dict [ str , Any ] The parsed overrides as a dictionary Source code in confit/cli.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def parse_overrides ( args : List [ str ]) -> Dict [ str , Any ]: \"\"\" Parse the overrides from the command line into a dictionary of key-value pairs. Parameters ---------- args: List[str] The arguments to parse Returns ------- Dict[str, Any] The parsed overrides as a dictionary \"\"\" result = {} while args : opt = args . pop ( 0 ) err = f \"Invalid config override ' { opt } '\" if opt . startswith ( \"--\" ): # new argument opt = opt . replace ( \"--\" , \"\" ) if \"=\" in opt : # we have --opt=value opt , value = opt . split ( \"=\" , 1 ) else : if not args or args [ 0 ] . startswith ( \"--\" ): # flag with no value value = \"true\" else : value = args . pop ( 0 ) opt = opt . replace ( \"-\" , \"_\" ) result [ opt ] = loads ( value ) else : secho ( f \" { err } : doesn't support shorthands\" , fg = colors . RED ) exit ( 1 ) return result","title":"confit.cli"},{"location":"fr/reference/config/","text":"confit.config Config Bases: dict The configuration system consists of a supercharged dict, the Config class, that can be used to read and write to cfg files, interpolate variables and instantiate components through the registry with some special @factory keys. A cfg file can be used directly as an input to a CLI-decorated function. Source code in confit/config.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Config ( dict ): \"\"\" The configuration system consists of a supercharged dict, the `Config` class, that can be used to read and write to `cfg` files, interpolate variables and instantiate components through the registry with some special `@factory` keys. A cfg file can be used directly as an input to a CLI-decorated function. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs ) @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry ) def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s ) def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self ) def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue () def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ()) def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy @classmethod def _store_resolved ( cls , resolved : Any , config : Dict [ str , Any ]): \"\"\" Adds a resolved object to the RESOLVED_TO_CONFIG dict for later retrieval during serialization ([`.serialize`][confit.config.Config.serialize]) Parameters ---------- resolved: Any config: Config \"\"\" try : RESOLVED_TO_CONFIG [ resolved ] = config except TypeError : pass __init__ ( * args , ** kwargs ) A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. PARAMETER DESCRIPTION args TYPE: Any DEFAULT: () kwargs TYPE: Any DEFAULT: {} Source code in confit/config.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , * args : Any , ** kwargs : Any ): \"\"\" A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time. Parameters ---------- args: Any kwargs: Any \"\"\" if len ( args ) == 1 and isinstance ( args [ 0 ], dict ): assert len ( kwargs ) == 0 kwargs = args [ 0 ] super () . __init__ ( ** kwargs ) from_str ( s , resolve = False , registry = None ) classmethod Load a config object from a config string PARAMETER DESCRIPTION s The cfg config string TYPE: str resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @classmethod def from_str ( cls , s : str , resolve : bool = False , registry : Any = None ) -> Any : \"\"\" Load a config object from a config string Parameters ---------- s: Union[str, Path] The cfg config string resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" parser = ConfigParser () parser . optionxform = str parser . read_string ( s ) config = Config () for section in parser . sections (): parts = split_path ( section ) current = config for part in parts : if part not in current : current [ part ] = current = Config () else : current = current [ part ] current . clear () errors = [] for k , v in parser . items ( section ): path = split_path ( k ) for part in path [: - 1 ]: if part not in current : current [ part ] = current = Config () else : current = current [ part ] try : current [ path [ - 1 ]] = loads ( v ) except ValueError as e : errors . append ( ErrorWrapper ( e , loc = path )) if errors : raise ConfitValidationError ( errors = errors ) if resolve : return config . resolve ( registry = registry ) return config from_disk ( path , resolve = False , registry = None ) classmethod Load a config object from a '.cfg' file PARAMETER DESCRIPTION path The path to the config object TYPE: Union [ str , Path ] resolve Whether to resolve sections with '@' keys TYPE: bool DEFAULT: False registry Optional registry to resolve from. If None, the default registry will be used. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Config Source code in confit/config.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def from_disk ( cls , path : Union [ str , Path ], resolve : bool = False , registry : Any = None ) -> \"Config\" : \"\"\" Load a config object from a '.cfg' file Parameters ---------- path: Union[str, Path] The path to the config object resolve Whether to resolve sections with '@' keys registry Optional registry to resolve from. If None, the default registry will be used. Returns ------- Config \"\"\" s = Path ( path ) . read_text () return cls . from_str ( s , resolve = resolve , registry = registry ) to_disk ( path ) Export a config to the disk (usually to a .cfg file) PARAMETER DESCRIPTION path TYPE: Union [ str , Path ] Source code in confit/config.py 139 140 141 142 143 144 145 146 147 148 def to_disk ( self , path : Union [ str , Path ]): \"\"\" Export a config to the disk (usually to a .cfg file) Parameters ---------- path: Union[str, path] \"\"\" s = Config . to_str ( self ) Path ( path ) . write_text ( s ) serialize () Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. a = A () # serializable object cfg = { \"a\" : a , \"b\" : a } print ( Config . serialize ( cfg )) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} RETURNS DESCRIPTION Config Source code in confit/config.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def serialize ( self : Any ): \"\"\" Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree. ```python a = A() # serializable object cfg = {\"a\": a, \"b\": a} print(Config.serialize(cfg)) # Out: {\"a\": {...}, \"b\": Reference(\"a\")} ``` Returns ------- Config \"\"\" refs = {} # Temp memory to avoid objects being garbage collected mem = [] def is_simple ( o ): return o is None or isinstance ( o , ( str , int , float , bool , Reference )) def rec ( o : Any , path : Loc = ()): if id ( o ) in refs : return refs [ id ( o )] if is_simple ( o ): return o if isinstance ( o , collections . abc . Mapping ): items = sorted ( o . items (), key = lambda x : 1 if ( is_simple ( x [ 1 ]) or isinstance ( x [ 1 ], ( collections . abc . Mapping , list , tuple )) ) else 0 , ) serialized = { k : rec ( v , ( * path , k )) for k , v in items } serialized = { k : serialized [ k ] for k in o . keys ()} mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) if isinstance ( o , Config ): serialized = Config ( serialized ) return serialized if isinstance ( o , ( list , tuple )): mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return type ( o )( rec ( v , ( * path , i )) for i , v in enumerate ( o )) cfg = None try : cfg = ( cfg or Config ()) . merge ( RESOLVED_TO_CONFIG [ o ]) except ( KeyError , TypeError ): pass try : cfg = ( cfg or Config ()) . merge ( o . cfg ) except AttributeError : pass if cfg is not None : mem . append ( o ) refs [ id ( o )] = Reference ( join_path ( path )) return rec ( cfg , path ) try : return pydantic_core . to_jsonable_python ( o ) except Exception : raise TypeError ( f \"Cannot dump { o !r} at { join_path ( path ) } \" ) return rec ( self ) to_str () Export a config to a string in the cfg format by serializing it first RETURNS DESCRIPTION str Source code in confit/config.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def to_str ( self ): \"\"\" Export a config to a string in the cfg format by serializing it first Returns ------- str \"\"\" additional_sections = {} prepared = flatten_sections ( Config . serialize ( self )) prepared . update ( flatten_sections ( additional_sections )) parser = ConfigParser () parser . optionxform = str for section_name , section in prepared . items (): parser . add_section ( section_name ) parser [ section_name ] . update ( { join_path (( k ,)): dumps ( v ) for k , v in section . items ()} ) s = StringIO () parser . write ( s ) return s . getvalue () resolve ( deep = True , registry = None , root = None ) Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. PARAMETER DESCRIPTION deep Should we resolve deeply DEFAULT: True registry Registry to use when resolving TYPE: Any DEFAULT: None root The root of the config tree. Used for resolving references. TYPE: Mapping DEFAULT: None RETURNS DESCRIPTION Union [ Config , Any ] Source code in confit/config.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 def resolve ( self , deep = True , registry : Any = None , root : Mapping = None ) -> Any : \"\"\" Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config. Parameters ---------- deep: bool Should we resolve deeply registry: Registry to use when resolving root: Mapping The root of the config tree. Used for resolving references. Returns ------- Union[Config, Any] \"\"\" if root is None : root = self if registry is None : from .registry import get_default_registry registry = get_default_registry () resolved_locs = {} seen_locs = set () def resolve_reference ( ref : Reference ) -> Any : pat = re . compile ( PATH + \":?\" ) def replace ( match : re . Match ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : return match . group () path = match . group () parts = split_path ( path . rstrip ( \":\" )) try : return local_names [ parts ] + ( \".\" if path . endswith ( \":\" ) else \"\" ) except KeyError : raise KeyError ( path ) local_leaves = {} local_names = {} for match in pat . finditer ( ref . value ): start = match . start () if start > 0 and ref . value [ start - 1 ] == \":\" : continue path = match . group () parts = split_path ( path . rstrip ( \":\" )) current = root for part in parts : current = current [ part ] if id ( current ) not in resolved_locs : resolved = rec ( current , parts ) else : resolved = resolved_locs [ id ( current )] local_names [ parts ] = f \"var_ { len ( local_leaves ) } \" local_leaves [ f \"var_ { len ( local_leaves ) } \" ] = resolved replaced = pat . sub ( replace , ref . value ) res = safe_eval ( replaced , local_leaves ) return res def rec ( obj , loc : Tuple [ Union [ str , int ]] = ()): \"\"\" Parameters ---------- obj: Any The current object being resolved loc: Sequence[str] Internal variable Current path in tree Returns ------- \"\"\" if id ( obj ) in resolved_locs : return resolved_locs [ id ( obj )] if id ( obj ) in seen_locs : raise CyclicReferenceError ( tuple ( loc )) seen_locs . add ( id ( obj )) if not deep and len ( loc ) > 1 : return obj if isinstance ( obj , Mapping ): resolved = Config ({ k : rec ( v , ( * loc , k )) for k , v in obj . items ()}) registries = [ ( key , value , getattr ( registry , key [ 1 :])) for key , value in resolved . items () if key . startswith ( \"@\" ) ] assert ( len ( registries ) <= 1 ), f \"Cannot resolve using multiple registries at { '.' . join ( loc ) } \" if len ( registries ) == 1 : cfg = resolved params = dict ( resolved ) params . pop ( registries [ 0 ][ 0 ]) fn = registries [ 0 ][ 2 ] . get ( registries [ 0 ][ 1 ]) try : resolved = fn ( ** params ) # The `validate_arguments` decorator has most likely # already put the resolved config in the registry # but for components that are instantiated without it # we need to do it here Config . _store_resolved ( resolved , cfg ) except ConfitValidationError as e : e = ConfitValidationError ( errors = patch_errors ( e . raw_errors , loc , params ), model = e . model , name = getattr ( e , \"name\" , None ), ) . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) if not is_debug (): e . __cause__ = None e . __suppress_context__ = True raise e elif isinstance ( obj , list ): resolved = [ rec ( v , ( * loc , i )) for i , v in enumerate ( obj )] elif isinstance ( obj , tuple ): resolved = tuple ( rec ( v , ( * loc , i )) for i , v in enumerate ( obj )) elif isinstance ( obj , Reference ): resolved = None while resolved is None : try : resolved = resolve_reference ( obj ) except KeyError : raise MissingReference ( obj ) else : resolved = obj resolved_locs [ id ( obj )] = resolved return resolved return rec ( self , ()) merge ( * updates , remove_extra = False ) Deep merge two configs. Heavily inspired from thinc 's config merge function. PARAMETER DESCRIPTION updates Configs to update the original config TYPE: Union [ Dict [ str , Any ], Config ] DEFAULT: () remove_extra If true, restricts update to keys that existed in the original config TYPE: bool DEFAULT: False RETURNS DESCRIPTION The new config Source code in confit/config.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def merge ( self , * updates : Union [ Dict [ str , Any ], \"Config\" ], remove_extra : bool = False , ) -> \"Config\" : \"\"\" Deep merge two configs. Heavily inspired from `thinc`'s config merge function. Parameters ---------- updates: Union[Config, Dict] Configs to update the original config remove_extra: If true, restricts update to keys that existed in the original config Returns ------- The new config \"\"\" def deep_set ( current , path , val ): if path not in current and remove_extra : return current [ path ] = val def rec ( old , new ): for key , new_val in list ( new . items ()): if \".\" in key : deep_set ( old , key , new_val ) continue if key not in old : if remove_extra : continue else : old [ key ] = new_val continue old_val = old [ key ] if isinstance ( old_val , dict ) and isinstance ( new_val , dict ): old_resolver = next (( k for k in old_val if k . startswith ( \"@\" )), None ) new_resolver = next (( k for k in new_val if k . startswith ( \"@\" )), None ) if ( new_resolver is not None and old_resolver is not None and ( old_resolver != new_resolver or old_val . get ( old_resolver ) != new_val . get ( new_resolver ) ) ): old [ key ] = new_val else : rec ( old [ key ], new_val ) else : old [ key ] = new_val return old config = self . copy () for u in updates : rec ( config , u ) return config copy () Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] RETURNS DESCRIPTION Any Source code in confit/config.py 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def copy ( self : T ) -> T : \"\"\" Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.) ``` Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}] ``` Returns ------- Any \"\"\" seen = {} def rec ( obj ): if id ( obj ) in seen : return seen [ id ( obj )] seen [ id ( obj )] = obj if isinstance ( obj , ( Config , dict )): return type ( obj )( { k : rec ( v ) for k , v in obj . items ()}, ) elif isinstance ( obj , list ): return [ rec ( v ) for v in obj ] elif isinstance ( obj , tuple ): return tuple ( rec ( v ) for v in obj ) elif isinstance ( obj , Reference ): return Reference ( obj . value ) else : return obj copy = rec ( self ) return copy merge_from_disk ( config_paths , returned_name = 'first' ) Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config PARAMETER DESCRIPTION config_paths Paths to the config files TYPE: Union [ Path , List [ Path ]] returned_name If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign TYPE: str DEFAULT: 'first' Source code in confit/config.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 def merge_from_disk ( config_paths : Union [ Path , List [ Path ]], returned_name : str = \"first\" , ): \"\"\" Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config Parameters ---------- config_paths: Union[Path, List[Path]] Paths to the config files returned_name: str If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign Returns ------- \"\"\" assert returned_name in { \"first\" , \"concat\" } if isinstance ( config_paths , Path ): config_paths = [ config_paths ] configs = [ Config . from_disk ( p , resolve = False ) for p in config_paths ] config_names = [ p . stem for p in config_paths ] name = config_names [ 0 ] if returned_name == \"first\" else \"+\" . join ( config_names ) config = configs . pop ( 0 ) return config . merge ( * configs ), name","title":"confit.config"},{"location":"fr/reference/errors/","text":"confit.errors MissingReference Bases: Exception Raised when one or multiple references cannot be resolved. Source code in confit/errors.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class MissingReference ( Exception ): \"\"\" Raised when one or multiple references cannot be resolved. \"\"\" def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref ) __init__ ( ref ) PARAMETER DESCRIPTION ref The reference that could not be resolved. TYPE: Reference Source code in confit/errors.py 38 39 40 41 42 43 44 45 46 def __init__ ( self , ref : Reference ): \"\"\" Parameters ---------- ref: Reference The reference that could not be resolved. \"\"\" self . ref = ref super () . __init__ () __str__ () String representation of the exception Source code in confit/errors.py 48 49 50 51 52 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Could not interpolate the following reference: {} \" . format ( self . ref ) CyclicReferenceError Bases: Exception Raised when a cyclic reference is detected. Source code in confit/errors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class CyclicReferenceError ( Exception ): \"\"\" Raised when a cyclic reference is detected. \"\"\" def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ () def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path )) __init__ ( path ) PARAMETER DESCRIPTION path The path of the cyclic reference TYPE: Loc Source code in confit/errors.py 60 61 62 63 64 65 66 67 68 def __init__ ( self , path : Loc ): \"\"\" Parameters ---------- path: Loc The path of the cyclic reference \"\"\" self . path = path super () . __init__ () __str__ () String representation of the exception Source code in confit/errors.py 70 71 72 73 74 def __str__ ( self ): \"\"\" String representation of the exception \"\"\" return \"Cyclic reference detected at {} \" . format ( join_path ( self . path )) remove_lib_from_traceback ( tb ) Remove the lib folder from the traceback Source code in confit/errors.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def remove_lib_from_traceback ( tb ): \"\"\" Remove the lib folder from the traceback \"\"\" # compare package to module in f_globals if is_debug (): return tb if tb is not None and tb . tb_frame . f_globals . get ( \"__package__\" ) == __package__ : return remove_lib_from_traceback ( tb . tb_next ) if tb is None or tb . tb_next is None : return tb tb . tb_next = remove_lib_from_traceback ( tb . tb_next ) return tb to_legacy_error ( err , model ) Decorator to convert a Pydantic ValidationError into a ConfitValidationError Source code in confit/errors.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def to_legacy_error ( err : pydantic . ValidationError , model : Any ) -> LegacyValidationError : \"\"\" Decorator to convert a Pydantic ValidationError into a ConfitValidationError \"\"\" if isinstance ( err , LegacyValidationError ): return err errors = err . errors ( include_url = False ) raw_errors = [] for err in errors : vrepr = repr ( err [ \"input\" ]) vrepr = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr err = dict ( err ) msg = err . pop ( \"msg\" , \"\" ) msg = ( msg [ 0 ] . lower () + msg [ 1 :]) if msg else msg raw_errors . append ( ErrorWrapper ( exc = err [ \"ctx\" ][ \"error\" ] if \"ctx\" in err and \"error\" in err [ \"ctx\" ] and isinstance ( err [ \"ctx\" ][ \"error\" ], BaseException ) else PydanticNewStyleError ( ** err , msg = msg , actual_value = vrepr , actual_type = type ( err [ \"input\" ]) . __name__ , ), loc = err [ \"loc\" ], ) ) return ConfitValidationError ( raw_errors , model = model ) patch_errors ( errors , path , values = None , model = None , special_names = ()) Patch the location of the errors to add the path prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. PARAMETER DESCRIPTION errors The pydantic errors to patch TYPE: Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] path The path to add to the errors TYPE: Loc values The values of the config TYPE: Dict DEFAULT: None special_names The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Union [ Sequence [ ErrorWrapper ], ErrorWrapper ] The patched errors Source code in confit/errors.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def patch_errors ( errors : Union [ Sequence [ ErrorWrapper ], ErrorWrapper ], path : Loc , values : Dict = None , model : Optional [ pydantic . BaseModel ] = None , special_names : Sequence [ str ] = (), ): \"\"\" Patch the location of the errors to add the `path` prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config. Parameters ---------- errors: Union[Sequence[ErrorWrapper], ErrorWrapper] The pydantic errors to patch path: Loc The path to add to the errors values: Dict The values of the config special_names: Sequence[str] The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path Returns ------- Union[Sequence[ErrorWrapper], ErrorWrapper] The patched errors \"\"\" if isinstance ( errors , list ): res = [] for error in errors : res . extend ( patch_errors ( error , path , values , model , special_names )) return res if isinstance ( errors , ErrorWrapper ) and isinstance ( errors . exc , LegacyValidationError ): try : field_model = model for part in errors . loc_tuple (): # if not issubclass(field_model, pydantic.BaseModel) and issubclass( # field_model.vd.model, pydantic.BaseModel # ): # field_model = field_model.vd.model if hasattr ( field_model , \"model_fields\" ): field_model = field_model . model_fields [ part ] else : field_model = field_model . __fields__ [ part ] if hasattr ( field_model , \"type_\" ): field_model = field_model . type_ else : field_model = field_model . annotation if ( field_model is errors . exc . model or field_model . vd . model is errors . exc . model ): return patch_errors ( errors . exc . raw_errors , ( * path , * errors . loc_tuple ()), values , model , special_names , ) except ( KeyError , AttributeError ): # pragma: no cover print ( \"Could not find model for\" , errors . loc_tuple ()) if ( isinstance ( errors . exc , PydanticErrorMixin ) and values is not None and errors . loc_tuple () and errors . loc_tuple ()[ 0 ] in values ): if \"actual_value\" not in errors . exc . __dict__ : actual_value = values for key in errors . loc_tuple (): actual_value = actual_value [ key ] vrepr = repr ( actual_value ) errors . exc . actual_value = vrepr [: 50 ] + \"...\" if len ( vrepr ) > 50 else vrepr errors . exc . actual_type = type ( actual_value ) . __name__ cls = errors . exc . __class__ if cls not in PATCHED_ERRORS_CLS : def error_str ( self ): s = cls . __str__ ( self ) s = ( s + f \", got { self . actual_value } ( { self . actual_type } )\" if hasattr ( self , \"actual_value\" ) else s ) return s new_cls = type ( cls . __name__ , ( cls ,), { \"msg_template\" : cls . msg_template + \", got {actual_value} ( {actual_type} )\" } if hasattr ( cls , \"msg_template\" ) else { \"__str__\" : error_str , }, ) PATCHED_ERRORS_CLS [ cls ] = new_cls PATCHED_ERRORS_CLS [ new_cls ] = new_cls errors . exc . __class__ = PATCHED_ERRORS_CLS [ cls ] if ( isinstance ( errors . exc , TypeError ) and str ( errors . exc ) . startswith ( \"unexpected keyword argument\" ) and \":\" in errors . exc . args [ 0 ] ): extra_keys = errors . exc . args [ 0 ] . split ( \": \" )[ 1 ] . split ( \", \" ) return [ ErrorWrapper ( TypeError ( \"unexpected keyword argument\" ), ( * path , * errors . loc_tuple ()[: - 1 ], key . strip ( \"'\" )), ) for key in extra_keys ] loc_tuple = errors . loc_tuple () if loc_tuple and loc_tuple [ - 1 ] in special_names : loc_tuple = ( * loc_tuple [: - 1 ], \"[signature]\" ) return [ ErrorWrapper ( errors . exc , ( * path , * loc_tuple ), ) ]","title":"confit.errors"},{"location":"fr/reference/registry/","text":"confit.registry VisibleDeprecationWarning Bases: UserWarning Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 Source code in confit/registry.py 346 347 348 349 350 351 352 353 354 355 class VisibleDeprecationWarning ( UserWarning ): \"\"\" Visible deprecation warning. By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug. Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51 \"\"\" # noqa: E501 Registry Bases: Registry A registry that validates the input arguments of the registered functions. Source code in confit/registry.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 class Registry ( catalogue . Registry ): \"\"\" A registry that validates the input arguments of the registered functions. \"\"\" def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace ) def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result ) __init__ ( namespace , entry_points = False ) Initialize the registry. PARAMETER DESCRIPTION namespace The namespace of the registry TYPE: Sequence [ str ] entry_points Should we use entry points to load the registered functions TYPE: bool DEFAULT: False Source code in confit/registry.py 366 367 368 369 370 371 372 373 374 375 376 377 378 def __init__ ( self , namespace : Sequence [ str ], entry_points : bool = False ) -> None : \"\"\" Initialize the registry. Parameters ---------- namespace: Sequence[str] The namespace of the registry entry_points: bool Should we use entry points to load the registered functions \"\"\" super () . __init__ ( namespace , entry_points = entry_points ) self . registry = None register ( name , * , func = None , save_params = None , skip_save_params = (), invoker = None , deprecated = ()) This is a convenience wrapper around catalogue.Registry.register , that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. PARAMETER DESCRIPTION name The name of the function TYPE: str func The function to register TYPE: Optional [ InFunc ] DEFAULT: None save_params Additional parameters to save when the function is called. If falsy, the function parameters are not saved TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None skip_save_params List of parameters to skip when saving the function parameters TYPE: Sequence [ str ] DEFAULT: () invoker An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. TYPE: Optional [ Callable ] DEFAULT: None deprecated The deprecated registry names for the function TYPE: Sequence [ str ] DEFAULT: () RETURNS DESCRIPTION Callable [[ InFunc ], InFunc ] Source code in confit/registry.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 def register ( self , name : str , * , func : Optional [ catalogue . InFunc ] = None , save_params : Optional [ Dict [ str , Any ]] = None , skip_save_params : Sequence [ str ] = (), invoker : Optional [ Callable ] = None , deprecated : Sequence [ str ] = (), ) -> Callable [[ catalogue . InFunc ], catalogue . InFunc ]: \"\"\" This is a convenience wrapper around `catalogue.Registry.register`, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments. Parameters ---------- name: str The name of the function func: Optional[catalogue.InFunc] The function to register save_params: Optional[Dict[str, Any]] Additional parameters to save when the function is called. If falsy, the function parameters are not saved skip_save_params: Sequence[str] List of parameters to skip when saving the function parameters invoker: Optional[Callable] = None, An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters. deprecated: Sequence[str] The deprecated registry names for the function Returns ------- Callable[[catalogue.InFunc], catalogue.InFunc] \"\"\" registerer = super () . register save_params = save_params or { f \"@ { self . namespace [ - 1 ] } \" : name } def invoke ( func , params ): resolved = invoker ( func , params ) if invoker is not None else func ( params ) if save_params is not None : params_to_save = { ** save_params , ** params } for name in skip_save_params : params_to_save . pop ( name , None ) Config . _store_resolved ( resolved , params_to_save ) return resolved def wrap_and_register ( fn : catalogue . InFunc ) -> catalogue . InFunc : if save_params is not None : _check_signature_for_save_params ( fn if not isinstance ( fn , type ) else fn . __init__ ) validated_fn = validate_arguments ( fn , config = { \"arbitrary_types_allowed\" : True }, registry = getattr ( self , \"registry\" , None ), invoker = invoke , ) registerer ( name )( validated_fn ) for deprecated_name in deprecated : def make_deprecated_fn ( old ): @wraps ( fn ) def deprecated_fn ( * args , ** kwargs ): warnings . warn ( f '\" { old } \" is deprecated, please use \" { name } \" instead.\"' , VisibleDeprecationWarning , ) return validated_fn ( * args , ** kwargs ) return deprecated_fn registerer ( deprecated_name )( make_deprecated_fn ( deprecated_name )) return validated_fn if func is not None : return wrap_and_register ( func ) else : return wrap_and_register get ( name ) Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. PARAMETER DESCRIPTION name The name of the function TYPE: str RETURNS DESCRIPTION InFunc Source code in confit/registry.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def get ( self , name : str ) -> catalogue . InFunc : \"\"\" Get the registered function for a given name. Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points. Parameters ---------- name: str The name of the function Returns ------- catalogue.InFunc \"\"\" if self . entry_points : from_entry_point = self . get_entry_point ( name ) if from_entry_point : return from_entry_point namespace = list ( self . namespace ) + [ name ] if not catalogue . check_exists ( * namespace ): raise catalogue . RegistryError ( f \"Can't find ' { name } ' in registry { ' -> ' . join ( self . namespace ) } . \" f \"Available names: { ', ' . join ( sorted ( self . get_available ())) or 'none' } \" ) return catalogue . _get ( namespace ) get_available () Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. Source code in confit/registry.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def get_available ( self ) -> Sequence [ str ]: \"\"\"Get all functions for a given namespace. namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name. \"\"\" result = set () if self . entry_points : result . update ({ p . name for p in self . _get_entry_points ()}) for keys in catalogue . REGISTRY . copy () . keys (): if len ( self . namespace ) == len ( keys ) - 1 and all ( self . namespace [ i ] == keys [ i ] for i in range ( len ( self . namespace )) ): result . add ( keys [ - 1 ]) return sorted ( result ) MetaRegistryCollection Bases: type A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. Source code in confit/registry.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 class MetaRegistryCollection ( type ): \"\"\" A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class. \"\"\" def __setattr__ ( self , key , value ): assert isinstance ( value , Registry ) value . registry = self super () . __setattr__ ( key , value ) def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls __init__ ( name , bases , dct ) Initialize the registry collection by adding it-self as the registry collection of all registries. PARAMETER DESCRIPTION name bases dct Source code in confit/registry.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def __init__ ( cls , name , bases , dct ): \"\"\" Initialize the registry collection by adding it-self as the registry collection of all registries. Parameters ---------- name bases dct \"\"\" super () . __init__ ( name , bases , dct ) for key , value in dct . items (): if isinstance ( value , Registry ): value . registry = cls RegistryCollection A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) Source code in confit/registry.py 545 546 547 548 549 550 551 552 553 class RegistryCollection ( metaclass = MetaRegistryCollection ): \"\"\" A collection of registries. ```python class MyRegistries(RegistryCollection): my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True) my_other_registry = Registry((\"package_name\", \"my_other_registry\")) \"\"\" validate_arguments ( func = None , * , config = None , invoker = None , registry = None ) Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing PARAMETER DESCRIPTION func The function or class to call TYPE: Optional [ Callable ] DEFAULT: None config The validation configuration object TYPE: Dict DEFAULT: None invoker An optional invoker to apply on the validated function TYPE: Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] DEFAULT: None registry The registry to use to resolve the default parameters TYPE: Any DEFAULT: None RETURNS DESCRIPTION Any Source code in confit/registry.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def validate_arguments ( func : Optional [ Callable ] = None , * , config : Dict = None , invoker : Optional [ Callable [[ Callable , Dict [ str , Any ]], Any ]] = None , registry : Any = None , ) -> Any : \"\"\" Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing Parameters ---------- func: Callable The function or class to call config: Dict The validation configuration object invoker: Optional[Callable] An optional invoker to apply on the validated function registry: Any The registry to use to resolve the default parameters Returns ------- Any \"\"\" if config is None : config = {} config = { ** config , \"arbitrary_types_allowed\" : True } def validate ( _func : Callable ) -> Callable : if isinstance ( _func , type ): _func : type if hasattr ( _func . __init__ , \"__wrapped__\" ): vd = ValidatedFunction ( _func . __init__ . __wrapped__ , config ) else : vd = ValidatedFunction ( _func . __init__ , config ) vd . model . __name__ = _func . __name__ if hasattr ( vd . model , \"model_fields\" ): vd . model . model_fields [ \"self\" ] . default = None else : vd . model . __fields__ [ \"self\" ] . default = None # This function is called by Pydantic when asked to cast # a value (most likely a dict) as a Model (most often during # a function call) old_get_validators = ( _func . __get_validators__ if hasattr ( _func , \"__get_validators__\" ) else None ) old_get_pydantic_core_schema = ( _func . __get_pydantic_core_schema__ if hasattr ( _func , \"__get_pydantic_core_schema__\" ) else None ) def __get_validators__ (): \"\"\" This function is called by Pydantic when asked to cast a value (most likely a dict) as a Model (most often during a function call) Yields ------- Callable The validator function \"\"\" def _validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) if old_get_validators is not None : for validator in old_get_validators (): value = validator ( value ) if isinstance ( value , _func ): return value return _func ( ** value ) yield _validate def __get_pydantic_core_schema__ ( * args , ** kwargs ): from pydantic_core import core_schema def pre_validate ( value ): if isinstance ( value , dict ): value = Config ( value ) . resolve ( registry = registry ) return value def post_validate ( value ): if isinstance ( value , _func ): return value return _func ( ** value ) return core_schema . chain_schema ( [ core_schema . no_info_plain_validator_function ( pre_validate ), * ( ( old_get_pydantic_core_schema ( * args , ** kwargs ),) if old_get_pydantic_core_schema else ( core_schema . no_info_plain_validator_function ( fn ) for fn in old_get_validators () ) if old_get_validators is not None else () ), core_schema . no_info_plain_validator_function ( post_validate ), ] ) # This function is called when we do Model(variable=..., other=...) @wraps ( vd . raw_function , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = True , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __context__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) _func . vd = vd # type: ignore _func . __get_validators__ = __get_validators__ # type: ignore _func . __get_pydantic_core_schema__ = ( __get_pydantic_core_schema__ # type: ignore ) _func . model = vd . model # type: ignore _func . model . type_ = _func # type: ignore _func . __init__ = wrapper_function _func . __init__ . __wrapped__ = vd . raw_function # type: ignore return _func else : vd = ValidatedFunction ( _func , config ) @wraps ( _func , assigned = ( \"__module__\" , \"__name__\" , \"__qualname__\" , \"__doc__\" , \"__annotations__\" , \"__defaults__\" , \"__kwdefaults__\" , ), ) def wrapper_function ( * args : Any , ** kwargs : Any ) -> Any : try : return _resolve_and_validate_call ( args = args , kwargs = kwargs , pydantic_func = vd , use_self = False , invoker = invoker , callee = _func , ) except Exception as e : if not is_debug () and isinstance ( e . __cause__ , ( ValidationError , LegacyValidationError ) ): e . __cause__ = None e . __suppress_context__ = True raise e . with_traceback ( remove_lib_from_traceback ( e . __traceback__ )) wrapper_function . vd = vd # type: ignore wrapper_function . validate = vd . init_model_instance # type: ignore wrapper_function . __wrapped__ = vd . raw_function # type: ignore wrapper_function . model = vd . model # type: ignore return wrapper_function if func : return validate ( func ) else : return validate get_default_registry () Get the default registered registry. RETURNS DESCRIPTION Registry Source code in confit/registry.py 556 557 558 559 560 561 562 563 564 def get_default_registry () -> Any : \"\"\" Get the default registered registry. Returns ------- Registry \"\"\" return _default_registry set_default_registry ( registry ) Set the default registered registry. This is used in Config.resolve() when no registry is provided. PARAMETER DESCRIPTION registry TYPE: CustomRegistry RETURNS DESCRIPTION Registry Source code in confit/registry.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 def set_default_registry ( registry : CustomRegistry ) -> CustomRegistry : \"\"\" Set the default registered registry. This is used in [`Config.resolve()`][confit.config.Config.resolve] when no registry is provided. Parameters ---------- registry: Registry Returns ------- Registry \"\"\" global _default_registry _default_registry = registry return registry","title":"confit.registry"},{"location":"fr/reference/utils/","text":"confit.utils","title":"confit.utils"},{"location":"fr/reference/utils/collections/","text":"confit.utils.collections join_path ( path ) Join a path into a string and quotes subpaths that contain dots. PARAMETER DESCRIPTION path RETURNS DESCRIPTION str Source code in confit/utils/collections.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def join_path ( path ): \"\"\" Join a path into a string and quotes subpaths that contain dots. Parameters ---------- path: Tuple[Union[int, str]] Returns ------- str \"\"\" return \".\" . join ( repr ( x ) if not isinstance ( x , str ) or split_path ( x . strip ()) != ( x ,) else x for x in path ) split_path ( path ) Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. PARAMETER DESCRIPTION path TYPE: str Source code in confit/utils/collections.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def split_path ( path : str ) -> Tuple [ Union [ int , str ]]: \"\"\" Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string. Parameters ---------- path: str Returns ------- \"\"\" offset = 0 result = [] for match in re . finditer ( KEY_PART , str ( path )): assert match . start () == offset , f \"Malformed path: { path !r} in config\" offset = match . end () part = next (( g for g in match . groups () if g is not None )) result . append ( int ( part ) if part . isdigit () else part ) if offset == len ( path ): break return tuple ( result ) flatten_sections ( root ) Flatten a nested dict of dicts into a \"flat\" dict of dict. PARAMETER DESCRIPTION root The root dict to flatten TYPE: Dict [ str , Any ] RETURNS DESCRIPTION Dict [ str , Dict [ str , Any ]] Source code in confit/utils/collections.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def flatten_sections ( root : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Flatten a nested dict of dicts into a \"flat\" dict of dict. Parameters ---------- root: Dict[str, Any] The root dict to flatten Returns ------- Dict[str, Dict[str, Any]] \"\"\" res = collections . defaultdict ( lambda : {}) def rec ( d , path ): res . setdefault ( join_path ( path ), {}) section = {} for k , v in d . items (): if isinstance ( v , dict ): rec ( v , ( * path , k )) else : section [ k ] = v res [ join_path ( path )] . update ( section ) rec ( root , ()) root_level = res . pop ( \"\" , None ) if root_level is not None and len ( root_level ) > 0 : raise Exception ( \"Cannot dump root level config\" , root_level ) return dict ( res )","title":"confit.utils.collections"},{"location":"fr/reference/utils/eval/","text":"confit.utils.eval Transformer Bases: NodeTransformer An ast NodeTransformer that only allows a subset of the Python AST. Source code in confit/utils/eval.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Transformer ( ast . NodeTransformer ): \"\"\" An ast NodeTransformer that only allows a subset of the Python AST. \"\"\" ALLOWED_NODE_TYPES = { \"Expression\" , \"Attribute\" , \"Slice\" , \"Subscript\" , \"Index\" , \"Constant\" , \"Tuple\" , \"Name\" , \"Load\" , \"Str\" , \"BinOp\" , \"Num\" , \"List\" , \"Dict\" , \"Set\" , \"Add\" , \"Sub\" , \"Mult\" , \"Div\" , \"FloorDiv\" , \"Mod\" , \"Pow\" , \"LShift\" , \"RShift\" , \"BitOr\" , \"BitXor\" , \"BitAnd\" , \"MatMult\" , \"And\" , \"Or\" , \"Compare\" , \"Eq\" , \"NotEq\" , \"Lt\" , \"LtE\" , \"Gt\" , \"GtE\" , \"Is\" , \"IsNot\" , \"In\" , \"NotIn\" , \"Starred\" , } def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node ) generic_visit ( node ) Checks that the node type is allowed. Source code in confit/utils/eval.py 55 56 57 58 59 60 61 62 63 def generic_visit ( self , node ): \"\"\" Checks that the node type is allowed. \"\"\" nodetype = type ( node ) . __name__ if nodetype not in self . ALLOWED_NODE_TYPES : raise RuntimeError ( f \"Invalid expression: { nodetype } not allowed !\" ) return ast . NodeTransformer . generic_visit ( self , node ) safe_eval ( source , locals_dict = None ) Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. PARAMETER DESCRIPTION source The expression to evaluate TYPE: str locals_dict The local variables to use in the evaluation TYPE: Optional [ Dict [ str , Any ]] DEFAULT: None RETURNS DESCRIPTION Any The result of the evaluation Source code in confit/utils/eval.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def safe_eval ( source : str , locals_dict : Optional [ Dict [ str , Any ]] = None ): \"\"\" Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled. Parameters ---------- source: str The expression to evaluate locals_dict: Optional[Dict[str, Any]] The local variables to use in the evaluation Returns ------- Any The result of the evaluation \"\"\" tree = ast . parse ( source , mode = \"eval\" ) transformer . visit ( tree ) clause = compile ( tree , \"<AST>\" , \"eval\" ) result = eval ( clause , { \"__builtins__\" : {}}, locals_dict ) return result","title":"confit.utils.eval"},{"location":"fr/reference/utils/random/","text":"confit.utils.random set_seed Source code in confit/utils/random.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class set_seed : def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_val , exc_tb ): set_random_generator_state ( self . state ) __init__ ( seed , cuda = None ) Set seed values for random generators. If used as a context, restore the random state used before entering the context. PARAMETER DESCRIPTION seed Value used as a seed. cuda Saves the cuda random states too TYPE: Optional [ bool ] DEFAULT: None Source code in confit/utils/random.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def __init__ ( self , seed , cuda : Optional [ bool ] = None ): \"\"\" Set seed values for random generators. If used as a context, restore the random state used before entering the context. Parameters ---------- seed: int Value used as a seed. cuda: bool Saves the cuda random states too \"\"\" # if seed is True: # seed = random.randint(1, 2**16) seed = random . randint ( 1 , 2 ** 16 ) if seed is True else seed self . state = get_random_generator_state ( cuda ) if seed is not None : random . seed ( seed ) try : import torch torch . manual_seed ( seed ) if cuda or ( cuda is None and torch . cuda . is_available () ): # pragma: no cover torch . cuda . manual_seed ( seed ) torch . cuda . manual_seed_all ( seed ) except ImportError : # pragma: no cover pass try : import numpy numpy . random . seed ( seed ) except ImportError : # pragma: no cover pass get_random_generator_state ( cuda = None ) Get the torch , numpy and random random generator state. PARAMETER DESCRIPTION cuda Saves the cuda random states too DEFAULT: None RETURNS DESCRIPTION RandomGeneratorState Source code in confit/utils/random.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def get_random_generator_state ( cuda = None ): \"\"\" Get the `torch`, `numpy` and `random` random generator state. Parameters ---------- cuda: bool Saves the cuda random states too Returns ------- RandomGeneratorState \"\"\" torch_state = torch_cuda_state = numpy_state = None random_state = random . getstate () try : import torch torch_state = torch . random . get_rng_state () if cuda or ( cuda is None and torch . cuda . is_available ()): # pragma: no cover torch_cuda_state = torch . cuda . get_rng_state_all () except ImportError : # pragma: no cover pass try : import numpy numpy_state = numpy . random . get_state () except ImportError : # pragma: no cover pass return RandomGeneratorState ( random_state , torch_state , numpy_state , torch_cuda_state , ) set_random_generator_state ( state ) Set the torch , numpy and random random generator state. PARAMETER DESCRIPTION state Source code in confit/utils/random.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_random_generator_state ( state ): \"\"\" Set the `torch`, `numpy` and `random` random generator state. Parameters ---------- state: RandomGeneratorState \"\"\" random . setstate ( state . random ) if state . torch is not None : import torch torch . random . set_rng_state ( state . torch ) if ( state . torch_cuda is not None and torch . cuda . is_available () and len ( state . torch_cuda ) == torch . cuda . device_count () ): # pragma: no cover torch . cuda . set_rng_state_all ( state . torch_cuda ) if state . numpy is not None : import numpy numpy . random . set_state ( state . numpy )","title":"confit.utils.random"},{"location":"fr/reference/utils/settings/","text":"confit.utils.settings","title":"confit.utils.settings"},{"location":"fr/reference/utils/xjson/","text":"confit.utils.xjson Reference A path reference to a value in the configuration. Source code in confit/utils/xjson.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Reference : \"\"\" A path reference to a value in the configuration. \"\"\" def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value def __repr__ ( self ): return f \"$ {{ { self . value } }} \" def __str__ ( self ): return self . __repr__ () def __eq__ ( self , other ): return self . value == other . value __init__ ( value ) PARAMETER DESCRIPTION value The path to the value in the configuration. TYPE: str Source code in confit/utils/xjson.py 13 14 15 16 17 18 19 20 def __init__ ( self , value : str ): \"\"\" Parameters ---------- value: str The path to the value in the configuration. \"\"\" self . value = value XJsonTransformer Bases: Transformer A Lark transformer to parse extended JSON. Source code in confit/utils/xjson.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class XJsonTransformer ( Transformer ): \"\"\" A Lark transformer to parse extended JSON. \"\"\" def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n ) def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n ) def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ]) list = list tuple = tuple pair = tuple dict = dict def null ( self , _ ): \"\"\"Parse null\"\"\" return None def true ( self , _ ): \"\"\"Parse true\"\"\" return True def false ( self , _ ): \"\"\"Parse false\"\"\" return False def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" ) def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" ) def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" ) __init__ ( input_string ) PARAMETER DESCRIPTION input_string The input string to parse. TYPE: str Source code in confit/utils/xjson.py 88 89 90 91 92 93 94 95 96 def __init__ ( self , input_string : str ): \"\"\" Parameters ---------- input_string: str The input string to parse. \"\"\" super () . __init__ () self . input_string = input_string string ( s ) Parse string Source code in confit/utils/xjson.py 98 99 100 101 102 def string ( self , s ): \"\"\"Parse string\"\"\" ( s ,) = s s = ast . literal_eval ( s ) return s float ( n ) Parse number Source code in confit/utils/xjson.py 104 105 106 107 def float ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return float ( n ) int ( n ) Parse number Source code in confit/utils/xjson.py 109 110 111 112 def int ( self , n ): \"\"\"Parse number\"\"\" ( n ,) = n return int ( n ) reference ( tree ) Parse reference Source code in confit/utils/xjson.py 114 115 116 117 def reference ( self , tree : Tree ): \"\"\"Parse reference\"\"\" meta = tree [ 0 ] . meta return Reference ( self . input_string [ meta . start_pos : meta . end_pos ]) null ( _ ) Parse null Source code in confit/utils/xjson.py 124 125 126 def null ( self , _ ): \"\"\"Parse null\"\"\" return None true ( _ ) Parse true Source code in confit/utils/xjson.py 128 129 130 def true ( self , _ ): \"\"\"Parse true\"\"\" return True false ( _ ) Parse false Source code in confit/utils/xjson.py 132 133 134 def false ( self , _ ): \"\"\"Parse false\"\"\" return False plus_inf ( _ ) Parse infinity Source code in confit/utils/xjson.py 136 137 138 def plus_inf ( self , _ ): \"\"\"Parse infinity\"\"\" return float ( \"inf\" ) minus_inf ( _ ) Parse -infinity Source code in confit/utils/xjson.py 140 141 142 def minus_inf ( self , _ ): \"\"\"Parse -infinity\"\"\" return - float ( \"inf\" ) nan ( _ ) Parse nan Source code in confit/utils/xjson.py 144 145 146 def nan ( self , _ ): \"\"\"Parse nan\"\"\" return float ( \"nan\" ) loads ( s ) Load an extended JSON string into a python object. Takes care of detecting references and tuples PARAMETER DESCRIPTION s TYPE: str RETURNS DESCRIPTION Any Source code in confit/utils/xjson.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def loads ( s : str ): \"\"\" Load an extended JSON string into a python object. Takes care of detecting references and tuples Parameters ---------- s: str Returns ------- Any \"\"\" try : return XJsonTransformer ( s ) . transform ( _json_parser . parse ( s )) except Exception : # Fail if we suspect that it is a malformed object # (e.g. has ', \", {, }, [, ] in it) if set ( s ) & set ( \",' \\\" {} []$\" ): raise MalformedValueError ( s ) return s dumps ( o ) Dump a python object into an extended JSON string. Takes care of serializing references and tuples PARAMETER DESCRIPTION o TYPE: Any RETURNS DESCRIPTION str Source code in confit/utils/xjson.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def dumps ( o : Any ): \"\"\" Dump a python object into an extended JSON string. Takes care of serializing references and tuples Parameters ---------- o: Any Returns ------- str \"\"\" return \"\" . join ( _make_iterencode ()( o ))","title":"confit.utils.xjson"}]}