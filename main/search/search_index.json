{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Confit","text":"<p>Confit is a complete and easy-to-use configuration framework aimed at improving the reproducibility of experiments by relying on the Python typing system, minimal configuration files and command line interfaces.</p> <p>The three pillars of this configuration system are the catalogue registry, the Pydantic validation system and the typer CLI library.</p>"},{"location":"#registry","title":"Registry","text":"<p>The catalogue registry records the various objects (classes or functions) that can be composed together to run your program. Once registered, with the <code>registry.factory.register</code> decorator, these objects are accessible as [entry points] and can be used in the configuration system. To start, you can create a simple registry <code>\"factory\"</code> as follows:</p> <pre><code>from confit import Registry, RegistryCollection\n\n\nclass registry(RegistryCollection):\n    factory = Registry((\"my_library\", \"factory\"), entry_points=True)\n</code></pre> <p>What is this useful for?</p> <p>With this registry, you can register a function or a class:</p> <pre><code>@registry.factory.register(\"my-function\")\ndef my_function(value=10):\n    print(f\"The value is {value}!\")\n</code></pre> <p>Now you can dynamically retrieve the function from anywhere:</p> <pre><code>func = registry.factory.get(\"my-function\")\nfunc()\n# Out: \"The value is 10!\"\nfunc(value=42)\n# Out: \"The value is 42!\"\n</code></pre>"},{"location":"#typing-system","title":"Typing system","text":"<p>The Pydantic <code>validate_arguments</code> decorator enhances a function to automatically parse and validate its arguments every time it is called, using the Pydantic typing-based validation system. For instance, strings can be automatically cast as Path objects, or datetime or numbers depending on the type annotation of the argument.</p> <p>Combined with our configuration system, dictionaries passed as arguments to a decorated function can be \"cast\" as instantiated classes if these classes were them-selves decorated.</p>"},{"location":"#cli","title":"CLI","text":"<p>We provide the <code>confit.Cli</code> object, a Typer-based wrapper that turns a regular function into a command line interface. Once decorated with <code>@app.command</code>, the function can be executed from the terminal and automatically accepts one or several <code>--config</code> files containing its parameters, as well as parameter-wise overrides.</p> <p>For instance, we'll decorate the <code>cool_function</code> function to make it available as a command line interface, and put some of its parameters in a configuration file <code>config.yml</code>:</p> <pre><code>from confit import Cli, Registry, RegistryCollection\n\n\nclass registry(RegistryCollection):\n    factory = Registry((\"myapp\", \"factory\"), entry_points=True)\n\n\n@registry.factory.register(\"my-class\")\nclass MyClass:\n    def __init__(self, value1: int, value2: float):\n        self.value1 = value1\n        self.value2 = value2\n\n\napp = Cli()\n\n\n@app.command(name=\"cool_function\", registry=registry)\ndef cool_function(\n    modelA: MyClass,\n    modelB,\n    seed: int = 0,\n):\n    ...\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> config.yml<pre><code># No need for @factory here, as the type hint is enough\nmodelA:\n  value1: 0\n  value2: 1.5\n\n# ModelB is not type hinted, so we need to tell how to instantiate it\nmodelB:\n  \"@factory\": \"my-class\"\n  value1: 2\n  value2: 3.5\n\ncool_function:\n  modelA: ${modelA}\n  modelB: ${modelB}\n</code></pre> <p>All left to do is to run the script with the <code>--config</code> option, which will read the configuration file and instantiate the objects accordingly:</p> <pre><code>python script.py --config config.yml --seed 42\n</code></pre> <p>Command line arguments override values from the configuration. If multiple configuration files are provided, they are merged in order.</p>"},{"location":"#the-config-object","title":"The Config object","text":"<p>The configuration object consists of a supercharged dict, the <code>Config</code> class, that can  be used to read and write to <code>cfg</code> files, interpolate variables and instantiate components  through the registry with some special <code>@factory</code> keys. A cfg file can be used directly as an input to a CLI-decorated function.</p> <p>We will show partial examples with increasing complexity below. See here for an end-to-end example.</p>"},{"location":"#instantiating-an-object","title":"Instantiating an object","text":"script.py<pre><code>@registry.factory.register(\"my-class\")\nclass MyClass:\n    def __init__(self, value1: int, value2: float):\n        self.value1 = value1\n        self.value2 = value2\n</code></pre> INI syntaxYAML syntax config.cfg<pre><code>[myclass]\n@factory = \"my-class\"\nvalue1 = 1.1\nvalue2 = 2.5\n</code></pre> config.yaml<pre><code>myclass:\n  \"@factory\": \"my-class\"\n  value1: 1.1\n  value2: 2.5\n</code></pre> <p>Here, Confit will:</p> <ul> <li>Parse the configuration</li> <li>Get the target class from the registry</li> <li>Validate parameters if needed (in this case, <code>value1</code> is typed as an int, thus it will be casted as an int by setting <code>value1=1</code>)</li> <li>Instantiate the class using the validated parameters</li> </ul>"},{"location":"#interpolating-values","title":"Interpolating values","text":"<p>When multiple sections of the configuration need to access the same value, you can provide it using the <code>${&lt;section.value&gt;}</code> syntax:</p> INI syntaxYAML syntax config.cfg<pre><code>[myclass]\n@factory = \"my-class\"\nvalue1 = 1.1\nvalue2 = ${other_values.value3}\n\n[other_values]\nvalue3 = 10\n</code></pre> config.yaml<pre><code>myclass:\n  \"@factory\": \"my-class\"\n  value1: 1.1\n  value2: ${other_values.value3}\n</code></pre> <p>Here, <code>value2</code> will be set to 10.</p>"},{"location":"#advanced-interpolation","title":"Advanced interpolation","text":"<p>You can even pass instantiated objects! Suppose we have a registered <code>myOtherClass</code> class expecting an instance of <code>MyClass</code> as input. You could use the following configuration:</p> INI syntaxYAML syntax config.cfg<pre><code>[func]\n@factory = \"my-other-class\"\nobj = ${myclass}\n\n[myclass]\n@factory = \"my-class\"\nvalue1 = 1.1\nvalue2 = ${other_values.value3}\n\n[other_values]\nvalue3 = 10\n</code></pre> config.yaml<pre><code>func:\n  \"@factory\": \"my-other-class\"\n  obj: ${myclass}\n\nmyclass:\n    \"@factory\": \"my-class\"\n    value1: 1.1\n    value2: ${other_values.value3}\n\nother_values:\n    value3: 10\n</code></pre> <p>Finally, you may want to access some attributes of Python classes that are available after instantiation, but not present in the configuration file. For instance, let's modify our <code>MyClass</code> class:</p> script.py<pre><code>@registry.factory.register(\"my-class\")\nclass MyClass:\n    def __init__(self, value1: int, value2: float):\n        self.value1 = value1\n        self.value2 = value2\n+         self.hidden_value = 99\n</code></pre> <p>To access those values directly in the configuration file, use the <code>${&lt;obj:attribute&gt;}</code> syntax (notice the colon instead of the point)</p> INI syntaxYAML syntax config.cfg<pre><code>[myclass]\n@factory = \"my-class\"\nvalue1 = 1.1\nvalue2 = 2.5\n\n[other_values]\nvalue3 = ${myclass:hidden_value}\n</code></pre> config.yaml<pre><code>myclass:\n  \"@factory\": \"my-class\"\n  value1: 1.1\n  value2: 2.5\n\nother_values:\n    value3: ${myclass:hidden_value}\n</code></pre>"},{"location":"#drafts","title":"Drafts","text":"<p>When a component is instantiated with <code>MyClass.draft(...)</code> instead of <code>MyClass(...)</code>, the call returns a <code>Draft</code> object rather than instantiating the object immediately.</p> <p>This \"draft\" retains the provided parameters and can be instantiated later via <code>Draft.instantiate()</code>. This is particularly useful when certain parameters not available at the same time, and the object's instantiation can be delegated to another component.</p> <p>This can be seen as a simplified version of the builder design pattern.</p> <pre><code>from confit import validate_arguments\n\n\n@validate_arguments\nclass MyClass:\n    def __init__(self, value1: int, value2: float):\n        self.value1 = value1\n        self.value2 = value2\n\n    def __repr__(self):\n        return f\"MyClass(value1={self.value1}, value2={self.value2})\"\n\n\ndraft = MyClass.draft(value1=1)\ntype(draft)\n# Out: Draft[MyClass]\n\ndraft.instantiate(value2=2.5)\n# Out: MyClass(value1=1, value2=2.5)\n</code></pre> <p>In a config file, a draft can be instantiated by using the following syntax: <pre><code>modelA:\n    \"@draft\": my-class !draft\n    value1: 0\n</code></pre></p>"},{"location":"alternatives/","title":"Alternatives &amp; Comparison","text":"<p>In this section, we will explore what inspired Confit and how it compares to other alternative Python packages.</p>"},{"location":"alternatives/#confection","title":"Confection","text":"<p>Confection (originally part of the Thinc library) is another configuration framework from which Confit takes most of its inspiration. Both Confit and Confection support loading and exporting configuration data from/to strings or config files, as well as basic interpolation and custom class instantiation from a registry.</p> <p>However, Confit takes it a step further by allowing arbitrary expression evaluation, post-resolution interpolation, and exporting features such as saving to strings or config files, serialization of JSON-like objects, custom classes, and reference serialization.</p> <p>Confit also adds support for command-line interfaces by either passing a config file as an argument or by passing arguments (or overrides) directly to the CLI, while benefiting from argument validation and type casting.</p>"},{"location":"alternatives/#gin-config","title":"Gin-config","text":"<p>Gin Config is a flexible configuration system built for machine learning research. Like Confit and Confection, gin-config supports basic interpolation and custom class instantiation and offers CLI support. However, it does not provide exporting configuration objects functionalities like Confit does or parameter validation.</p>"},{"location":"alternatives/#typer","title":"Typer","text":"<p>Typer is a CLI library that focuses on providing easy-to-use functionalities for building command-line interface. While Typer offers excellent CLI support and basic argument validation, it does not have configuration file-related features such as loading, exporting, or parameter validation like Confit does. Confit relies on Typer for its CLI support, but adds config file arguments and instantiating classes from a registry, both of which are not available in Typer.</p> <p>However, if your primary focus is on building a robust CLI, Typer is a strong alternative.</p>"},{"location":"alternatives/#pydantic-cli","title":"Pydantic-CLI","text":"<p>Pydantic-CLI is another CLI library that combines Pydantic and argparse for creating command-line interfaces. Pydantic-CLI provides CLI support and argument validation, similar to Typer. However, it does not have any configuration file-related features like Confit does, nor does it allow instantiating custom classes.</p>"},{"location":"alternatives/#tabular-comparison","title":"Tabular comparison","text":""},{"location":"alternatives/#loading","title":"Loading","text":"Feature Confit Confection Gin Typer Pydantic-cli Load from str/config file Basic interpolation NA NA Arbitrary expression eval NA NA Post-resolution interpolation NA NA Custom class instantiation NA NA Deferred instantiation NA NA"},{"location":"alternatives/#exporting","title":"Exporting","text":"Feature Confit Confection Gin Typer Pydantic-cli Save to str/config file Serialization of JSON-like obj NA NA NA Serialization of custom classes NA NA NA Reference serialization NA NA NA"},{"location":"alternatives/#cli","title":"CLI","text":"Feature Confit Confection Gin Typer Pydantic-cli CLI support CLI short-hands NA Argument validation NA Config file argument NA"},{"location":"alternatives/#parameter-validation","title":"Parameter validation","text":"Feature Confit Confection Gin Typer Pydantic-cli Parameter validation support Auto casting NA From a Python func/class call NA"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v0102-2025-12-11","title":"v0.10.2 (2025-12-11)","text":"<ul> <li>Confit should not complain anymore when given multiline strings</li> </ul>"},{"location":"changelog/#v0101-2025-09-29","title":"v0.10.1 (2025-09-29)","text":"<ul> <li>Simplify typing of <code>Registry.register(...)</code> to help jedi infer the type of the registered callable</li> </ul>"},{"location":"changelog/#v0100-2025-08-26","title":"v0.10.0 (2025-08-26)","text":"<ul> <li>Drop <code>auto_draft_in_config</code>, in favor of explicitly using   <pre><code>@registry: myname !draft\n</code></pre>   to define a draft object</li> <li> Even if a <code>MyClass.draft(...)</code> instantiation contains all required parameter, it will now still return a draft. <code>draft.instantiate</code> must be called to instantiate the actual object.</li> <li>Support <code>isinstance(obj, Draft)</code> for Draft instances</li> </ul>"},{"location":"changelog/#v090-2025-05-15","title":"v0.9.0 (2025-05-15)","text":"<ul> <li>Fix calling @validate_arguments on classes with wrapped <code>__init__</code> functions (e.g. accelerate loggers)</li> <li>Enforce <code>auto_draft_in_config</code> parameter when a function is imported via entry points (i.e., apply precedence to function passed to <code>Registry.register</code>, instead of the one got from the entry point)</li> <li>Add <code>default_config</code> option in CLI decorator</li> </ul>"},{"location":"changelog/#v080-2025-04-15","title":"v0.8.0 (2025-04-15)","text":"<ul> <li>Added <code>auto_draft_in_config</code> parameter to <code>register(...)</code> function. This is meant for functions that can only be partially be instantiated by a user, because a required parameter will be provided by the library later.</li> </ul> <p>For instance:</p> <ul> <li>EDS-NLP's <code>ScheduledOptimizer</code> requires the pipeline parameters, which depends on the pipeline being trained</li> <li>EDS-NLP's local trackers (like <code>csv</code> and <code>json</code>) require <code>logging_dir</code> which might be defined in the <code>edsnlp.train</code> function.</li> </ul> <p>If a callable registered with <code>auto_draft_in_config=True</code> is resolved with missing required parameters, a <code>Draft[ReturnType]</code> class is returned.   This class can then be instantiated via the draft.instantiate method.   We don't instantiate a Draft class via the <code>__call__</code> method to avoid users mistakenly proceeding with a non instantiated class.   Instead, whenever a Draft an attribute or a method is requested on Draft class, outside the Draft few specific attrs/methods,   a message error is displayed explaining how this object is not instantiated yet.</p> <p>The user can also explicitly instantiate the Draft object via the <code>Class.draft</code> method for classes that have been wrapped with <code>validate_arguments</code>.</p> <ul> <li>Added a <code>Validatable</code> class that can be inherited from to run a <code>validate</code> class method whenever the class is validated</li> </ul>"},{"location":"changelog/#v075-2025-03-21","title":"v0.7.5 (2025-03-21)","text":"<ul> <li>Allow non-string keys in config files</li> </ul>"},{"location":"changelog/#v074-2025-01-15","title":"v0.7.4 (2025-01-15)","text":"<ul> <li>Allow larger than 4096 bytes config files</li> <li>Escape tabs and newline when serializing to a config file</li> <li>Fix an infinite loop that occurred when resolving a reference to a field with a null value</li> </ul>"},{"location":"changelog/#v073-2024-12-11","title":"v0.7.3 (2024-12-11)","text":"<ul> <li>Support interpolated seed in the config file (as a reminder, the seed is treated specifically by confit to initialize random generators before any object is resolved)</li> <li>Support if/else expressions in interpolation, and only resolve the relevant branch</li> </ul>"},{"location":"changelog/#v072-2024-11-23","title":"v0.7.2 (2024-11-23)","text":"<ul> <li>Seed the program BEFORE the config file is resolved and components have been instantiated, to ensure reproducibility.</li> </ul>"},{"location":"changelog/#v071-2024-11-21","title":"v0.7.1 (2024-11-21)","text":"<ul> <li>Force utf-8 encoding when writing a config file (ini or yaml)</li> </ul>"},{"location":"changelog/#v070-2024-10-22","title":"v0.7.0 (2024-10-22)","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Aborting a script will now show the traceback</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Confit should no longer cause pydantic v1 deprecation warnings</li> </ul>"},{"location":"changelog/#v060-2024-09-13","title":"v0.6.0 (2024-09-13)","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Support IPython autoreload on confit wrapped functions</li> <li>Support using config files with scripts without a dedicated section header</li> <li>Disable configparser interpolation (% symbol)</li> <li>Better support for escaped strings in config files</li> <li>Various registry-related fixes</li> </ul>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Non-relevant fields (outside the script dedicated section) are no longer instantiated when running a script with a config file</li> <li>We now support loading and serializing configs in yaml syntax (<code>Confit.from_yaml_str</code>, <code>Confit.to_yaml_str</code>, <code>Confit.from_disk(\"___.yaml\")</code> and <code>Confit.to_disk(\"___.yaml\")</code>)</li> </ul>"},{"location":"changelog/#v055","title":"v0.5.5","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support fixing the path of validation errors raised inside a \"validate\" function (see the <code>AsList</code> meta type in the tests)</li> </ul>"},{"location":"changelog/#v054","title":"v0.5.4","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>We now forward function signature when accessing a callable via a deprecated registry name.   This is useful when registry.get(\"deprecated-name\") is inspected.</li> </ul>"},{"location":"changelog/#v053","title":"v0.5.3","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>We now raise an error if a value in the config cannot be deserialized as a JSON object but contains characters that hint at a JSON object (e.g. quotes, brackets, etc.). This changes the old behavior where we would silently ignore the value and keep the string as is.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Allow complex interpolations like <code>${[*section.\"key.with.dot\", \"baz\"]}</code></li> </ul>"},{"location":"changelog/#v052","title":"v0.5.2","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Keys with dots (or path-like keys in general) will be escaped when serializing a config <pre><code>{\"section\": {\"deep.key\": \"ok\"}}\n</code></pre> will be serialized as <pre><code>[section]\n'deep.key' = \"ok\"\n</code></pre></li> </ul>"},{"location":"changelog/#v051","title":"v0.5.1","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Use context instead of func for set_seed to allow   <pre><code>with set_seed(42):\n    # do stuff\n    num = random.randint(0, 100)\n</code></pre></li> <li>Add auto-reload plugin to work with confit wrapped functions in notebooks</li> </ul>"},{"location":"changelog/#v050","title":"v0.5.0","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>deprecated</code> parameter to register an object under multiple names with deprecation warnings</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Stop interpreting type errors as validation errors when executing a validated function</li> </ul>"},{"location":"changelog/#v043-31-08-2023","title":"v0.4.3 - 31-08-2023","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Save var kwargs as separate fields</li> </ul>"},{"location":"changelog/#v042-31-08-2023","title":"v0.4.2 - 31-08-2023","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Re-enable extra/duplicate arg errors and uniformize between pydantic v1/v2</li> <li>Add pydantic-core dependency for jsonable types during dump</li> </ul>"},{"location":"changelog/#v041-29-08-2023","title":"v0.4.1 - 29-08-2023","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Use pydantic v2 context error only if it is an exception</li> </ul>"},{"location":"changelog/#v040-29-08-2023","title":"v0.4.0 - 29-08-2023","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Improve validation errors merging and display. By default, confit related frames and exception causes   in the traceback are hidden.</li> <li>Show inner-confit traceback and exception chains if <code>CONFIT_DEBUG</code> env var is true</li> <li>Support for both Pydantic v2 and v1</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>If the <code>seed</code> is given a default value in CLI, it can now be used by confit when no seed is given</li> </ul>"},{"location":"changelog/#v030-25-08-2023","title":"v0.3.0 - 25-08-2023","text":"<ul> <li>Allow keyword only parameters</li> <li>Avoid import of all entry points by catalogue during failed registry lookup</li> <li>Fix bug in serialization, leading to mixed config fields</li> </ul>"},{"location":"changelog/#v021-11-05-2023","title":"v0.2.1 - 11-05-2023","text":"<ul> <li>Fix un-allowed kwargs: accepted signatures are <code>fn(paramA, paramB=..., ... **kwargs)</code></li> </ul>"},{"location":"changelog/#v020-05-04-2023","title":"v0.2.0 - 05-04-2023","text":"<ul> <li><code>Config.merge(...)</code> now only copies collections (not the underlying data) and doesn't split keys around dots</li> <li><code>__path__</code> option has been removed (having a override_structure in .to_str() would be better)</li> <li>Allow to skip some parameters when storing config before resolution</li> <li>Allow to resolve only a part of a configuration</li> <li>Improve serialization (can refer to dict/tuple/list objects now) and merge the instance's <code>.cfg</code> attribute (which can be updated by the instance) with the stored config</li> <li>Add the <code>invoker</code> option to <code>.register(...)</code> to modify the arguments of the call to the registered function or do something with the result</li> <li>User defined <code>class registry</code> should now inherit from <code>RegistryCollection</code></li> </ul>"},{"location":"changelog/#v015-02-03-2023","title":"v0.1.5 - 02-03-2023","text":"<ul> <li>Verify the signature when registering rather than during a call</li> <li>Allow <code>**kwargs</code></li> </ul>"},{"location":"changelog/#v014-27-02-2023","title":"v0.1.4 - 27-02-2023","text":"<ul> <li>More robust resolution algorithm</li> <li>Cyclic reference detection</li> <li>Extended JSON syntax reading &amp; writing (tuple &amp; nested refs)</li> <li>Fix lists and tuple parsing</li> <li>Fix multi registration</li> <li>Fix inheritance between registered classes</li> <li>Multilingual doc &amp; improved docs style</li> </ul>"},{"location":"changelog/#v011-06-01-2023","title":"v0.1.1 - 06-01-2023","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Enhanced references capabilities</li> </ul>"},{"location":"changelog/#v010-30-12-2022","title":"v0.1.0 - 30-12-2022","text":"<p>Inception ! </p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Config object with pre-resolve</li> <li>typer CLI wrappers</li> <li>catalogue registries</li> <li>...</li> </ul>"},{"location":"contributing/","title":"Contributing to Confit","text":"<p>We welcome contributions ! There are many ways to help. For example, you can:</p> <ol> <li>Help us track bugs by filing issues</li> <li>Suggest and help prioritise new functionalities</li> <li>Help us make the library as straightforward as possible, by simply asking questions on whatever does not seem clear to you.</li> </ol>"},{"location":"contributing/#development-installation","title":"Development installation","text":"<p>To be able to run the test suite and develop your own pipeline, you should clone the repo and install it locally. You will need to have uv installed.</p> <pre><code># Clone the repository and change directory\ngit clone ssh://git@github.com/aphp/confit.git\n\ncd confit\n\n# Install the library with its dev dependencies\nuv pip install -e . --group dev --group docs\n\n# Activate the virtual environment\nsource .venv/bin/activate\n</code></pre> <p>To make sure the pipeline will not fail because of formatting errors, we added pre-commit hooks using the <code>pre-commit</code> Python library. To use it, simply install it:</p> <pre><code>pre-commit install\n</code></pre> <p>The pre-commit hooks defined in the configuration will automatically run when you commit your changes, letting you know if something went wrong.</p> <p>The hooks only run on staged changes. To force-run it on all files, run:</p> <pre><code>uv run pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#proposing-a-merge-request","title":"Proposing a merge request","text":"<p>Ideally, your changes should :</p> <ul> <li>Be well-documented</li> <li>Pass every tests, and preferably implement their own</li> <li>Follow the style guide.</li> </ul>"},{"location":"contributing/#testing-your-code","title":"Testing your code","text":"<p>We use the Pytest test suite.</p> <p>The following command will run the test suite. Writing your own tests is encouraged !</p> <pre><code>uv run pytest\n</code></pre> <p>Should your contribution propose a bug fix, we require the bug be thoroughly tested.</p>"},{"location":"contributing/#style-guide","title":"Style Guide","text":"<p>We use Ruff to reformat the code.</p> <p>Moreover, the CI/CD pipeline enforces a number of checks on the \"quality\" of the code. To wit, non ruff-formatted code will make the test pipeline fail. We use <code>pre-commit</code> to keep our codebase clean.</p> <p>Refer to the development install tutorial for tips on how to format your files automatically. Most modern editors propose extensions that will format files on save.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Make sure to document your improvements, both within the code with comprehensive docstrings, as well as in the documentation itself if need be.</p> <p>We use <code>MkDocs</code> for Confit's documentation. You can checkout the changes you make with:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>Go to <code>localhost:8000</code> to see your changes. MkDocs watches for changes in the documentation folder and automatically reloads the page.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install the library with pip:</p> <pre><code>pip install confit\n</code></pre>"},{"location":"getting-started/#a-simple-example","title":"A simple example","text":"<p>Confit only abstracts the boilerplate code related to configuration and leaves the rest of your code unchanged.</p> <p>Here is an example:</p> script.py<pre><code>import datetime\n+ from confit import Cli, Registry, RegistryCollection\n\n+ app = Cli(pretty_exceptions_show_locals=False)\n\n+ class RegistryCollection(:\n+     factory = Registry((\"test_cli\", \"factory\"), entry_points=True)\n\n+ @registry.factory.register(\"submodel\")\nclass SubModel:\n    # Type hinting is optional but recommended to benefit for argument casting !\n    def __init__(self, value: float, desc: str = \"\"):\n        self.value = value\n        self.desc = desc\n\n\n+ @registry.factory.register(\"bigmodel\")\nclass BigModel:\n    def __init__(self, date: datetime.date, submodel: SubModel):\n        self.date = date\n        self.submodel = submodel\n\n\n+ @app.command(name=\"script\", registry=registry)\ndef func(modelA: BigModel, modelB: BigModel, other: int, seed: int):\n    assert modelA.submodel is modelB.submodel\n    assert modelA.date == datetime.date(2010, 10, 10)\n    print(\"Other:\", other)\n\n+ if __name__ == \"__main__\":\n+     app()\n</code></pre> <p>Create a new config file</p> INI syntaxYAML syntax config.cfg<pre><code># CLI sections\n[script]\nmodelA = ${modelA}\nmodelB = ${modelB}\n\n# CLI common parameters\n[modelA]\n@factory = \"bigmodel\"\ndate = \"2010-10-10\"\n\n[modelA.submodel]\n@factory = \"submodel\"\nvalue = 12\n\n[modelB]\ndate = \"2003-04-05\"\nsubmodel = ${modelA.submodel}\n</code></pre> <p>and run the following command from the terminal</p> <pre><code>python script.py --config config.cfg --seed 42\n</code></pre> config.yaml<pre><code>script:\n  modelA: ${modelA}\n  modelB: ${modelB}\n\nmodelA:\n  \"@factory\": \"bigmodel\"\n  date: \"2010-10-10\"\n\n  submodel:\n    \"@factory\": \"submodel\"\n    value: 12\n\nmodelB:\n  date: \"2003-04-05\"\n  submodel: ${modelA.submodel}\n</code></pre> <p>and run the following command from the terminal</p> <pre><code>python script.py --config config.yaml --seed 42\n</code></pre> <p>Naming</p> <p>To use the name of your config path (e.g. <code>config-expe-2</code> if the configuration file is named <code>config-expe-2.cfg</code> in the configuration (after resolution), simply mention <code>name = None</code> under the section which title was provided at <code>@app.command(name=&lt;section-title&gt;)</code></p> <p>Multiple configurations</p> <p>You can pass multiple configuration files by repeating the <code>--config</code> option. Configuration will be merged in order.</p> <p>You can still call the <code>function</code> method from your code, but now also benefit from argument validation !</p> <pre><code>from script import func, BigModel, SubModel\n\n# To seed before creating the models\nfrom confit.utils.random import set_seed\n\nseed = 42\nset_seed(seed)\n\nsubmodel = SubModel(value=12)\n# BigModel will cast date strings as datetime.date objects\nmodelA = BigModel(date=\"2003-02-01\", submodel=submodel)\nmodelB = BigModel(date=\"2003-04-05\", submodel=submodel)\nfunc(\n    modelA=modelA,\n    modelB=modelA,\n    seed=seed,\n)\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":"<ul> <li>better pydantic &lt;-&gt; typer errors</li> <li>tutorials</li> <li>find edge cases ...</li> </ul>"},{"location":"reference/","title":"<code>confit</code>","text":""},{"location":"reference/cli/","title":"<code>confit.cli</code>","text":""},{"location":"reference/cli/#confit.cli.Cli","title":"<code>Cli</code>","text":"<p>           Bases: <code>Typer</code></p> <p>Custom Typer object that:</p> <ul> <li>validates a command parameters before executing it</li> <li>accepts a configuration file describing the parameters</li> <li>automatically instantiates parameters given a dictionary when type hinted</li> </ul>"},{"location":"reference/cli/#confit.cli.parse_overrides","title":"<code>parse_overrides</code>","text":"<p>Parse the overrides from the command line into a dictionary of key-value pairs.</p>"},{"location":"reference/cli/#confit.cli.parse_overrides--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>args</code> <p>The arguments to parse</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The parsed overrides as a dictionary</p> Source code in <code>confit/cli.py</code> <pre><code>def parse_overrides(args: List[str]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Parse the overrides from the command line into a dictionary\n    of key-value pairs.\n\n    Parameters\n    ----------\n    args: List[str]\n        The arguments to parse\n\n    Returns\n    -------\n    Dict[str, Any]\n        The parsed overrides as a dictionary\n    \"\"\"\n    result = {}\n    while args:\n        opt = args.pop(0)\n        err = f\"Invalid config override '{opt}'\"\n        if opt.startswith(\"--\"):  # new argument\n            opt = opt.replace(\"--\", \"\")\n            if \"=\" in opt:  # we have --opt=value\n                opt, value = opt.split(\"=\", 1)\n            else:\n                if not args or args[0].startswith(\"--\"):  # flag with no value\n                    value = \"true\"\n                else:\n                    value = args.pop(0)\n            opt = opt.replace(\"-\", \"_\")\n            result[opt] = loads(value)\n        else:\n            secho(f\"{err}: doesn't support shorthands\", fg=colors.RED)\n            exit(1)\n    return result\n</code></pre>"},{"location":"reference/config/","title":"<code>confit.config</code>","text":""},{"location":"reference/config/#confit.config.Config","title":"<code>Config</code>","text":"<p>           Bases: <code>dict</code></p> <p>The configuration system consists of a supercharged dict, the <code>Config</code> class, that can be used to read and write to <code>cfg</code> files, interpolate variables and instantiate components through the registry with some special <code>@factory</code> keys. A cfg file can be used directly as an input to a CLI-decorated function.</p> <p>A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time.</p>"},{"location":"reference/config/#confit.config.Config--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>args</code> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>confit/config.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any):\n    \"\"\"\n    A new config object can be instantiated either from a dict as a positional\n    argument, or from keyword arguments. Only one of these two options can be\n    used at a time.\n\n    Parameters\n    ----------\n    args: Any\n    kwargs: Any\n    \"\"\"\n    if len(args) == 1 and isinstance(args[0], dict):\n        assert len(kwargs) == 0\n        kwargs = args[0]\n    super().__init__(kwargs)\n</code></pre>"},{"location":"reference/config/#confit.config.Config.from_cfg_str","title":"<code>from_cfg_str</code>  <code>classmethod</code>","text":"<p>Load a config object from a config string</p>"},{"location":"reference/config/#confit.config.Config.from_cfg_str--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>s</code> <p>The cfg config string</p> <p> TYPE: <code>str</code> </p> <code>resolve</code> <p>Whether to resolve sections with '@' keys</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>registry</code> <p>Optional registry to resolve from. If None, the default registry will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Config</code> Source code in <code>confit/config.py</code> <pre><code>@classmethod\ndef from_cfg_str(cls, s: str, resolve: bool = False, registry: Any = None) -&gt; Any:\n    \"\"\"\n    Load a config object from a config string\n\n    Parameters\n    ----------\n    s: Union[str, Path]\n        The cfg config string\n    resolve\n        Whether to resolve sections with '@' keys\n    registry\n        Optional registry to resolve from.\n        If None, the default registry will be used.\n\n    Returns\n    -------\n    Config\n    \"\"\"\n    parser = ConfigParser(interpolation=None)\n    parser.optionxform = str\n    parser.read_string(s)\n\n    config = Config()\n\n    for section in parser.sections():\n        parts = split_path(section)\n        current = config\n        for part in parts:\n            if part not in current:\n                current[part] = current = Config()\n            else:\n                current = current[part]\n\n        current.clear()\n        errors = []\n        for k, v in parser.items(section):\n            parsed_k = loads(k)\n            try:\n                current[parsed_k] = loads(v)\n            except ValueError as e:\n                errors.append(ErrorWrapper(e, loc=parsed_k))\n\n        if errors:\n            raise ConfitValidationError(errors=errors)\n\n    if resolve:\n        return config.resolve(registry=registry)\n\n    return config\n</code></pre>"},{"location":"reference/config/#confit.config.Config.from_disk","title":"<code>from_disk</code>  <code>classmethod</code>","text":"<p>Load a config object from a '.cfg' file</p>"},{"location":"reference/config/#confit.config.Config.from_disk--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p>The path to the config object</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>resolve</code> <p>Whether to resolve mappings with '@' keys</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>registry</code> <p>Optional registry to resolve from. If None, the default registry will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Config</code> Source code in <code>confit/config.py</code> <pre><code>@classmethod\ndef from_disk(\n    cls, path: Union[str, Path], resolve: bool = False, registry: Any = None\n) -&gt; \"Config\":\n    \"\"\"\n    Load a config object from a '.cfg' file\n\n    Parameters\n    ----------\n    path: Union[str, Path]\n        The path to the config object\n    resolve\n        Whether to resolve mappings with '@' keys\n    registry\n        Optional registry to resolve from.\n        If None, the default registry will be used.\n\n    Returns\n    -------\n    Config\n    \"\"\"\n    s = Path(path).read_text(encoding=\"utf-8\")\n    path_str = str(path)\n    if path_str.endswith(\".yaml\") or path_str.endswith(\".yml\"):\n        return cls.from_yaml_str(s, resolve=resolve, registry=registry)\n    else:\n        return cls.from_cfg_str(s, resolve=resolve, registry=registry)\n</code></pre>"},{"location":"reference/config/#confit.config.Config.to_disk","title":"<code>to_disk</code>","text":"<p>Export a config to the disk (usually to a .cfg file)</p>"},{"location":"reference/config/#confit.config.Config.to_disk--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>Union[str, Path]</code> </p> Source code in <code>confit/config.py</code> <pre><code>def to_disk(self, path: Union[str, Path]):\n    \"\"\"\n    Export a config to the disk (usually to a .cfg file)\n\n    Parameters\n    ----------\n    path: Union[str, path]\n    \"\"\"\n    path_str = str(path)\n    if path_str.endswith(\".yaml\") or path_str.endswith(\".yml\"):\n        s = self.to_yaml_str()\n    else:\n        s = Config.to_str(self)\n    Path(path).write_text(s, encoding=\"utf-8\")\n</code></pre>"},{"location":"reference/config/#confit.config.Config.serialize","title":"<code>serialize</code>","text":"<p>Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form</p> <p>We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree.</p> <pre><code>a = A()  # serializable object\ncfg = {\"a\": a, \"b\": a}\nprint(Config.serialize(cfg))\n# Out: {\"a\": {...}, \"b\": Reference(\"a\")}\n</code></pre> RETURNS DESCRIPTION <code>Config</code> Source code in <code>confit/config.py</code> <pre><code>def serialize(self: Any):\n    \"\"\"\n    Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object\n    back to their original catalogue + params form\n\n    We try to preserve referential equalities between non dict/list/tuple\n    objects by serializing subsequent references to the same object as references\n    to its first occurrence in the tree.\n\n    ```python\n    a = A()  # serializable object\n    cfg = {\"a\": a, \"b\": a}\n    print(Config.serialize(cfg))\n    # Out: {\"a\": {...}, \"b\": Reference(\"a\")}\n    ```\n\n    Returns\n    -------\n    Config\n    \"\"\"\n    refs = {}\n\n    # Temp memory to avoid objects being garbage collected\n    mem = []\n\n    def is_simple(o):\n        return o is None or isinstance(o, (str, int, float, bool, Reference))\n\n    def rec(o: Any, path: Loc = ()):\n        if id(o) in refs:\n            return refs[id(o)]\n        if is_simple(o):\n            return o\n        if isinstance(o, collections.abc.Mapping):\n            items = sorted(\n                o.items(),\n                key=lambda x: 1\n                if (\n                    is_simple(x[1])\n                    or isinstance(x[1], (collections.abc.Mapping, list, tuple))\n                )\n                else 0,\n            )\n            serialized = {k: rec(v, (*path, k)) for k, v in items}\n            serialized = {k: serialized[k] for k in o.keys()}\n            mem.append(o)\n            refs[id(o)] = Reference(join_path(path))\n            if isinstance(o, Config):\n                serialized = Config(serialized)\n            return serialized\n        if isinstance(o, (list, tuple)):\n            mem.append(o)\n            refs[id(o)] = Reference(join_path(path))\n            return type(o)(rec(v, (*path, i)) for i, v in enumerate(o))\n        cfg = None\n        try:\n            cfg = (cfg or Config()).merge(RESOLVED_TO_CONFIG[o])\n        except (KeyError, TypeError):\n            pass\n        try:\n            cfg = (cfg or Config()).merge(o.cfg)\n        except (AttributeError, TypeError):\n            pass\n        if cfg is not None:\n            mem.append(o)\n            refs[id(o)] = Reference(join_path(path))\n            return rec(cfg, path)\n        try:\n            return pydantic_core.to_jsonable_python(o)\n        except Exception:\n            raise TypeError(f\"Cannot dump {o!r} at {join_path(path)}\")\n\n    return rec(self)\n</code></pre>"},{"location":"reference/config/#confit.config.Config.to_cfg_str","title":"<code>to_cfg_str</code>","text":"<p>Export a config to a string in the cfg format by serializing it first</p> RETURNS DESCRIPTION <code>str</code> Source code in <code>confit/config.py</code> <pre><code>def to_cfg_str(self):\n    \"\"\"\n    Export a config to a string in the cfg format\n    by serializing it first\n\n    Returns\n    -------\n    str\n    \"\"\"\n    additional_sections = {}\n\n    prepared = flatten_sections(Config.serialize(self))\n    prepared.update(flatten_sections(additional_sections))\n\n    parser = ConfigParser(interpolation=None)\n    parser.optionxform = str\n    for section_name, section in prepared.items():\n        parser.add_section(section_name)\n        parser[section_name].update(\n            {join_path((k,)): dumps(v) for k, v in section.items()}\n        )\n    s = StringIO()\n    parser.write(s)\n    return s.getvalue()\n</code></pre>"},{"location":"reference/config/#confit.config.Config.resolve","title":"<code>resolve</code>","text":"<p>Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config.</p>"},{"location":"reference/config/#confit.config.Config.resolve--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>deep</code> <p>Should we resolve deeply</p> <p> DEFAULT: <code>True</code> </p> <code>registry</code> <p>Registry to use when resolving</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>root</code> <p>The root of the config tree. Used for resolving references.</p> <p> TYPE: <code>Mapping</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[Config, Any]</code> Source code in <code>confit/config.py</code> <pre><code>def resolve(self, deep=True, registry: Any = None, root: Mapping = None) -&gt; Any:\n    \"\"\"\n    Resolves the parts of the nested config object with @ variables using\n    a registry, and then interpolate references in the config.\n\n    Parameters\n    ----------\n    deep: bool\n        Should we resolve deeply\n    registry:\n        Registry to use when resolving\n    root: Mapping\n        The root of the config tree. Used for resolving references.\n\n    Returns\n    -------\n    Union[Config, Any]\n    \"\"\"\n    if root is None:\n        root = self\n\n    if registry is None:\n        from .registry import get_default_registry\n\n        registry = get_default_registry()\n    resolved_locs = {}\n    seen_locs = set()\n\n    def resolve_reference(ref: Reference) -&gt; Any:\n        pat = re.compile(PATH + \":?\")\n\n        def replace(match: re.Match):\n            start = match.start()\n            if start &gt; 0 and ref.value[start - 1] == \":\":\n                return match.group()\n\n            path = match.group()\n            parts = split_path(path.rstrip(\":\"))\n\n            # Check if part is any special python keyword\n            if len(parts) == 1 and parts[0] in keyword.kwlist:\n                return match.group()\n            try:\n                return local_names[parts] + (\".\" if path.endswith(\":\") else \"\")\n            except KeyError:\n                raise KeyError(path)\n\n        local_names = {}\n        for match in pat.finditer(ref.value):\n            start = match.start()\n            if start &gt; 0 and ref.value[start - 1] == \":\":\n                continue\n            path = match.group()\n            parts = split_path(path.rstrip(\":\"))\n            if len(parts) == 1 and parts[0] in keyword.kwlist:\n                continue\n            local_names.setdefault(parts, f\"var_{len(local_names)}\")\n\n        local_leaves = DynamicLocals(local_names, root, resolved_locs, rec)\n\n        replaced = pat.sub(replace, ref.value)\n\n        res = safe_eval(replaced, local_leaves)\n\n        return res\n\n    def rec(obj, loc: Tuple[Union[str, int]] = ()):\n        \"\"\"\n        Parameters\n        ----------\n        obj: Any\n            The current object being resolved\n        loc: Sequence[str]\n            Internal variable\n            Current path in tree\n\n        Returns\n        -------\n\n        \"\"\"\n        if id(obj) in resolved_locs:\n            return resolved_locs[id(obj)]\n\n        if id(obj) in seen_locs:\n            raise CyclicReferenceError(tuple(loc))\n\n        seen_locs.add(id(obj))\n\n        if not deep and len(loc) &gt; 1:\n            return obj\n\n        if isinstance(obj, Mapping):\n            resolved = Config({k: rec(v, (*loc, k)) for k, v in obj.items()})\n\n            registries = [\n                (key, value, getattr(registry, key[1:]))\n                for key, value in resolved.items()\n                if isinstance(key, str) and key.startswith(\"@\")\n            ]\n            assert (\n                len(registries) &lt;= 1\n            ), f\"Cannot resolve using multiple registries at {'.'.join(loc)}\"\n\n            if len(registries) == 1:\n                raw_key, value, registry_value = registries[0]\n                cfg = resolved\n                params = dict(resolved)\n                params.pop(raw_key)\n                value = value.strip()\n                is_draft = value.endswith(\"!draft\")\n                if is_draft:\n                    value = value[:-len(\"!draft\")].strip()\n                fn = registry_value.get(value)\n                try:\n                    if is_draft:\n                        resolved = Draft(fn, params)\n                    else:\n                        resolved = fn(**params)\n                    # The `validate_arguments` decorator has most likely\n                    # already put the resolved config in the registry\n                    # but for components that are instantiated without it\n                    # we need to do it here\n                    Config._store_resolved(resolved, cfg)\n                except ConfitValidationError as e:\n                    e = ConfitValidationError(\n                        errors=patch_errors(e.raw_errors, loc, params),\n                        model=e.model,\n                        name=getattr(e, \"name\", None),\n                    ).with_traceback(remove_lib_from_traceback(e.__traceback__))\n                    if not is_debug():\n                        e.__cause__ = None\n                        e.__suppress_context__ = True\n                    raise e\n\n        elif isinstance(obj, list):\n            resolved = [rec(v, (*loc, i)) for i, v in enumerate(obj)]\n        elif isinstance(obj, tuple):\n            resolved = tuple(rec(v, (*loc, i)) for i, v in enumerate(obj))\n        elif isinstance(obj, Reference):\n            while True:\n                try:\n                    resolved = resolve_reference(obj)\n                    break\n                except (KeyError, NameError):\n                    raise MissingReference(obj)\n        else:\n            resolved = obj\n\n        resolved_locs[id(obj)] = resolved\n\n        return resolved\n\n    return rec(self, ())\n</code></pre>"},{"location":"reference/config/#confit.config.Config.merge","title":"<code>merge</code>","text":"<p>Deep merge two configs. Heavily inspired from <code>thinc</code>'s config merge function.</p>"},{"location":"reference/config/#confit.config.Config.merge--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>updates</code> <p>Configs to update the original config</p> <p> TYPE: <code>Union[Dict[str, Any], Config]</code> DEFAULT: <code>()</code> </p> <code>remove_extra</code> <p>If true, restricts update to keys that existed in the original config</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>The new config</code> Source code in <code>confit/config.py</code> <pre><code>def merge(\n    self,\n    *updates: Union[Dict[str, Any], \"Config\"],\n    remove_extra: bool = False,\n) -&gt; \"Config\":\n    \"\"\"\n    Deep merge two configs. Heavily inspired from `thinc`'s config merge function.\n\n    Parameters\n    ----------\n    updates: Union[Config, Dict]\n        Configs to update the original config\n    remove_extra:\n        If true, restricts update to keys that existed in the original config\n\n    Returns\n    -------\n    The new config\n    \"\"\"\n\n    def deep_set(current, path, val):\n        if path not in current and remove_extra:\n            return\n        current[path] = val\n\n    def rec(old, new):\n        for key, new_val in list(new.items()):\n            if \".\" in key:\n                deep_set(old, key, new_val)\n                continue\n\n            if key not in old:\n                if remove_extra:\n                    continue\n                else:\n                    old[key] = new_val\n                    continue\n\n            old_val = old[key]\n            if isinstance(old_val, dict) and isinstance(new_val, dict):\n                old_resolver = next(\n                    (\n                        k\n                        for k in old_val\n                        if isinstance(key, str) and k.startswith(\"@\")\n                    ),\n                    None,\n                )\n                new_resolver = next(\n                    (\n                        k\n                        for k in new_val\n                        if isinstance(key, str) and k.startswith(\"@\")\n                    ),\n                    None,\n                )\n                if (\n                    new_resolver is not None\n                    and old_resolver is not None\n                    and (\n                        old_resolver != new_resolver\n                        or old_val.get(old_resolver) != new_val.get(new_resolver)\n                    )\n                ):\n                    old[key] = new_val\n                else:\n                    rec(old[key], new_val)\n            else:\n                old[key] = new_val\n        return old\n\n    config = self.copy()\n    for u in updates:\n        rec(config, u)\n    return config\n</code></pre>"},{"location":"reference/config/#confit.config.Config.copy","title":"<code>copy</code>","text":"<p>Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.)</p> <pre><code>Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}]\n</code></pre> RETURNS DESCRIPTION <code>Any</code> Source code in <code>confit/config.py</code> <pre><code>def copy(self: T) -&gt; T:\n    \"\"\"\n    Deep copy of the config, but not of the underlying data.\n    Should also work with other types of objects (e.g. lists, tuples, etc.)\n\n    ```\n    Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}]\n    ```\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    seen = {}\n\n    def rec(obj):\n        if id(obj) in seen:\n            return seen[id(obj)]\n        seen[id(obj)] = obj\n        if isinstance(obj, (Config, dict)):\n            return type(obj)(\n                {k: rec(v) for k, v in obj.items()},\n            )\n        elif isinstance(obj, list):\n            return [rec(v) for v in obj]\n        elif isinstance(obj, tuple):\n            return tuple(rec(v) for v in obj)\n        elif isinstance(obj, Reference):\n            return Reference(obj.value)\n        else:\n            return obj\n\n    copy = rec(self)\n    return copy\n</code></pre>"},{"location":"reference/config/#confit.config.merge_from_disk","title":"<code>merge_from_disk</code>","text":"<p>Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config</p>"},{"location":"reference/config/#confit.config.merge_from_disk--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>config_paths</code> <p>Paths to the config files</p> <p> TYPE: <code>Union[Path, List[Path]]</code> </p> <code>returned_name</code> <p>If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign</p> <p> TYPE: <code>str</code> DEFAULT: <code>'first'</code> </p> Source code in <code>confit/config.py</code> <pre><code>def merge_from_disk(\n    config_paths: Union[Path, List[Path]],\n    returned_name: str = \"first\",\n):\n    \"\"\"\n    Merge multiple configs loaded from the filesystem\n    and return the merged config as well as the name of the config\n\n    Parameters\n    ----------\n    config_paths: Union[Path, List[Path]]\n        Paths to the config files\n    returned_name: str\n        If \"first\", the name of the first config is returned as the name of the merged\n        config. If \"concat\", the names of the configs are concatenated with a \"+\" sign\n\n    Returns\n    -------\n\n    \"\"\"\n    assert returned_name in {\"first\", \"concat\"}\n    if isinstance(config_paths, Path):\n        config_paths = [config_paths]\n\n    configs = [Config.from_disk(p, resolve=False) for p in config_paths]\n    config_names = [p.stem for p in config_paths]\n\n    name = config_names[0] if returned_name == \"first\" else \"+\".join(config_names)\n\n    config = configs.pop(0)\n    return config.merge(*configs), name\n</code></pre>"},{"location":"reference/draft/","title":"<code>confit.draft</code>","text":""},{"location":"reference/draft/#confit.draft.MetaDraft","title":"<code>MetaDraft</code>","text":"<p>           Bases: <code>type</code></p> <p>A metaclass for Draft that allows the user to create specify the type the Draft should become when instantiated.</p> <p>In addition to allowing static typing, this metaclass also provides a way to validate the Draft object when used in combination with pydantic validation.</p>"},{"location":"reference/draft/#confit.draft.MetaDraft--examples","title":"Examples","text":"<pre><code>from confit import Draft\n\n\n@validate_arguments\ndef make_hi(name, prefix) -&gt; str:\n    return prefix + \" \" + name\n\n\n@validate_arguments\ndef print_hi(param: Draft[str]):\n    val = param.instantiate(prefix=\"Hello\")\n    print(val)\n\n\nprint_hi(make_hi.draft(name=\"John\"))\n</code></pre> Source code in <code>confit/draft.py</code> <pre><code>def __init__(cls, name, bases, dct):\n    super().__init__(name, bases, dct)\n    cls.type_ = Any\n</code></pre>"},{"location":"reference/draft/#confit.draft.Draft","title":"<code>Draft</code>","text":"<p>           Bases: <code>Generic[R]</code></p> <p>A Draft is a placeholder for a value that has not been instantiated yet, likely because it is missing an argument that will be provided later by the library.</p> Source code in <code>confit/draft.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[P, R],\n    kwargs: Dict[str, Any],\n):\n    self._func = func\n    self._kwargs = kwargs\n</code></pre>"},{"location":"reference/draft/#confit.draft.Draft.instantiate","title":"<code>instantiate</code>","text":"<p>Finalize the Draft object into an instance of the expected type using the provided arguments. The new arguments are merged with the existing ones, with the old ones taking precedence. The rationale for this is that the user makes the Draft, and the library completes any missing arguments.</p> Source code in <code>confit/draft.py</code> <pre><code>def instantiate(self, **kwargs) -&gt; R:\n    \"\"\"\n    Finalize the Draft object into an instance of the expected type\n    using the provided arguments. The new arguments are merged with the\n    existing ones, with the old ones taking precedence. The rationale\n    for this is that the user makes the Draft, and the library\n    completes any missing arguments.\n    \"\"\"\n    if not isinstance(self, Draft):\n        return self\n\n    # Order matters: priority is given to the kwargs provided\n    # by the user, so most likely when the Partial is instantiated\n    res = self._func(**{**kwargs, **self._kwargs})\n    return res\n</code></pre>"},{"location":"reference/errors/","title":"<code>confit.errors</code>","text":""},{"location":"reference/errors/#confit.errors.MissingReference","title":"<code>MissingReference</code>","text":"<p>           Bases: <code>Exception</code></p> <p>Raised when one or multiple references cannot be resolved.</p>"},{"location":"reference/errors/#confit.errors.MissingReference--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>ref</code> <p>The reference that could not be resolved.</p> <p> TYPE: <code>Reference</code> </p> Source code in <code>confit/errors.py</code> <pre><code>def __init__(self, ref: Reference):\n    \"\"\"\n    Parameters\n    ----------\n    ref: Reference\n        The reference that could not be resolved.\n    \"\"\"\n    self.ref = ref\n    super().__init__()\n</code></pre>"},{"location":"reference/errors/#confit.errors.MissingReference.__str__","title":"<code>__str__</code>","text":"<p>String representation of the exception</p> Source code in <code>confit/errors.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    String representation of the exception\n    \"\"\"\n    return \"Could not interpolate the following reference: {}\".format(self.ref)\n</code></pre>"},{"location":"reference/errors/#confit.errors.CyclicReferenceError","title":"<code>CyclicReferenceError</code>","text":"<p>           Bases: <code>Exception</code></p> <p>Raised when a cyclic reference is detected.</p>"},{"location":"reference/errors/#confit.errors.CyclicReferenceError--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p>The path of the cyclic reference</p> <p> TYPE: <code>Loc</code> </p> Source code in <code>confit/errors.py</code> <pre><code>def __init__(self, path: Loc):\n    \"\"\"\n    Parameters\n    ----------\n    path: Loc\n        The path of the cyclic reference\n    \"\"\"\n    self.path = path\n    super().__init__()\n</code></pre>"},{"location":"reference/errors/#confit.errors.CyclicReferenceError.__str__","title":"<code>__str__</code>","text":"<p>String representation of the exception</p> Source code in <code>confit/errors.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    String representation of the exception\n    \"\"\"\n    return \"Cyclic reference detected at {}\".format(join_path(self.path))\n</code></pre>"},{"location":"reference/errors/#confit.errors.remove_lib_from_traceback","title":"<code>remove_lib_from_traceback</code>","text":"<p>Remove the lib folder from the traceback</p> Source code in <code>confit/errors.py</code> <pre><code>def remove_lib_from_traceback(tb):\n    \"\"\"\n    Remove the lib folder from the traceback\n    \"\"\"\n    # compare package to module in f_globals\n    if is_debug():\n        return tb\n    if tb is not None and tb.tb_frame.f_globals.get(\"__package__\") == __package__:\n        return remove_lib_from_traceback(tb.tb_next)\n    if tb is None or tb.tb_next is None:\n        return tb\n    tb.tb_next = remove_lib_from_traceback(tb.tb_next)\n    return tb\n</code></pre>"},{"location":"reference/errors/#confit.errors.to_legacy_error","title":"<code>to_legacy_error</code>","text":"<p>Decorator to convert a Pydantic ValidationError into a ConfitValidationError</p> Source code in <code>confit/errors.py</code> <pre><code>def to_legacy_error(err: pydantic.ValidationError, model: Any) -&gt; LegacyValidationError:\n    \"\"\"\n    Decorator to convert a Pydantic ValidationError into a ConfitValidationError\n    \"\"\"\n    if isinstance(err, LegacyValidationError):\n        return err\n    errors = err.errors(include_url=False)\n    raw_errors = []\n    for err in errors:\n        try:\n            vrepr = repr(err[\"input\"])\n        except Exception:  # pragma: no cover\n            vrepr = object.__repr__(err[\"input\"])\n        vrepr = vrepr[:50] + \"...\" if len(vrepr) &gt; 50 else vrepr\n        err = dict(err)\n        msg = err.pop(\"msg\", \"\")\n        msg = (msg[0].lower() + msg[1:]) if msg else msg\n        raw_errors.append(\n            ErrorWrapper(\n                exc=err[\"ctx\"][\"error\"]\n                if \"ctx\" in err\n                and \"error\" in err[\"ctx\"]\n                and isinstance(err[\"ctx\"][\"error\"], BaseException)\n                else PydanticNewStyleError(\n                    **err,\n                    msg=msg,\n                    actual_value=vrepr,\n                    actual_type=type(err[\"input\"]).__name__,\n                ),\n                loc=err[\"loc\"],\n            )\n        )\n    return ConfitValidationError(raw_errors, model=model)\n</code></pre>"},{"location":"reference/errors/#confit.errors.patch_errors","title":"<code>patch_errors</code>","text":"<p>Patch the location of the errors to add the <code>path</code> prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config.</p>"},{"location":"reference/errors/#confit.errors.patch_errors--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>errors</code> <p>The pydantic errors to patch</p> <p> TYPE: <code>T</code> </p> <code>path</code> <p>The path to add to the errors</p> <p> TYPE: <code>Loc</code> DEFAULT: <code>()</code> </p> <code>values</code> <p>The values of the config</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>special_names</code> <p>The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>model</code> <p>The model of the config</p> <p> TYPE: <code>Optional[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>drop_names</code> <p>The names of the keys to drop from the error path</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Union[ValidationError, Sequence[ErrorWrapper], ErrorWrapper]</code> <p>The patched errors</p> Source code in <code>confit/errors.py</code> <pre><code>def patch_errors(\n    errors: T,\n    path: Loc = (),\n    values: Dict = None,\n    model: Optional[pydantic.BaseModel] = None,\n    special_names: Sequence[str] = (),\n    drop_names: Sequence[str] = (),\n) -&gt; T:\n    \"\"\"\n    Patch the location of the errors to add the `path` prefix and complete\n    the errors with the actual value if it is available.\n    This is useful when the errors are raised in a sub-dict of the config.\n\n    Parameters\n    ----------\n    errors: Union[LegacyValidationError, Sequence[ErrorWrapper], ErrorWrapper]\n        The pydantic errors to patch\n    path: Loc\n        The path to add to the errors\n    values: Dict\n        The values of the config\n    special_names: Sequence[str]\n        The names of the special keys of the model signature, to replace with a wildcard\n        when encountered in the error path\n    model: Optional[pydantic.BaseModel]\n        The model of the config\n    drop_names: Sequence[str]\n        The names of the keys to drop from the error path\n\n    Returns\n    -------\n    Union[LegacyValidationError, Sequence[ErrorWrapper], ErrorWrapper]\n        The patched errors\n    \"\"\"\n    if isinstance(errors, pydantic.ValidationError):\n        errors = to_legacy_error(errors, model).raw_errors\n        errors = patch_errors(errors, path, values, model, special_names, drop_names)\n        return ConfitValidationError(errors, model=model)\n    if isinstance(errors, list):\n        res = []\n        for error in errors:\n            res.extend(\n                patch_errors(error, path, values, model, special_names, drop_names)\n            )\n        return res\n    if isinstance(errors, ErrorWrapper) and isinstance(\n        errors.exc, LegacyValidationError\n    ):\n        try:\n            field_model = model\n            for part in errors.loc_tuple():\n                # if not issubclass(field_model, pydantic.BaseModel) and issubclass(\n                #     field_model.vd.model, pydantic.BaseModel\n                # ):\n                #     field_model = field_model.vd.model\n                if PYDANTIC_V1:\n                    field_model = field_model.__fields__[part]\n                else:\n                    field_model = field_model.model_fields[part]\n                if PYDANTIC_V1:\n                    field_model = field_model.type_\n                else:\n                    field_model = field_model.annotation\n            if (\n                field_model is errors.exc.model\n                or field_model.vd.model is errors.exc.model\n            ):\n                return patch_errors(\n                    errors.exc.raw_errors,\n                    (*path, *errors.loc_tuple()),\n                    values,\n                    model,\n                    special_names,\n                    drop_names,\n                )\n        except (KeyError, AttributeError):  # pragma: no cover\n            print(\"Could not find model for\", errors.loc_tuple())\n\n    if (\n        isinstance(errors.exc, PydanticErrorMixin)\n        and values is not None\n        and errors.loc_tuple()\n        and errors.loc_tuple()[0] in values\n    ):\n        if \"actual_value\" not in errors.exc.__dict__:\n            actual_value = values\n            for key in errors.loc_tuple():\n                actual_value = actual_value[key]\n            vrepr = repr(actual_value)\n            errors.exc.actual_value = vrepr[:50] + \"...\" if len(vrepr) &gt; 50 else vrepr\n            errors.exc.actual_type = type(actual_value).__name__\n\n        cls = errors.exc.__class__\n        if cls not in PATCHED_ERRORS_CLS:\n\n            def error_str(self):\n                s = cls.__str__(self)\n                s = (\n                    s + f\", got {self.actual_value} ({self.actual_type})\"\n                    if hasattr(self, \"actual_value\")\n                    else s\n                )\n                return s\n\n            new_cls = type(\n                cls.__name__,\n                (cls,),\n                {\n                    \"msg_template\": cls.msg_template\n                    + \", got {actual_value} ({actual_type})\"\n                }\n                if hasattr(cls, \"msg_template\")\n                else {\n                    \"__str__\": error_str,\n                },\n            )\n            PATCHED_ERRORS_CLS[cls] = new_cls\n            PATCHED_ERRORS_CLS[new_cls] = new_cls\n        errors.exc.__class__ = PATCHED_ERRORS_CLS[cls]\n\n    if (\n        isinstance(errors.exc, TypeError)\n        and str(errors.exc).startswith(\"unexpected keyword argument\")\n        and \":\" in errors.exc.args[0]\n    ):\n        extra_keys = errors.exc.args[0].split(\": \")[1].split(\", \")\n        return [\n            ErrorWrapper(\n                TypeError(\"unexpected keyword argument\"),\n                (*path, *errors.loc_tuple()[:-1], key.strip(\"'\")),\n            )\n            for key in extra_keys\n        ]\n\n    loc_tuple = errors.loc_tuple()\n    if loc_tuple and loc_tuple[-1] in special_names:\n        loc_tuple = (*loc_tuple[:-1], \"[signature]\")\n    loc_tuple = tuple(part for part in loc_tuple if part not in drop_names)\n\n    return [\n        ErrorWrapper(\n            errors.exc,\n            (*path, *loc_tuple),\n        )\n    ]\n</code></pre>"},{"location":"reference/registry/","title":"<code>confit.registry</code>","text":""},{"location":"reference/registry/#confit.registry.VisibleDeprecationWarning","title":"<code>VisibleDeprecationWarning</code>","text":"<p>           Bases: <code>UserWarning</code></p> <p>Visible deprecation warning.</p> <p>By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug.</p> <p>Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51</p>"},{"location":"reference/registry/#confit.registry.Registry","title":"<code>Registry</code>","text":"<p>           Bases: <code>Registry</code></p> <p>A registry that validates the input arguments of the registered functions.</p> <p>Initialize the registry.</p>"},{"location":"reference/registry/#confit.registry.Registry--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>namespace</code> <p>The namespace of the registry</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>entry_points</code> <p>Should we use entry points to load the registered functions</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>confit/registry.py</code> <pre><code>def __init__(self, namespace: Sequence[str], entry_points: bool = False) -&gt; None:\n    \"\"\"\n    Initialize the registry.\n\n    Parameters\n    ----------\n    namespace: Sequence[str]\n        The namespace of the registry\n    entry_points: bool\n        Should we use entry points to load the registered functions\n    \"\"\"\n    super().__init__(namespace, entry_points=entry_points)\n    self.registry = None\n</code></pre>"},{"location":"reference/registry/#confit.registry.Registry.register","title":"<code>register</code>","text":"<p>This is a convenience wrapper around <code>catalogue.Registry.register</code>, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments.</p>"},{"location":"reference/registry/#confit.registry.Registry.register--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>name</code> <p>The name of the function</p> <p> TYPE: <code>str</code> </p> <code>func</code> <p>The function to register</p> <p> TYPE: <code>Optional[Union[Callable[P, R], Type[R]]]</code> DEFAULT: <code>None</code> </p> <code>save_params</code> <p>Additional parameters to save when the function is called. If falsy, the function parameters are not saved</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>skip_save_params</code> <p>List of parameters to skip when saving the function parameters</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>invoker</code> <p>An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>deprecated</code> <p>The deprecated registry names for the function</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> Source code in <code>confit/registry.py</code> <pre><code>def register(\n    self,\n    name: str,\n    *,\n    func: Optional[Union[Callable[P, R], Type[R]]] = None,\n    save_params: Optional[Dict[str, Any]] = None,\n    skip_save_params: Sequence[str] = (),\n    invoker: Optional[Callable] = None,\n    deprecated: Sequence[str] = (),\n) -&gt; Callable[[Callable[P, R]], Union[Callable[P, R], Draftable[R, P]]]:\n    \"\"\"\n    This is a convenience wrapper around `catalogue.Registry.register`, that\n    additionally validates the input arguments of the registered function and\n    saves the result of any call to a mapping to its arguments.\n\n    Parameters\n    ----------\n    name:\n        The name of the function\n    func:\n        The function to register\n    save_params:\n        Additional parameters to save when the function is called. If falsy,\n        the function parameters are not saved\n    skip_save_params:\n        List of parameters to skip when saving the function parameters\n    invoker:\n        An optional invoker to apply to the function before registering it.\n        It is better to use this than to apply the invoker to the function\n        to preserve the signature of the function or the class and enable\n        validating its parameters.\n    deprecated:\n        The deprecated registry names for the function\n    \"\"\"\n    registerer = super().register\n\n    save_params = save_params or {f\"@{self.namespace[-1]}\": name}\n\n    def invoke(func, params):\n        resolved = invoker(func, params) if invoker is not None else func(params)\n        if save_params is not None:\n            params_to_save = {**save_params, **params}\n            for name in skip_save_params:\n                params_to_save.pop(name, None)\n            Config._store_resolved(resolved, params_to_save)\n        return resolved\n\n    def wrap_and_register(fn: Callable[P, R]) -&gt; Draftable[P, R]:\n        if save_params is not None:\n            _check_signature_for_save_params(\n                fn if not isinstance(fn, type) else fn.__init__\n            )\n\n        validated_fn = validate_arguments(\n            fn,\n            config={\"arbitrary_types_allowed\": True},\n            registry=getattr(self, \"registry\", None),\n            invoker=invoke,\n        )\n\n        registerer(name)(validated_fn)\n\n        for deprecated_name in deprecated:\n\n            def make_deprecated_fn(old):\n                @wraps(fn)\n                def deprecated_fn(*args, **kwargs):\n                    warnings.warn(\n                        f'\"{old}\" is deprecated, please use \"{name}\" instead.\"',\n                        VisibleDeprecationWarning,\n                    )\n                    return validated_fn(*args, **kwargs)\n\n                return deprecated_fn\n\n            registerer(deprecated_name)(make_deprecated_fn(deprecated_name))\n\n        return validated_fn\n\n    if func is not None:\n        return wrap_and_register(func)\n    else:\n        return wrap_and_register\n</code></pre>"},{"location":"reference/registry/#confit.registry.Registry.get_entry_points","title":"<code>get_entry_points</code>","text":"<p>Get registered entry points from other packages for this namespace.</p> <p>RETURNS (Dict[str, Any]): Entry points, keyed by name.</p> Source code in <code>confit/registry.py</code> <pre><code>def get_entry_points(self):\n    \"\"\"Get registered entry points from other packages for this namespace.\n\n    RETURNS (Dict[str, Any]): Entry points, keyed by name.\n    \"\"\"\n    entrypoints = importlib_metadata.entry_points()\n    if hasattr(entrypoints, \"select\"):\n        return entrypoints.select(group=self.entry_point_namespace)\n    else:  # dict\n        return entrypoints.get(self.entry_point_namespace, [])\n</code></pre>"},{"location":"reference/registry/#confit.registry.Registry.get","title":"<code>get</code>","text":"<p>Get the registered function for a given name.</p> <p>Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points.</p>"},{"location":"reference/registry/#confit.registry.Registry.get--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>name</code> <p>The name of the function</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Func</code> Source code in <code>confit/registry.py</code> <pre><code>def get(self, name: str):\n    \"\"\"\n    Get the registered function for a given name.\n\n    Modified from catalogue.Registry.get to avoid importing\n    all entry points when lookup fails, but rather list the\n    available entry points.\n\n    Parameters\n    ----------\n    name: str\n        The name of the function\n\n    Returns\n    -------\n    Func\n    \"\"\"\n    path = list(self.namespace) + [name]\n    try:\n        return catalogue._get(path)\n    except catalogue.RegistryError:\n        if self.entry_points:\n            from_entry_point = self.get_entry_point(name)\n            if catalogue.check_exists(*path):\n                return catalogue._get(path)\n            elif from_entry_point:\n                return from_entry_point\n        if not catalogue.check_exists(*path):\n            raise catalogue.RegistryError(\n                f\"Can't find '{name}' in registry {' -&gt; '.join(self.namespace)}. \"\n                f\"Available names: \"\n                f\"{', '.join(sorted(self.get_available())) or 'none'}\"\n            )\n        return catalogue._get(path)\n</code></pre>"},{"location":"reference/registry/#confit.registry.Registry.get_available","title":"<code>get_available</code>","text":"<p>Get all functions for a given namespace.</p> <p>namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name.</p> Source code in <code>confit/registry.py</code> <pre><code>def get_available(self) -&gt; Sequence[str]:\n    \"\"\"Get all functions for a given namespace.\n\n    namespace (Tuple[str]): The namespace to get.\n    RETURNS (Dict[str, Any]): The functions, keyed by name.\n    \"\"\"\n    result = set()\n    if self.entry_points:\n        result.update({p.name for p in self._get_entry_points()})\n    for keys in catalogue.REGISTRY.copy().keys():\n        if len(self.namespace) == len(keys) - 1 and all(\n            self.namespace[i] == keys[i] for i in range(len(self.namespace))\n        ):\n            result.add(keys[-1])\n    return sorted(result)\n</code></pre>"},{"location":"reference/registry/#confit.registry.MetaRegistryCollection","title":"<code>MetaRegistryCollection</code>","text":"<p>           Bases: <code>type</code></p> <p>A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class.</p> <p>Initialize the registry collection by adding it-self as the registry collection of all registries.</p>"},{"location":"reference/registry/#confit.registry.MetaRegistryCollection--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>name</code> <code>bases</code> <code>dct</code> Source code in <code>confit/registry.py</code> <pre><code>def __init__(cls, name, bases, dct):\n    \"\"\"\n    Initialize the registry collection by adding it-self as the registry collection\n    of all registries.\n\n    Parameters\n    ----------\n    name\n    bases\n    dct\n    \"\"\"\n    super().__init__(name, bases, dct)\n    for key, value in dct.items():\n        if isinstance(value, Registry):\n            value.registry = cls\n</code></pre>"},{"location":"reference/registry/#confit.registry.RegistryCollection","title":"<code>RegistryCollection</code>","text":"<p>A collection of registries.</p> <p>```python class MyRegistries(RegistryCollection):     my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True)     my_other_registry = Registry((\"package_name\", \"my_other_registry\"))</p>"},{"location":"reference/registry/#confit.registry.validate_arguments","title":"<code>validate_arguments</code>","text":"<p>Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing</p>"},{"location":"reference/registry/#confit.registry.validate_arguments--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>func</code> <p>The function or class to call</p> <p> TYPE: <code>Optional[Callable[P, R]]</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>The validation configuration object</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>invoker</code> <p>An optional invoker to apply on the validated function</p> <p> TYPE: <code>Optional[Callable[[Callable, Dict[str, Any]], Any]]</code> DEFAULT: <code>None</code> </p> <code>registry</code> <p>The registry to use to resolve the default parameters</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Draftable[P, R]]:</code> Source code in <code>confit/registry.py</code> <pre><code>def validate_arguments(\n    func: Optional[Callable[P, R]] = None,\n    *,\n    config: Dict = None,\n    invoker: Optional[Callable[[Callable, Dict[str, Any]], Any]] = None,\n    registry: Any = None,\n) -&gt; Callable[[Callable[P, R]], Draftable[P, R]]:\n    \"\"\"\n    Decorator to validate the arguments passed to a function and store the result\n    in a mapping from results to call parameters (allowing\n\n    Parameters\n    ----------\n    func: Optional[Callable[P, R]]\n        The function or class to call\n    config: Dict\n        The validation configuration object\n    invoker: Optional[Callable]\n        An optional invoker to apply on the validated function\n    registry: Any\n        The registry to use to resolve the default parameters\n\n    Returns\n    -------\n    Callable[[Callable[P, R]], Draftable[P, R]]:\n    \"\"\"\n    if config is None:\n        config = {}\n    config = {**config, \"arbitrary_types_allowed\": True}\n\n    def validate(_func: Callable) -&gt; Callable:\n        if isinstance(_func, type):\n            _func: type\n            vd = _func.__init__\n            while hasattr(vd, \"__wrapped__\"):\n                vd = vd.__wrapped__\n            vd = ValidatedFunction(vd, config)\n            vd.model.__name__ = _func.__name__\n            vd.raw_function = _func.__init__\n            if PYDANTIC_V1:\n                vd.model.__fields__[\"self\"].default = None\n            else:\n                vd.model.model_fields[\"self\"].default = None\n\n            # This function is called by Pydantic when asked to cast\n            # a value (most likely a dict) as a Model (most often during\n            # a function call)\n\n            old_get_validators = (\n                _func.__get_validators__\n                if hasattr(_func, \"__get_validators__\")\n                else None\n            )\n            old_get_pydantic_core_schema = (\n                _func.__get_pydantic_core_schema__\n                if hasattr(_func, \"__get_pydantic_core_schema__\")\n                else None\n            )\n\n            def __get_validators__():\n                \"\"\"\n                This function is called by Pydantic when asked to cast\n                a value (most likely a dict) as a Model (most often during\n                a function call)\n\n                Yields\n                -------\n                Callable\n                    The validator function\n                \"\"\"\n\n                def _validate(value):\n                    if isinstance(value, dict):\n                        value = Config(value).resolve(registry=registry)\n\n                    if old_get_validators is not None:\n                        for validator in old_get_validators():\n                            value = validator(value)\n\n                    if isinstance(value, _func):\n                        return value\n\n                    return _func(**value)\n\n                yield _validate\n\n            def __get_pydantic_core_schema__(*args, **kwargs):\n                from pydantic_core import core_schema\n\n                def pre_validate(value):\n                    if isinstance(value, dict):\n                        value = Config(value).resolve(registry=registry)\n                    return value\n\n                def post_validate(value):\n                    if isinstance(value, _func):\n                        return value\n\n                    return _func(**value)\n\n                return core_schema.chain_schema(\n                    [\n                        core_schema.no_info_plain_validator_function(pre_validate),\n                        *(\n                            (old_get_pydantic_core_schema(*args, **kwargs),)\n                            if old_get_pydantic_core_schema\n                            else (\n                                core_schema.no_info_plain_validator_function(fn)\n                                for fn in old_get_validators()\n                            )\n                            if old_get_validators is not None\n                            else ()\n                        ),\n                        core_schema.no_info_plain_validator_function(post_validate),\n                    ]\n                )\n\n            # This function is called when we do Model(variable=..., other=...)\n            @wraps(\n                vd.raw_function,\n                assigned=(\n                    \"__module__\",\n                    \"__name__\",\n                    \"__qualname__\",\n                    \"__doc__\",\n                    \"__annotations__\",\n                    \"__defaults__\",\n                    \"__kwdefaults__\",\n                ),\n            )\n            def wrapper_function(*args: Any, **kwargs: Any) -&gt; Any:\n                try:\n                    return _resolve_and_validate_call(\n                        args=args,\n                        kwargs=kwargs,\n                        pydantic_func=vd,\n                        use_self=True,\n                        invoker=invoker,\n                        callee=_func,\n                    )\n                except Exception as e:\n                    if not is_debug() and isinstance(\n                        e.__context__, (ValidationError, LegacyValidationError)\n                    ):\n                        e.__cause__ = None\n                        e.__suppress_context__ = True\n                    raise e.with_traceback(remove_lib_from_traceback(e.__traceback__))\n\n            @wraps(\n                vd.raw_function,\n                assigned=(\n                    \"__module__\",\n                    \"__name__\",\n                    \"__qualname__\",\n                    \"__doc__\",\n                    \"__annotations__\",\n                    \"__defaults__\",\n                    \"__kwdefaults__\",\n                ),\n            )\n            def draft(**kwargs):\n                return Draft[_func](_func, kwargs)\n\n            _func.vd = vd\n            if PYDANTIC_V1:\n                _func.__get_validators__ = __get_validators__\n            else:\n                _func.__get_pydantic_core_schema__ = __get_pydantic_core_schema__\n            # _func.model = vd.model\n            # _func.model.type_ = _func\n            _func.__init__ = wrapper_function\n            _func.__init__.__wrapped__ = vd.raw_function\n            _func.draft = draft\n            return _func\n\n        else:\n            vd = ValidatedFunction(_func, config)\n\n            @wraps(\n                _func,\n                assigned=(\n                    \"__module__\",\n                    \"__name__\",\n                    \"__qualname__\",\n                    \"__doc__\",\n                    \"__annotations__\",\n                    \"__defaults__\",\n                    \"__kwdefaults__\",\n                    \"__signature__\",\n                ),\n            )\n            def wrapper_function(*args: Any, **kwargs: Any) -&gt; Any:\n                try:\n                    return _resolve_and_validate_call(\n                        args=args,\n                        kwargs=kwargs,\n                        pydantic_func=vd,\n                        use_self=False,\n                        invoker=invoker,\n                        callee=_func,\n                    )\n                except Exception as e:\n                    if not is_debug() and isinstance(\n                        e.__cause__, (ValidationError, LegacyValidationError)\n                    ):\n                        e.__cause__ = None\n                        e.__suppress_context__ = True\n                    raise e.with_traceback(remove_lib_from_traceback(e.__traceback__))\n\n            @wraps(\n                vd.raw_function,\n                assigned=(\n                    \"__module__\",\n                    \"__name__\",\n                    \"__qualname__\",\n                    \"__doc__\",\n                    \"__annotations__\",\n                    \"__defaults__\",\n                    \"__kwdefaults__\",\n                ),\n            )\n            def draft(**kwargs):\n                return Draft(_func, kwargs)\n\n            wrapper_function.vd = vd  # type: ignore\n            wrapper_function.validate = vd.init_model_instance  # type: ignore\n            wrapper_function.__wrapped__ = vd.raw_function  # type: ignore\n            wrapper_function.model = vd.model  # type: ignore\n            wrapper_function.draft = draft\n            return wrapper_function\n\n    if func:\n        return validate(func)\n    else:\n        return validate\n</code></pre>"},{"location":"reference/registry/#confit.registry.get_default_registry","title":"<code>get_default_registry</code>","text":"<p>Get the default registered registry.</p> RETURNS DESCRIPTION <code>Registry</code> Source code in <code>confit/registry.py</code> <pre><code>def get_default_registry() -&gt; Any:\n    \"\"\"\n    Get the default registered registry.\n\n    Returns\n    -------\n    Registry\n    \"\"\"\n    return _default_registry\n</code></pre>"},{"location":"reference/registry/#confit.registry.set_default_registry","title":"<code>set_default_registry</code>","text":"<p>Set the default registered registry. This is used in <code>Config.resolve()</code> when no registry is provided.</p>"},{"location":"reference/registry/#confit.registry.set_default_registry--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>registry</code> <p> TYPE: <code>CustomRegistry</code> </p> RETURNS DESCRIPTION <code>Registry</code> Source code in <code>confit/registry.py</code> <pre><code>def set_default_registry(registry: CustomRegistry) -&gt; CustomRegistry:\n    \"\"\"\n    Set the default registered registry. This is used in\n    [`Config.resolve()`][confit.config.Config.resolve] when no registry is provided.\n\n    Parameters\n    ----------\n    registry: Registry\n\n    Returns\n    -------\n    Registry\n    \"\"\"\n    global _default_registry\n    _default_registry = registry\n    return registry\n</code></pre>"},{"location":"reference/typing/","title":"<code>confit.typing</code>","text":""},{"location":"reference/utils/","title":"<code>confit.utils</code>","text":""},{"location":"reference/utils/collections/","title":"<code>confit.utils.collections</code>","text":""},{"location":"reference/utils/collections/#confit.utils.collections.join_path","title":"<code>join_path</code>","text":"<p>Join a path into a string and quotes subpaths that contain dots.</p>"},{"location":"reference/utils/collections/#confit.utils.collections.join_path--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> RETURNS DESCRIPTION <code>str</code> Source code in <code>confit/utils/collections.py</code> <pre><code>def join_path(path):\n    \"\"\"\n    Join a path into a string and quotes subpaths that contain dots.\n\n    Parameters\n    ----------\n    path: Tuple[Union[int, str]]\n\n    Returns\n    -------\n    str\n    \"\"\"\n    return \".\".join(\n        repr(x) if not isinstance(x, str) or split_path(x.strip()) != (x,) else x\n        for x in path\n    )\n</code></pre>"},{"location":"reference/utils/collections/#confit.utils.collections.split_path","title":"<code>split_path</code>","text":"<p>Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string.</p>"},{"location":"reference/utils/collections/#confit.utils.collections.split_path--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>str</code> </p> Source code in <code>confit/utils/collections.py</code> <pre><code>def split_path(path: str) -&gt; Tuple[Union[int, str]]:\n    \"\"\"\n    Split a path around \".\" into a tuple of strings and ints.\n    If a sub-path is quoted, it will be returned as a full non-split string.\n\n    Parameters\n    ----------\n    path: str\n\n    Returns\n    -------\n\n    \"\"\"\n    offset = 0\n    result = []\n    for match in re.finditer(KEY_PART, str(path)):\n        assert match.start() == offset, f\"Malformed path: {path!r} in config\"\n        offset = match.end()\n        part = next((g for g in match.groups() if g is not None))\n        result.append(int(part) if part.isdigit() else part)\n        if offset == len(path):\n            break\n    return tuple(result)\n</code></pre>"},{"location":"reference/utils/collections/#confit.utils.collections.flatten_sections","title":"<code>flatten_sections</code>","text":"<p>Flatten a nested dict of dicts into a \"flat\" dict of dict.</p>"},{"location":"reference/utils/collections/#confit.utils.collections.flatten_sections--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>root</code> <p>The root dict to flatten</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, Any]]</code> Source code in <code>confit/utils/collections.py</code> <pre><code>def flatten_sections(root: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Flatten a nested dict of dicts into a \"flat\" dict of dict.\n\n    Parameters\n    ----------\n    root: Dict[str, Any]\n        The root dict to flatten\n\n    Returns\n    -------\n    Dict[str, Dict[str, Any]]\n    \"\"\"\n    res = collections.defaultdict(lambda: {})\n\n    def rec(d, path):\n        res.setdefault(join_path(path), {})\n        section = {}\n        for k, v in d.items():\n            if isinstance(v, dict):\n                rec(v, (*path, k))\n            else:\n                section[k] = v\n        res[join_path(path)].update(section)\n\n    rec(root, ())\n    root_level = res.pop(\"\", None)\n    if root_level is not None and len(root_level) &gt; 0:\n        raise Exception(\"Cannot dump root level config\", root_level)\n    return dict(res)\n</code></pre>"},{"location":"reference/utils/eval/","title":"<code>confit.utils.eval</code>","text":""},{"location":"reference/utils/eval/#confit.utils.eval.Transformer","title":"<code>Transformer</code>","text":"<p>           Bases: <code>NodeTransformer</code></p> <p>An ast NodeTransformer that only allows a subset of the Python AST.</p>"},{"location":"reference/utils/eval/#confit.utils.eval.Transformer.generic_visit","title":"<code>generic_visit</code>","text":"<p>Checks that the node type is allowed.</p> Source code in <code>confit/utils/eval.py</code> <pre><code>def generic_visit(self, node):\n    \"\"\"\n    Checks that the node type is allowed.\n    \"\"\"\n    nodetype = type(node).__name__\n    if nodetype not in self.ALLOWED_NODE_TYPES:\n        raise RuntimeError(f\"Invalid expression: {nodetype} not allowed !\")\n\n    return ast.NodeTransformer.generic_visit(self, node)\n</code></pre>"},{"location":"reference/utils/eval/#confit.utils.eval.safe_eval","title":"<code>safe_eval</code>","text":"<p>Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled.</p>"},{"location":"reference/utils/eval/#confit.utils.eval.safe_eval--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>source</code> <p>The expression to evaluate</p> <p> TYPE: <code>str</code> </p> <code>locals_dict</code> <p>The local variables to use in the evaluation</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The result of the evaluation</p> Source code in <code>confit/utils/eval.py</code> <pre><code>def safe_eval(source: str, locals_dict: Optional[Dict[str, Any]] = None):\n    \"\"\"\n    Evaluate a Python string expression in a safe way.\n    For instance, imports, function calls and builtins are disabled.\n\n\n    Parameters\n    ----------\n    source: str\n        The expression to evaluate\n    locals_dict: Optional[Dict[str, Any]]\n        The local variables to use in the evaluation\n\n    Returns\n    -------\n    Any\n        The result of the evaluation\n    \"\"\"\n    tree = ast.parse(source, mode=\"eval\")\n\n    transformer.visit(tree)\n    clause = compile(tree, \"&lt;AST&gt;\", \"eval\")\n    result = eval(clause, {\"__builtins__\": {}}, locals_dict)\n\n    return result\n</code></pre>"},{"location":"reference/utils/random/","title":"<code>confit.utils.random</code>","text":""},{"location":"reference/utils/random/#confit.utils.random.set_seed","title":"<code>set_seed</code>","text":"<p>Set seed values for random generators. If used as a context, restore the random state used before entering the context.</p>"},{"location":"reference/utils/random/#confit.utils.random.set_seed--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>seed</code> <p>Value used as a seed.</p> <p> </p> <code>cuda</code> <p>Saves the cuda random states too</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> Source code in <code>confit/utils/random.py</code> <pre><code>def __init__(self, seed, cuda: Optional[bool] = None):\n    \"\"\"\n    Set seed values for random generators.\n    If used as a context, restore the random state\n    used before entering the context.\n\n    Parameters\n    ----------\n    seed: int\n        Value used as a seed.\n    cuda: bool\n        Saves the cuda random states too\n    \"\"\"\n    # if seed is True:\n    #     seed = random.randint(1, 2**16)\n    seed = random.randint(1, 2**16) if seed is True else seed\n    self.state = get_random_generator_state(cuda)\n    if seed is not None:\n        random.seed(seed)\n        try:\n            import torch\n\n            torch.manual_seed(seed)\n            if cuda or (\n                cuda is None and torch.cuda.is_available()\n            ):  # pragma: no cover\n                torch.cuda.manual_seed(seed)\n                torch.cuda.manual_seed_all(seed)\n        except ImportError:  # pragma: no cover\n            pass\n        try:\n            import numpy\n\n            numpy.random.seed(seed)\n        except ImportError:  # pragma: no cover\n            pass\n</code></pre>"},{"location":"reference/utils/random/#confit.utils.random.get_random_generator_state","title":"<code>get_random_generator_state</code>","text":"<p>Get the <code>torch</code>, <code>numpy</code> and <code>random</code> random generator state.</p>"},{"location":"reference/utils/random/#confit.utils.random.get_random_generator_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>cuda</code> <p>Saves the cuda random states too</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>RandomGeneratorState</code> Source code in <code>confit/utils/random.py</code> <pre><code>def get_random_generator_state(cuda=None):\n    \"\"\"\n    Get the `torch`, `numpy` and `random` random generator state.\n    Parameters\n    ----------\n    cuda: bool\n        Saves the cuda random states too\n\n    Returns\n    -------\n    RandomGeneratorState\n    \"\"\"\n    torch_state = torch_cuda_state = numpy_state = None\n    random_state = random.getstate()\n    try:\n        import torch\n\n        torch_state = torch.random.get_rng_state()\n        if cuda or (cuda is None and torch.cuda.is_available()):  # pragma: no cover\n            torch_cuda_state = torch.cuda.get_rng_state_all()\n\n    except ImportError:  # pragma: no cover\n        pass\n    try:\n        import numpy\n\n        numpy_state = numpy.random.get_state()\n    except ImportError:  # pragma: no cover\n        pass\n    return RandomGeneratorState(\n        random_state,\n        torch_state,\n        numpy_state,\n        torch_cuda_state,\n    )\n</code></pre>"},{"location":"reference/utils/random/#confit.utils.random.set_random_generator_state","title":"<code>set_random_generator_state</code>","text":"<p>Set the <code>torch</code>, <code>numpy</code> and <code>random</code> random generator state.</p>"},{"location":"reference/utils/random/#confit.utils.random.set_random_generator_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>state</code> Source code in <code>confit/utils/random.py</code> <pre><code>def set_random_generator_state(state):\n    \"\"\"\n    Set the `torch`, `numpy` and `random` random generator state.\n    Parameters\n    ----------\n    state: RandomGeneratorState\n    \"\"\"\n    random.setstate(state.random)\n    if state.torch is not None:\n        import torch\n\n        torch.random.set_rng_state(state.torch)\n        if (\n            state.torch_cuda is not None\n            and torch.cuda.is_available()\n            and len(state.torch_cuda) == torch.cuda.device_count()\n        ):  # pragma: no cover\n            torch.cuda.set_rng_state_all(state.torch_cuda)\n    if state.numpy is not None:\n        import numpy\n\n        numpy.random.set_state(state.numpy)\n</code></pre>"},{"location":"reference/utils/settings/","title":"<code>confit.utils.settings</code>","text":""},{"location":"reference/utils/xjson/","title":"<code>confit.utils.xjson</code>","text":""},{"location":"reference/utils/xjson/#confit.utils.xjson.Reference","title":"<code>Reference</code>","text":"<p>A path reference to a value in the configuration.</p>"},{"location":"reference/utils/xjson/#confit.utils.xjson.Reference--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>value</code> <p>The path to the value in the configuration.</p> <p> TYPE: <code>str</code> </p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def __init__(self, value: str):\n    \"\"\"\n    Parameters\n    ----------\n    value: str\n        The path to the value in the configuration.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer","title":"<code>XJsonTransformer</code>","text":"<p>           Bases: <code>Transformer</code></p> <p>A Lark transformer to parse extended JSON.</p>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>input_string</code> <p>The input string to parse.</p> <p> TYPE: <code>str</code> </p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def __init__(self, input_string: str):\n    \"\"\"\n    Parameters\n    ----------\n    input_string: str\n        The input string to parse.\n    \"\"\"\n    super().__init__()\n    self.input_string = input_string\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.string","title":"<code>string</code>","text":"<p>Parse string</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def string(self, s):\n    \"\"\"Parse string\"\"\"\n    (s,) = s\n    return ast.literal_eval(s)\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.float","title":"<code>float</code>","text":"<p>Parse number</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def float(self, n):\n    \"\"\"Parse number\"\"\"\n    (n,) = n\n    return float(n)\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.int","title":"<code>int</code>","text":"<p>Parse number</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def int(self, n):\n    \"\"\"Parse number\"\"\"\n    (n,) = n\n    return int(n)\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.reference","title":"<code>reference</code>","text":"<p>Parse reference</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def reference(self, tree: Tree):\n    \"\"\"Parse reference\"\"\"\n    meta = tree[0].meta\n    return Reference(self.input_string[meta.start_pos : meta.end_pos].strip())\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.null","title":"<code>null</code>","text":"<p>Parse null</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def null(self, _):\n    \"\"\"Parse null\"\"\"\n    return None\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.true","title":"<code>true</code>","text":"<p>Parse true</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def true(self, _):\n    \"\"\"Parse true\"\"\"\n    return True\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.false","title":"<code>false</code>","text":"<p>Parse false</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def false(self, _):\n    \"\"\"Parse false\"\"\"\n    return False\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.plus_inf","title":"<code>plus_inf</code>","text":"<p>Parse infinity</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def plus_inf(self, _):\n    \"\"\"Parse infinity\"\"\"\n    return float(\"inf\")\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.minus_inf","title":"<code>minus_inf</code>","text":"<p>Parse -infinity</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def minus_inf(self, _):\n    \"\"\"Parse -infinity\"\"\"\n    return -float(\"inf\")\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.XJsonTransformer.nan","title":"<code>nan</code>","text":"<p>Parse nan</p> Source code in <code>confit/utils/xjson.py</code> <pre><code>def nan(self, _):\n    \"\"\"Parse nan\"\"\"\n    return float(\"nan\")\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.loads","title":"<code>loads</code>","text":"<p>Load an extended JSON string into a python object. Takes care of detecting references and tuples</p>"},{"location":"reference/utils/xjson/#confit.utils.xjson.loads--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>s</code> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> Source code in <code>confit/utils/xjson.py</code> <pre><code>def loads(s: str):\n    \"\"\"\n    Load an extended JSON string into a python object.\n    Takes care of detecting references and tuples\n\n    Parameters\n    ----------\n    s: str\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    try:\n        return XJsonTransformer(s).transform(_json_parser.parse(s))\n    except Exception:\n        if \"\\n\" in s or \"\\r\" in s:\n            return s\n        # Fail if we suspect that it is a malformed object\n        # (e.g. has ', \", {, }, [, ] in it)\n        if set(s) &amp; set(\",'\\\"{}[]$\"):\n            raise MalformedValueError(s)\n        return s\n</code></pre>"},{"location":"reference/utils/xjson/#confit.utils.xjson.dumps","title":"<code>dumps</code>","text":"<p>Dump a python object into an extended JSON string. Takes care of serializing references and tuples</p>"},{"location":"reference/utils/xjson/#confit.utils.xjson.dumps--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>o</code> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>str</code> Source code in <code>confit/utils/xjson.py</code> <pre><code>def dumps(o: Any):\n    \"\"\"\n    Dump a python object into an extended JSON string.\n    Takes care of serializing references and tuples\n\n    Parameters\n    ----------\n    o: Any\n\n    Returns\n    -------\n    str\n    \"\"\"\n    res = \"\".join(_make_iterencode()(o))\n    return res\n</code></pre>"},{"location":"reference/confit/","title":"<code>confit</code>","text":""},{"location":"reference/confit/cli/","title":"<code>confit.cli</code>","text":""},{"location":"reference/confit/cli/#confit.cli.Cli","title":"<code>Cli</code>","text":"<p>           Bases: <code>Typer</code></p> <p>Custom Typer object that:</p> <ul> <li>validates a command parameters before executing it</li> <li>accepts a configuration file describing the parameters</li> <li>automatically instantiates parameters given a dictionary when type hinted</li> </ul>"},{"location":"reference/confit/cli/#confit.cli.parse_overrides","title":"<code>parse_overrides</code>","text":"<p>Parse the overrides from the command line into a dictionary of key-value pairs.</p>"},{"location":"reference/confit/cli/#confit.cli.parse_overrides--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>args</code> <p>The arguments to parse</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The parsed overrides as a dictionary</p>"},{"location":"reference/confit/config/","title":"<code>confit.config</code>","text":""},{"location":"reference/confit/config/#confit.config.Config","title":"<code>Config</code>","text":"<p>           Bases: <code>dict</code></p> <p>The configuration system consists of a supercharged dict, the <code>Config</code> class, that can be used to read and write to <code>cfg</code> files, interpolate variables and instantiate components through the registry with some special <code>@factory</code> keys. A cfg file can be used directly as an input to a CLI-decorated function.</p> <p>A new config object can be instantiated either from a dict as a positional argument, or from keyword arguments. Only one of these two options can be used at a time.</p>"},{"location":"reference/confit/config/#confit.config.Config--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>args</code> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p>"},{"location":"reference/confit/config/#confit.config.Config.from_cfg_str","title":"<code>from_cfg_str</code>  <code>classmethod</code>","text":"<p>Load a config object from a config string</p>"},{"location":"reference/confit/config/#confit.config.Config.from_cfg_str--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>s</code> <p>The cfg config string</p> <p> TYPE: <code>str</code> </p> <code>resolve</code> <p>Whether to resolve sections with '@' keys</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>registry</code> <p>Optional registry to resolve from. If None, the default registry will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Config</code>"},{"location":"reference/confit/config/#confit.config.Config.from_disk","title":"<code>from_disk</code>  <code>classmethod</code>","text":"<p>Load a config object from a '.cfg' file</p>"},{"location":"reference/confit/config/#confit.config.Config.from_disk--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p>The path to the config object</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>resolve</code> <p>Whether to resolve mappings with '@' keys</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>registry</code> <p>Optional registry to resolve from. If None, the default registry will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Config</code>"},{"location":"reference/confit/config/#confit.config.Config.to_disk","title":"<code>to_disk</code>","text":"<p>Export a config to the disk (usually to a .cfg file)</p>"},{"location":"reference/confit/config/#confit.config.Config.to_disk--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>Union[str, Path]</code> </p>"},{"location":"reference/confit/config/#confit.config.Config.serialize","title":"<code>serialize</code>","text":"<p>Try to convert non-serializable objects using the RESOLVED_TO_CONFIG object back to their original catalogue + params form</p> <p>We try to preserve referential equalities between non dict/list/tuple objects by serializing subsequent references to the same object as references to its first occurrence in the tree.</p> <pre><code>a = A()  # serializable object\ncfg = {\"a\": a, \"b\": a}\nprint(Config.serialize(cfg))\n# Out: {\"a\": {...}, \"b\": Reference(\"a\")}\n</code></pre> RETURNS DESCRIPTION <code>Config</code>"},{"location":"reference/confit/config/#confit.config.Config.to_cfg_str","title":"<code>to_cfg_str</code>","text":"<p>Export a config to a string in the cfg format by serializing it first</p> RETURNS DESCRIPTION <code>str</code>"},{"location":"reference/confit/config/#confit.config.Config.resolve","title":"<code>resolve</code>","text":"<p>Resolves the parts of the nested config object with @ variables using a registry, and then interpolate references in the config.</p>"},{"location":"reference/confit/config/#confit.config.Config.resolve--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>deep</code> <p>Should we resolve deeply</p> <p> DEFAULT: <code>True</code> </p> <code>registry</code> <p>Registry to use when resolving</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>root</code> <p>The root of the config tree. Used for resolving references.</p> <p> TYPE: <code>Mapping</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[Config, Any]</code>"},{"location":"reference/confit/config/#confit.config.Config.merge","title":"<code>merge</code>","text":"<p>Deep merge two configs. Heavily inspired from <code>thinc</code>'s config merge function.</p>"},{"location":"reference/confit/config/#confit.config.Config.merge--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>updates</code> <p>Configs to update the original config</p> <p> TYPE: <code>Union[Dict[str, Any], Config]</code> DEFAULT: <code>()</code> </p> <code>remove_extra</code> <p>If true, restricts update to keys that existed in the original config</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>The new config</code>"},{"location":"reference/confit/config/#confit.config.Config.copy","title":"<code>copy</code>","text":"<p>Deep copy of the config, but not of the underlying data. Should also work with other types of objects (e.g. lists, tuples, etc.)</p> <pre><code>Config.copy([1, 2, {\"ok\": 3}}]) == [1, 2, {\"ok\": 3}]\n</code></pre> RETURNS DESCRIPTION <code>Any</code>"},{"location":"reference/confit/config/#confit.config.merge_from_disk","title":"<code>merge_from_disk</code>","text":"<p>Merge multiple configs loaded from the filesystem and return the merged config as well as the name of the config</p>"},{"location":"reference/confit/config/#confit.config.merge_from_disk--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>config_paths</code> <p>Paths to the config files</p> <p> TYPE: <code>Union[Path, List[Path]]</code> </p> <code>returned_name</code> <p>If \"first\", the name of the first config is returned as the name of the merged config. If \"concat\", the names of the configs are concatenated with a \"+\" sign</p> <p> TYPE: <code>str</code> DEFAULT: <code>'first'</code> </p>"},{"location":"reference/confit/draft/","title":"<code>confit.draft</code>","text":""},{"location":"reference/confit/draft/#confit.draft.MetaDraft","title":"<code>MetaDraft</code>","text":"<p>           Bases: <code>type</code></p> <p>A metaclass for Draft that allows the user to create specify the type the Draft should become when instantiated.</p> <p>In addition to allowing static typing, this metaclass also provides a way to validate the Draft object when used in combination with pydantic validation.</p>"},{"location":"reference/confit/draft/#confit.draft.MetaDraft--examples","title":"Examples","text":"<pre><code>from confit import Draft\n\n\n@validate_arguments\ndef make_hi(name, prefix) -&gt; str:\n    return prefix + \" \" + name\n\n\n@validate_arguments\ndef print_hi(param: Draft[str]):\n    val = param.instantiate(prefix=\"Hello\")\n    print(val)\n\n\nprint_hi(make_hi.draft(name=\"John\"))\n</code></pre>"},{"location":"reference/confit/draft/#confit.draft.Draft","title":"<code>Draft</code>","text":"<p>           Bases: <code>Generic[R]</code></p> <p>A Draft is a placeholder for a value that has not been instantiated yet, likely because it is missing an argument that will be provided later by the library.</p>"},{"location":"reference/confit/draft/#confit.draft.Draft.instantiate","title":"<code>instantiate</code>","text":"<p>Finalize the Draft object into an instance of the expected type using the provided arguments. The new arguments are merged with the existing ones, with the old ones taking precedence. The rationale for this is that the user makes the Draft, and the library completes any missing arguments.</p>"},{"location":"reference/confit/errors/","title":"<code>confit.errors</code>","text":""},{"location":"reference/confit/errors/#confit.errors.MissingReference","title":"<code>MissingReference</code>","text":"<p>           Bases: <code>Exception</code></p> <p>Raised when one or multiple references cannot be resolved.</p>"},{"location":"reference/confit/errors/#confit.errors.MissingReference--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>ref</code> <p>The reference that could not be resolved.</p> <p> TYPE: <code>Reference</code> </p>"},{"location":"reference/confit/errors/#confit.errors.MissingReference.__str__","title":"<code>__str__</code>","text":"<p>String representation of the exception</p>"},{"location":"reference/confit/errors/#confit.errors.CyclicReferenceError","title":"<code>CyclicReferenceError</code>","text":"<p>           Bases: <code>Exception</code></p> <p>Raised when a cyclic reference is detected.</p>"},{"location":"reference/confit/errors/#confit.errors.CyclicReferenceError--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p>The path of the cyclic reference</p> <p> TYPE: <code>Loc</code> </p>"},{"location":"reference/confit/errors/#confit.errors.CyclicReferenceError.__str__","title":"<code>__str__</code>","text":"<p>String representation of the exception</p>"},{"location":"reference/confit/errors/#confit.errors.remove_lib_from_traceback","title":"<code>remove_lib_from_traceback</code>","text":"<p>Remove the lib folder from the traceback</p>"},{"location":"reference/confit/errors/#confit.errors.to_legacy_error","title":"<code>to_legacy_error</code>","text":"<p>Decorator to convert a Pydantic ValidationError into a ConfitValidationError</p>"},{"location":"reference/confit/errors/#confit.errors.patch_errors","title":"<code>patch_errors</code>","text":"<p>Patch the location of the errors to add the <code>path</code> prefix and complete the errors with the actual value if it is available. This is useful when the errors are raised in a sub-dict of the config.</p>"},{"location":"reference/confit/errors/#confit.errors.patch_errors--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>errors</code> <p>The pydantic errors to patch</p> <p> TYPE: <code>T</code> </p> <code>path</code> <p>The path to add to the errors</p> <p> TYPE: <code>Loc</code> DEFAULT: <code>()</code> </p> <code>values</code> <p>The values of the config</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>special_names</code> <p>The names of the special keys of the model signature, to replace with a wildcard when encountered in the error path</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>model</code> <p>The model of the config</p> <p> TYPE: <code>Optional[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>drop_names</code> <p>The names of the keys to drop from the error path</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Union[ValidationError, Sequence[ErrorWrapper], ErrorWrapper]</code> <p>The patched errors</p>"},{"location":"reference/confit/registry/","title":"<code>confit.registry</code>","text":""},{"location":"reference/confit/registry/#confit.registry.VisibleDeprecationWarning","title":"<code>VisibleDeprecationWarning</code>","text":"<p>           Bases: <code>UserWarning</code></p> <p>Visible deprecation warning.</p> <p>By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug.</p> <p>Copied from https://github.com/numpy/numpy/blob/965b41d418e6100c1afae0b6f818a7ef152bc25d/numpy/_globals.py#L44-L51</p>"},{"location":"reference/confit/registry/#confit.registry.Registry","title":"<code>Registry</code>","text":"<p>           Bases: <code>Registry</code></p> <p>A registry that validates the input arguments of the registered functions.</p> <p>Initialize the registry.</p>"},{"location":"reference/confit/registry/#confit.registry.Registry--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>namespace</code> <p>The namespace of the registry</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>entry_points</code> <p>Should we use entry points to load the registered functions</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/confit/registry/#confit.registry.Registry.register","title":"<code>register</code>","text":"<p>This is a convenience wrapper around <code>catalogue.Registry.register</code>, that additionally validates the input arguments of the registered function and saves the result of any call to a mapping to its arguments.</p>"},{"location":"reference/confit/registry/#confit.registry.Registry.register--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>name</code> <p>The name of the function</p> <p> TYPE: <code>str</code> </p> <code>func</code> <p>The function to register</p> <p> TYPE: <code>Optional[Union[Callable[P, R], Type[R]]]</code> DEFAULT: <code>None</code> </p> <code>save_params</code> <p>Additional parameters to save when the function is called. If falsy, the function parameters are not saved</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>skip_save_params</code> <p>List of parameters to skip when saving the function parameters</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>invoker</code> <p>An optional invoker to apply to the function before registering it. It is better to use this than to apply the invoker to the function to preserve the signature of the function or the class and enable validating its parameters.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>deprecated</code> <p>The deprecated registry names for the function</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p>"},{"location":"reference/confit/registry/#confit.registry.Registry.get_entry_points","title":"<code>get_entry_points</code>","text":"<p>Get registered entry points from other packages for this namespace.</p> <p>RETURNS (Dict[str, Any]): Entry points, keyed by name.</p>"},{"location":"reference/confit/registry/#confit.registry.Registry.get","title":"<code>get</code>","text":"<p>Get the registered function for a given name.</p> <p>Modified from catalogue.Registry.get to avoid importing all entry points when lookup fails, but rather list the available entry points.</p>"},{"location":"reference/confit/registry/#confit.registry.Registry.get--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>name</code> <p>The name of the function</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Func</code>"},{"location":"reference/confit/registry/#confit.registry.Registry.get_available","title":"<code>get_available</code>","text":"<p>Get all functions for a given namespace.</p> <p>namespace (Tuple[str]): The namespace to get. RETURNS (Dict[str, Any]): The functions, keyed by name.</p>"},{"location":"reference/confit/registry/#confit.registry.MetaRegistryCollection","title":"<code>MetaRegistryCollection</code>","text":"<p>           Bases: <code>type</code></p> <p>A metaclass for the registry collection that adds it as the registry collection of all registries defined in the body of the class.</p> <p>Initialize the registry collection by adding it-self as the registry collection of all registries.</p>"},{"location":"reference/confit/registry/#confit.registry.MetaRegistryCollection--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>name</code> <code>bases</code> <code>dct</code>"},{"location":"reference/confit/registry/#confit.registry.RegistryCollection","title":"<code>RegistryCollection</code>","text":"<p>A collection of registries.</p> <p>```python class MyRegistries(RegistryCollection):     my_registry = Registry((\"package_name\", \"my_registry\"), entry_points=True)     my_other_registry = Registry((\"package_name\", \"my_other_registry\"))</p>"},{"location":"reference/confit/registry/#confit.registry.validate_arguments","title":"<code>validate_arguments</code>","text":"<p>Decorator to validate the arguments passed to a function and store the result in a mapping from results to call parameters (allowing</p>"},{"location":"reference/confit/registry/#confit.registry.validate_arguments--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>func</code> <p>The function or class to call</p> <p> TYPE: <code>Optional[Callable[P, R]]</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>The validation configuration object</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>invoker</code> <p>An optional invoker to apply on the validated function</p> <p> TYPE: <code>Optional[Callable[[Callable, Dict[str, Any]], Any]]</code> DEFAULT: <code>None</code> </p> <code>registry</code> <p>The registry to use to resolve the default parameters</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Draftable[P, R]]:</code>"},{"location":"reference/confit/registry/#confit.registry.get_default_registry","title":"<code>get_default_registry</code>","text":"<p>Get the default registered registry.</p> RETURNS DESCRIPTION <code>Registry</code>"},{"location":"reference/confit/registry/#confit.registry.set_default_registry","title":"<code>set_default_registry</code>","text":"<p>Set the default registered registry. This is used in <code>Config.resolve()</code> when no registry is provided.</p>"},{"location":"reference/confit/registry/#confit.registry.set_default_registry--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>registry</code> <p> TYPE: <code>CustomRegistry</code> </p> RETURNS DESCRIPTION <code>Registry</code>"},{"location":"reference/confit/typing/","title":"<code>confit.typing</code>","text":""},{"location":"reference/confit/utils/","title":"<code>confit.utils</code>","text":""},{"location":"reference/confit/utils/collections/","title":"<code>confit.utils.collections</code>","text":""},{"location":"reference/confit/utils/collections/#confit.utils.collections.join_path","title":"<code>join_path</code>","text":"<p>Join a path into a string and quotes subpaths that contain dots.</p>"},{"location":"reference/confit/utils/collections/#confit.utils.collections.join_path--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> RETURNS DESCRIPTION <code>str</code>"},{"location":"reference/confit/utils/collections/#confit.utils.collections.split_path","title":"<code>split_path</code>","text":"<p>Split a path around \".\" into a tuple of strings and ints. If a sub-path is quoted, it will be returned as a full non-split string.</p>"},{"location":"reference/confit/utils/collections/#confit.utils.collections.split_path--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>str</code> </p>"},{"location":"reference/confit/utils/collections/#confit.utils.collections.flatten_sections","title":"<code>flatten_sections</code>","text":"<p>Flatten a nested dict of dicts into a \"flat\" dict of dict.</p>"},{"location":"reference/confit/utils/collections/#confit.utils.collections.flatten_sections--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>root</code> <p>The root dict to flatten</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, Any]]</code>"},{"location":"reference/confit/utils/eval/","title":"<code>confit.utils.eval</code>","text":""},{"location":"reference/confit/utils/eval/#confit.utils.eval.Transformer","title":"<code>Transformer</code>","text":"<p>           Bases: <code>NodeTransformer</code></p> <p>An ast NodeTransformer that only allows a subset of the Python AST.</p>"},{"location":"reference/confit/utils/eval/#confit.utils.eval.Transformer.generic_visit","title":"<code>generic_visit</code>","text":"<p>Checks that the node type is allowed.</p>"},{"location":"reference/confit/utils/eval/#confit.utils.eval.safe_eval","title":"<code>safe_eval</code>","text":"<p>Evaluate a Python string expression in a safe way. For instance, imports, function calls and builtins are disabled.</p>"},{"location":"reference/confit/utils/eval/#confit.utils.eval.safe_eval--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>source</code> <p>The expression to evaluate</p> <p> TYPE: <code>str</code> </p> <code>locals_dict</code> <p>The local variables to use in the evaluation</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The result of the evaluation</p>"},{"location":"reference/confit/utils/random/","title":"<code>confit.utils.random</code>","text":""},{"location":"reference/confit/utils/random/#confit.utils.random.set_seed","title":"<code>set_seed</code>","text":"<p>Set seed values for random generators. If used as a context, restore the random state used before entering the context.</p>"},{"location":"reference/confit/utils/random/#confit.utils.random.set_seed--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>seed</code> <p>Value used as a seed.</p> <p> </p> <code>cuda</code> <p>Saves the cuda random states too</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/confit/utils/random/#confit.utils.random.get_random_generator_state","title":"<code>get_random_generator_state</code>","text":"<p>Get the <code>torch</code>, <code>numpy</code> and <code>random</code> random generator state.</p>"},{"location":"reference/confit/utils/random/#confit.utils.random.get_random_generator_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>cuda</code> <p>Saves the cuda random states too</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>RandomGeneratorState</code>"},{"location":"reference/confit/utils/random/#confit.utils.random.set_random_generator_state","title":"<code>set_random_generator_state</code>","text":"<p>Set the <code>torch</code>, <code>numpy</code> and <code>random</code> random generator state.</p>"},{"location":"reference/confit/utils/random/#confit.utils.random.set_random_generator_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>state</code>"},{"location":"reference/confit/utils/settings/","title":"<code>confit.utils.settings</code>","text":""},{"location":"reference/confit/utils/xjson/","title":"<code>confit.utils.xjson</code>","text":""},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.Reference","title":"<code>Reference</code>","text":"<p>A path reference to a value in the configuration.</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.Reference--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>value</code> <p>The path to the value in the configuration.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer","title":"<code>XJsonTransformer</code>","text":"<p>           Bases: <code>Transformer</code></p> <p>A Lark transformer to parse extended JSON.</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>input_string</code> <p>The input string to parse.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.string","title":"<code>string</code>","text":"<p>Parse string</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.float","title":"<code>float</code>","text":"<p>Parse number</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.int","title":"<code>int</code>","text":"<p>Parse number</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.reference","title":"<code>reference</code>","text":"<p>Parse reference</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.null","title":"<code>null</code>","text":"<p>Parse null</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.true","title":"<code>true</code>","text":"<p>Parse true</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.false","title":"<code>false</code>","text":"<p>Parse false</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.plus_inf","title":"<code>plus_inf</code>","text":"<p>Parse infinity</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.minus_inf","title":"<code>minus_inf</code>","text":"<p>Parse -infinity</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.XJsonTransformer.nan","title":"<code>nan</code>","text":"<p>Parse nan</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.loads","title":"<code>loads</code>","text":"<p>Load an extended JSON string into a python object. Takes care of detecting references and tuples</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.loads--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>s</code> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.dumps","title":"<code>dumps</code>","text":"<p>Dump a python object into an extended JSON string. Takes care of serializing references and tuples</p>"},{"location":"reference/confit/utils/xjson/#confit.utils.xjson.dumps--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>o</code> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>str</code>"}]}